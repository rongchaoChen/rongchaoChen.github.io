<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>web布局</title>
      <link href="/2023/10/19/web%E5%B8%83%E5%B1%80/"/>
      <url>/2023/10/19/web%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="web布局"><a href="#web布局" class="headerlink" title="web布局"></a>web布局</h1><p>最早期的互联网的页面是没有css布局的,仅仅以超文本语言来构建页面.这也导致<code>html</code> 本身的原始规范基本不具备能准确控制页面的布局能力.</p><p>早期的web 设计时代, web 页面上的信息元素都是按照正常的流排序来组织的, 它没有色块, 没有图形,只有文字.</p><h2 id="表格布局"><a href="#表格布局" class="headerlink" title="表格布局"></a>表格布局</h2><p>互联网的发展是快速的, 在html2.0 之后, 新增了图片<code>&lt;img&gt;</code>  表单<code>&lt;from&gt;</code> 和表格<code>&lt;table&gt;</code></p><p>后面用于展示数据的表格被用于web 的布局上, 且越来越受欢迎. 这个时候表格布局诞生了.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>顶部<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span>&gt;</span>左列<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span>&gt;</span>右列<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202310200015840.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202310200015840.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>虽然<code>&lt;table&gt;</code> 表格再布局上有着天生的不足, 但是它却改变了web 设计的历史, 因为这时候起诞生了web 布局这样一个概念.</p><p>然后再后来, 网景和微软发动了对html 的改革, 淘汰了展示用的html 标签, 这时候与html 结构分离的联级样式随之到来.</p><p>1996 年层叠样式表<code>css</code> 诞生, 允许了我们将WEB 页面结构<code>HTML</code>和样式信息<code>CSS</code> 分开. 样式规则可以保存至单独的文档</p><h2 id="浮动布局"><a href="#浮动布局" class="headerlink" title="浮动布局"></a>浮动布局</h2>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue</title>
      <link href="/2023/10/08/vue/"/>
      <url>/2023/10/08/vue/</url>
      
        <content type="html"><![CDATA[<h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h3 id="文本插值"><a href="#文本插值" class="headerlink" title="文本插值"></a>文本插值</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>message &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">const msg = ref(&#x27;hello&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>双大括号中的标签会被替换为相应组件实例中<code>msg</code> 的值,同时每次更改msg 的值的时候, 它也会同步更新</p><h3 id="原始HTML"><a href="#原始HTML" class="headerlink" title="原始HTML"></a>原始HTML</h3><p>在vue 中双大括号会将数据解释为纯文本, 而不是html. 如果先插入html.则需要用到<code>v-html</code>指令</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rawHtml = <span class="title function_">ref</span>(<span class="string">`&lt;span style=&quot;color: red&quot;&gt;This should be red.&lt;/span&gt;`</span>);</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using text interpolation: &#123;&#123; rawHtml &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using v-html directive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;rawHtml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在没有使用 <code>v-html</code> 标签的时候, 双大括号中的<code>rawhtml</code> 不会被解析成html 内容, 而是以纯文本的方式展现, 在使用了<code>v-html</code> 的标签, 则会把双大括号中的<code>rawhtml</code>解析成html 标签渲染出来.</p><p><img src="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202311181108858.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202311181108858.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="Attribute-绑定"><a href="#Attribute-绑定" class="headerlink" title="Attribute 绑定"></a>Attribute 绑定</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;dynamicId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>v-bind 指令可以将vue 的元素的id attribte 与组件的 id 属性保持一致, 如果绑定时的值是null  或者是undefined, 那么这个attribute 将会从渲染的元素移除</p><h4 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:id</span>=<span class="string">&quot;dynamicId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="布尔型Attribute"><a href="#布尔型Attribute" class="headerlink" title="布尔型Attribute"></a>布尔型Attribute</h4><p>布尔型的attribute 依据true 和false 来决定attribute 是否存在该元素上</p><h4 id="动态绑定多个值"><a href="#动态绑定多个值" class="headerlink" title="动态绑定多个值"></a>动态绑定多个值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> attributes = &#123;</span><br><span class="line"><span class="keyword">class</span> = <span class="string">&#x27;box&#x27;</span>,</span><br><span class="line">id = <span class="string">&#x27;content&#x27;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;div v-bind = <span class="string">&quot;attributes&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>这时候该元素就被同时被绑定上<code>class</code>, <code>id</code> 属性</p><p><img src="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202311201435490.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202311201435490.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="指令Dirctives"><a href="#指令Dirctives" class="headerlink" title="指令Dirctives"></a>指令Dirctives</h3><h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><h3 id="ref"><a href="#ref" class="headerlink" title="ref()"></a>ref()</h3><p>在vue3 组合式中推荐使用<code>ref()</code> 函数来声明响应式状态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br></pre></td></tr></table></figure><p>在<code>ref() </code>接受参数的时候 , 包裹一个带有<code>.value</code>属性的ref 对象返回.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">      count.<span class="property">value</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count,</span><br><span class="line">      increment,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="lt-script-setup-gt"><a href="#lt-script-setup-gt" class="headerlink" title="&lt;script setup&gt;"></a>&lt;script setup&gt;</h3><p>在上面的例子, 在<code>setup</code> 函数中暴露大量的状态和方法稍显繁琐, 但是,在v3 中可以使用单文件组件(sfc) 来避免这种情况,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br></pre></td></tr></table></figure><blockquote><p>这时候只需要在顶层script 标签中添加一个 <code>setup</code>  </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">const count = ref(0)</span><br><span class="line">function increment()&#123;</span><br><span class="line">  count.value+=</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="深层响应式"><a href="#深层响应式" class="headerlink" title="深层响应式"></a>深层响应式</h3><p>ref 可以持有任何类型的值, 包括深层嵌套的对象, 数组或者javascript 内置的数据结构.</p><p>ref 会使它的值具有深层响应性, 意味着即使改变嵌套对象或者数组时, 变化也会被检测到.</p><h3 id="DOM-更新时机"><a href="#DOM-更新时机" class="headerlink" title="DOM 更新时机"></a>DOM 更新时机</h3><p>当修改了响应式式状态时, dom 会自动更新, 但是需要注意的时, dom 的更新不是同步的, </p><p>vue会咋爱<code>next tick</code> 更新周期中缓冲所有状态的修改, 以确保不管进行了多少次状态修改 , 每个组件都只会被更新一次.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123;nextTick&#125; from &#x27;vue&#x27;</span><br><span class="line">async function increment()&#123;</span><br><span class="line">count.vaule++;</span><br><span class="line">awit nextTick()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><p>reactive 和可以将内部的值包装在特殊对象中的ref 不同. reactive 可以使对象本身具有响应性.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;<span class="attr">count</span>:<span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line">&lt;button @click=<span class="string">&#x27;state.count++&#x27;</span>&gt;&#123;&#123;  state.<span class="property">count</span> &#125;&#125;&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>reactive 响应式对象是javascript 的代理, 其行为就和普通的对象一样, 不同的是vue 可以拦截对响应式对象所有属性的访问和修改, 方便进行依赖追踪和出发更新.</p><h4 id="Reactive-Proxy-vs-Original"><a href="#Reactive-Proxy-vs-Original" class="headerlink" title="Reactive Proxy vs. Original"></a>Reactive Proxy vs. Original</h4><p>reactive返回的是一个原始对象的Proxy . 它和原始对象是不相等的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> raw = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="title function_">reactive</span>(raw);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy === raw); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>也就是说在vue 中只有代理对象是响应式的, 更改原始对象的时候, 不会触发代理对象的更新,所以在使用<code>reactive</code> 响应式的时候在,最好是只使用声明对象的代理版本.</p><p>在对同一个原始对象使用<code>reactive</code>的时候总是会返回同样的代理对象, 而对一个已存在的代理对象调用<code>reactive()</code> 会返回本身</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> raw = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="title function_">reactive</span>(raw);</span><br><span class="line"><span class="comment">// 在同一个对象上调用reactive() 会返回相同的代理</span></span><br><span class="line"><span class="title function_">reactive</span>(raw) === proxy <span class="comment">// true</span></span><br><span class="line"><span class="comment">//在一个代理上调用reactive() 会返回自己</span></span><br><span class="line"><span class="title function_">reactive</span>(proxy)  === proxy <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="reactive-局限性"><a href="#reactive-局限性" class="headerlink" title="reactive 局限性"></a>reactive 局限性</h4><h5 id="有限的值类型"><a href="#有限的值类型" class="headerlink" title="有限的值类型"></a>有限的值类型</h5><p>它只能用对象类型, 不能持有(string, number, boolean) 这样的原始类型</p><h5 id="不能替换整个对象"><a href="#不能替换整个对象" class="headerlink" title="不能替换整个对象"></a>不能替换整个对象</h5><p>由于vue 的响应式式跟踪通过属性访问实现的, 所以在引用的时候必须始终保持对响应式对象的相同引用.如果更换了响应式对象, 那么与之前引用的响应性连接则会丢失.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> state = <span class="title function_">reactive</span>(&#123;<span class="attr">count</span>:<span class="number">0</span>&#125;)</span><br><span class="line"><span class="comment">// 上面的&#123;count: 0&#125; 引用不会在被跟踪, 响应性链接已经丢失</span></span><br><span class="line">state = <span class="title function_">reactive</span>(&#123;<span class="attr">count</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><h5 id="对解构不友好"><a href="#对解构不友好" class="headerlink" title="对解构不友好"></a>对解构不友好</h5><p>当响应式对象的原始类型结构为本地变量的时候, 或者将 该属性传递给函数的时候, 响应性连接也会丢失</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const state = reactive(&#123;count:0&#125;)</span><br><span class="line">// 解构式, count 会和state.count 断开连接</span><br><span class="line">let &#123;count&#125; = state</span><br><span class="line">// 但是不会原始的state</span><br><span class="line">count++</span><br><span class="line"></span><br><span class="line">//当一个函数希望传递的参数式一个普通的数字的时候,希望它保持响应式</span><br><span class="line">// 但是如果只传递state的时候, </span><br><span class="line">callback(state)&#123;</span><br><span class="line">console.log(state) // undefined</span><br><span class="line">&#125;</span><br><span class="line">// 传递state</span><br></pre></td></tr></table></figure><h2 id="计算属性computed"><a href="#计算属性computed" class="headerlink" title="计算属性computed"></a>计算属性computed</h2><p>计算属性 的作用在于用来解构依赖复杂的数据显示.</p><p>计算属性<code>computed</code> 方法期望接收<code>getter</code> 函数, 返回值一个计算属性<code>ref</code>.该<code>ref</code> 和其他ref 一样. 也可以通过.value 访问计算结果 . 计算属性ref 也会在模板中自动解包.</p><p>vue 的计算属性会自动追踪响应式依赖, 她会自动检测到依赖的数据, 当依赖的数据发生了改变, 依赖绑定的数据也会同时更新.</p><p>vue 计算属性computed 是有缓存的. 也就意味着如果依赖的数据没有发生改变, 那么展现返回h的永远都是先前的计算结果, 不会重复执行<code>getter</code>函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; reactive, computed &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> author = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">author</span>: <span class="string">&quot;john&quot;</span>,</span><br><span class="line">  <span class="attr">books</span>: [<span class="string">&quot;v1&quot;</span>, <span class="string">&quot;v2&quot;</span>],</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// computed</span></span><br><span class="line"><span class="keyword">const</span> publishedBooks = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> author.<span class="property">books</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> el;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fnBooks</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> author.<span class="property">books</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">el</span>)=&gt;</span>&#123; el&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的逻辑在组件函数和在 计算属性中, 结果基本都是相同的, 不同的是, 组件函数会在重新渲染发生的时候,再次执行函数,</p><p>而计算属性属性是有缓存的, 如果在一个非常郝性能的列表的时候, 没有缓存的话每次渲染的时候都会重复计算,造成不必要的性能损耗, 而有了缓存再 没有数据发生变化的时候 ,就不用每次重新计算数据了.</p><h3 id="可写计算属性"><a href="#可写计算属性" class="headerlink" title="可写计算属性"></a>可写计算属性</h3><p>计算属性默认是只读的, 在vue 中尝试修改一个计算属性的时候 , 会收到运行警告.只有在某些特殊场景中才会用到可写属性 , 这时候可以通过同时提供<code>getter</code> 和<code>setter</code> 来创建.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, computed &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const firstName = ref(&#x27;John&#x27;)</span><br><span class="line">const lastName = ref(&#x27;Doe&#x27;)</span><br><span class="line"></span><br><span class="line">const fullName = computed(&#123;</span><br><span class="line">  // getter</span><br><span class="line">  get() &#123;</span><br><span class="line">    return firstName.value + &#x27; &#x27; + lastName.value</span><br><span class="line">  &#125;,</span><br><span class="line">  // setter</span><br><span class="line">  set(newValue) &#123;</span><br><span class="line">    // 注意：我们这里使用的是解构赋值语法</span><br><span class="line">    [firstName.value, lastName.value] = newValue.split(&#x27; &#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><p>getter 应该子程序逻辑中只做计算不要有任何其他的副作用.</p><p>不要再getter 中做异步请求或者更改DOM</p><h4 id="避免直接修改计算属性值"><a href="#避免直接修改计算属性值" class="headerlink" title="避免直接修改计算属性值"></a>避免直接修改计算属性值</h4><p>vue 中计算属性返回的值是一个派生状态, 可以看成是一个零时快照, 每当原装态发生变化的时候, 就会创建一个新的快照, 所以更改快照是没有意义的, 因此计算属性的返回值应该被视为只读的, 并且永远不应该被给更改, 应该更新他所依赖的状态触发新的计算.</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript重难点阅读</title>
      <link href="/2023/10/08/javascript%E9%87%8D%E9%9A%BE%E7%82%B9%E9%98%85%E8%AF%BB/"/>
      <url>/2023/10/08/javascript%E9%87%8D%E9%9A%BE%E7%82%B9%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>在javascript 中, 数据类型可以分为基本数据类型和引用数据类型.</p><p>基本数据类型包括:</p><ul><li>undefined</li><li>null</li><li>boolean</li><li>number</li><li>string</li><li>symbol(es6新增)</li></ul><p>引用数据类型包括:</p><ul><li>Object</li><li>Function</li><li>Array</li><li>Date</li></ul><h3 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h3><pre><code>表示一个变量不存在, 或者声明了却没有赋值初始化.</code></pre><ul><li><p>声明了变量但是没有初始化的变量会返回undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a ;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br></pre></td></tr></table></figure></li><li><p>获取一个对象的某个不存在的属性(自身属性和原型链属性)时, 会返回undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="property">age</span>; <span class="comment">// undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>函数没有明确返回值时, 但却在其他地方使用了返回值, 会发返回undeined,</p><blockquote><p>这也是我们经常在控制台调试的时候, 在没有指定return 值的时候, 老是会有undefined的出现</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">lof</span>()<span class="title function_">foo</span>())</span><br></pre></td></tr></table></figure></li><li><p>函数定义的时候使用了多个形式参数, 在调用传递的时候,参数的数量少于形参, 那么在没有匹配上的参数就位undefined, 在es6 中已经可以指定默认参数, 避免了这种情况发行</p><p><code>  function foo(num1, num=2)&#123;&#125;</code> 如果在传递形参的时候, 指定了默认参数, 那么就会使用 默认参数, 避免了undefined的发生</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">num1, mu2</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num,num2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h3><p>null 类型只有一个唯一的字面值,null , 表示一个空指针对象, 所以在使用 <code>typeof</code> 检测null 值的时候也会返回一个 <code>object</code> 的原因.</p><ul><li><p>如果生命的变量是为了以后保存某个值, 那么再声明的时候, 就会会赋值为null</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">obj = foo</span><br></pre></td></tr></table></figure></li><li><p>javascript 中在获取dom 元素的时候, 如果没有获取到指定的元素对象, 也会返回null</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#id&quot;</span>) <span class="comment">// null</span></span><br></pre></td></tr></table></figure></li><li><p>使用正则表达式进行捕获的时候, 如果没有捕获结果, 就会返回null</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;test&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/a/</span>) ; <span class="comment">// null</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Null-和undefined-的异同"><a href="#Null-和undefined-的异同" class="headerlink" title="Null 和undefined 的异同"></a>Null 和undefined 的异同</h3><p> 虽然null 和undefined 是两种不同的基本数据类型,虽然存在一些不同的特性, 但是某些表现上却也存在着相同之处.</p><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><p>null 和undefined 两种数据类型都只有一个字面值, 分别是null 和undefined.</p><p>null类和undefined  类在转换为boolea 类型的值时候, 都会转换为false.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在非严格相等的情况下, 两者是相等的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p>null  是javascript 中的关键字, 而undefined 是javascript 中的一个全局变量</p><ul><li><p>在使用 <code>typeof</code> 运算检测的时候, undefined 类型的值会返回 <code>undefined</code> null 类型的会返回 <code>object</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// object</span></span><br></pre></td></tr></table></figure></li><li><p>通过call 调用 <code>toString</code> 函数的时候, <code>undefined</code> 类型的值会返回 <code>[Object Undefined]</code> 而 <code>null </code> 类型会返回 <code>[Object Null]</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>) <span class="comment">// [Object Undefined]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>) <span class="comment">// [Object NuLl]</span></span><br></pre></td></tr></table></figure></li><li><p>在需要进行字符串转换的时候, <code>null</code> 会换转为字符串 <code>null</code> 而 <code>undefined</code> 会转换为字符串 <code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> + <span class="string">&quot;string&quot;</span> <span class="comment">// undefined string</span></span><br><span class="line"><span class="literal">null</span> + <span class="string">&quot;string&quot;</span> <span class="comment">// null string</span></span><br></pre></td></tr></table></figure></li><li><p>在需要进行数值类型得转换 的时候, <code>undefined</code> 会转换为 <code>nan</code> 无法参与计算, <code>null</code> 会转换为0, 可以参与计算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> + <span class="number">0</span> ; <span class="comment">// nan</span></span><br><span class="line"><span class="literal">null</span>+ <span class="number">0</span> ; <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>Boolean 又称为布尔类型, 字面值只有两个, 分别是 <code>true</code> 和 <code>false</code>, 他们是区分大小写, 例如True 和 False 并不是 <code>boolean</code> 类型.</p><h4 id="String-类型转换Boolean-类型"><a href="#String-类型转换Boolean-类型" class="headerlink" title="String 类型转换Boolean 类型"></a>String 类型转换Boolean 类型</h4><ul><li>空字符串都转换为false</li><li>任何非空字符串都会转换为true, 包括空格字符串</li></ul><h4 id="number-类型"><a href="#number-类型" class="headerlink" title="number 类型"></a>number 类型</h4><ul><li>0 和nan 会转换为false</li><li>除了 0 和nan 都会转换为true, 包括无穷大和无穷小的 <code>infinity</code> 和 <code> -infinity</code></li></ul><h4 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h4><ul><li>当object 为null 的时候, 会转换为false</li><li>如果object不为null , 则都会转换为true, 包括空对象{}</li></ul><h4 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h4><p>任何Function 类型的值都会转换为true</p><h4 id="Null-类型"><a href="#Null-类型" class="headerlink" title="Null 类型"></a>Null 类型</h4><p>Null 类型只有一个null 值, 会转换为false</p><h4 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a>Undefined 类型</h4><p> undefined 类型只有一个undefined , 会转换为false</p><h3 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h3><p>在javascript 中number 类型包括了整数类型, 也包括了浮点类型数据.</p><h4 id="Number-类型转换"><a href="#Number-类型转换" class="headerlink" title="Number 类型转换"></a>Number 类型转换</h4><p>javascript 中基本是按照十进制数据类行转换.</p><ul><li><p>boolean 类型转换number</p><ul><li><p>true 转换wi1</p></li><li><p>false 转换为0</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">false</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Null 类型转换</p><ul><li><p>null 类型值只有一个字面值null, 直接转换为0</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Undefined 转换</p><ul><li>undefined  只有一个字面值undefined, 直接转换为nan</li></ul></li><li><p>String 类型转换</p><ul><li>如果字符串中值包含数字, 则会转换成十进制数, 如果前面有0, 则会直接省略掉,例如 <code>0123</code> , 直接转换为 <code>123</code></li><li>如果字符串串中包含有效的十六进制格式的数据, 则会按照十进制转换</li><li>如果是空字符串, 则转换为 <code>0</code></li><li>除了上面的格式, 其他的则会直接转换为 <code>NaN</code></li></ul></li><li><p>Object 类型转换</p><ul><li>Object 类型转在转换为Number 类型的时候, 会优先调用 <code>valueof</code> 函数, 燃烧后通过 <code>valueof&#39;</code> 函数的方绘制值,按照规则转换,如果转换的结果是 <code>nan</code> 则调用 <code>toString</code> 函数, 通过 <code>toString</code> 函数的返回值重新按照指定规则进行转换</li><li>&#96;&#96;&#96;javascript<br>const obj &#x3D; {<br>  age: 21,<br>  valueOf: function () {<br>return [];<br>  },<br>  toString: function () {<br>return this.age;<br>  },<br>};<br>console.log(Number(obj));<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### Number 方法</span><br><span class="line"></span><br><span class="line">##### parseInt()</span><br><span class="line"></span><br><span class="line">用于解析一个字符串, 并返回指定的基数对应的整数值</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>parseInt(string, radix)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; string : 表示要被解析的值, 如果该参数不是一个字符串, 那么会调用 `toString` 函数转换成字符串</span><br><span class="line">&gt;</span><br><span class="line">&gt; radix: 表示进制转换的基数, 基数范围是2-36, 默认 为10 进制.</span><br><span class="line">&gt;</span><br><span class="line">&gt; 如果传入的字符串无法转换成 `number` 类型, 则会返回 `nan`</span><br><span class="line"></span><br><span class="line">###### map () 函数和parseInt() 函数的隐性坑</span><br><span class="line"></span><br><span class="line">在一个场景, 如果存在一个数组, 数组中的每个元素, 都是 `number`类型的字符串 `[“1”, ‘“2”, “3”]` 这时候如果将数组中的元素都转换为整数.</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">var arr = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;];</span><br><span class="line"></span><br><span class="line">var result = arr.map(parseInt);</span><br><span class="line"></span><br><span class="line">console.log(result);</span><br><span class="line">// 预期结果是 [1,2,3,4]</span><br><span class="line">// 实际结果是: [1, nan]</span><br></pre></td></tr></table></figure><p><code>Array.prototype.map</code> 在mdn 的定义是一个迭代方法, 它为数组中的每一个元素调用一次提供的 <code>callback</code> , 并用结果返回一个新数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">map</span>(callback, thisArray)</span><br></pre></td></tr></table></figure><blockquote><p>map 的callback 接受三个参数,</p><ul><li>element: 数组当前正在处理的元素</li><li>index: 当前正在处理的元素数组索引</li><li>array: 调用了map 的数组本身</li></ul></blockquote><p>也就是类似于在使用map 的时候代码类似这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">el, index, array</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">parseInt</span> (el, index)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>map 每次调用调用处理的数组元素的index 下标是在变化的.在处理到时候大概如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>);  <span class="comment">// 1  任何整数以0 为基数取数的时候, 都会返回数值本身</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;2&#x27;</span>, <span class="number">1</span>);  <span class="comment">// NaN  基数只能是2-36</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;3&#x27;</span>, <span class="number">2</span>);  <span class="comment">// NaN 二进制数只有0,和1, 3超过了进制范围</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;4&#x27;</span>, <span class="number">3</span>);  <span class="comment">// NaN 4 无法使用3 进制表示</span></span><br></pre></td></tr></table></figure><p>解决办法就是, 在每次使用 <code>parseInt</code> 的时候尽量指定基数, 不要将 <code>parseInt</code> 作为 <code>map</code> 的参数,而是在 <code>map</code> 的回调函数中使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = []</span><br><span class="line"><span class="keyword">let</span> res = arr.<span class="title function_">map</span>(<span class="function">(<span class="params">el</span>)=&gt;</span>&#123; <span class="keyword">return</span> <span class="built_in">parseInt</span>(<span class="number">10</span>)&#125;)</span><br></pre></td></tr></table></figure><h5 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h5><p>该方法用于解析一个字符串, 返回对应的符数点 , 如果给定的值不能转为数值, 则返回 <code>nan</code>.</p><p>在解析的过程中如果遇到了正负号, 数字0-9 , 小数点或者科学计数法以外的字符, 则会忽略该字符开始至结束的所有字符, 然后返回当前已经接卸的字符的浮点数形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;+1.2&#x27;</span>);   <span class="comment">// 1.2</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;-1.2&#x27;</span>);   <span class="comment">// -1.2</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;++1.2&#x27;</span>);  <span class="comment">// NaN，符号不能连续出现</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;--1.2&#x27;</span>);  <span class="comment">// NaN，符号不能连续出现</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;1+1.2&#x27;</span>);  <span class="comment">// 1，&#x27;+&#x27;出现在第二位，不会当作符号位处理</span></span><br></pre></td></tr></table></figure><ul><li><p>字符前面的空白会直接忽略, 如果无法解析, 则直接返回 <code>nan</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot; 1.2&quot;</span>) <span class="comment">// 1.2</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;f1.2&quot;</span>) <span class="comment">// nan</span></span><br></pre></td></tr></table></figure></li><li><p>对于字符中出现的合法科学运算符, 在金蒜运算处理后会转换成浮点数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;4e3&quot;</span>) <span class="comment">// 400</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;4e3, 10&quot;</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><blockquote><p>parseFloat:  在处理4e3 的时候 , 会先进行科学计数法的运算, 然后再转换为浮点数</p><p>parseInt : 在处理4e3 的时候, 则直接从字符串4 开始按进制基数10 转换, 然后返回整数4</p></blockquote></li><li><p>对于小数点, 只能正确匹配第一个, 第二个小数点是无效的, 后面的字符也将被忽略</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;11.20&#x27;</span>);  <span class="comment">// 11.2</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;11.2.1&#x27;</span>); <span class="comment">// 11.2</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="isNaN-与-Number-isNaN"><a href="#isNaN-与-Number-isNaN" class="headerlink" title="isNaN  与 Number.isNaN"></a>isNaN  与 Number.isNaN</h4><p>在number 数据类型中, 存在一个特殊的数值 <code>nan</code> 即not a number, 表示应该返回设置却没有返回数值.</p><p>在javascript 中nan 有两个明显的特点:</p><ol><li>任何涉及nan 的操作都会返回nan</li><li>nan 与任何值都不相等, 即使是与 <code>nan</code> 本身相比</li></ol><p>在判断 <code>nan</code> 的时候, es5 提供了 <code>isNaN</code> 函数, 在es6 的时候, 又为number 类型添加了静态函数 <code>isNaN</code></p><h5 id="isNaN-函数"><a href="#isNaN-函数" class="headerlink" title="isNaN () 函数"></a>isNaN () 函数</h5><p>用来确定一个变量是不是 <code>NaN</code> . <code>NaN</code>  是一个number 类型的数值, 只不过这个数值无法用真实的数字表示.</p><p>在传递参数的时候, 如果是number 类型的数据, 可以很容易判断是不是 <code>NaN</code> 但是在传递的参数是非number 类型的时候, 谈返回的结果往往让人费解.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(&#123;&#125;) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>空对象明明不是一个nan 数据, 应该返回的false, 但是却返回了true.</p><p>首先 <code>nan</code> 产生的条件是在数据运算的时候, 返回了一个无法表示的数值,如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>/<span class="number">0</span>) <span class="comment">// nan</span></span><br></pre></td></tr></table></figure><blockquote><p>除了0&#x2F;0 , 其他数据除以0 都会返回Infinity</p></blockquote><p>又或者在做强制数据类型转换的时候, 某些数据不能直接转换为数值类型, 也会返回 <code>nan</code>如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1- &quot;a &quot;  // nan</span><br></pre></td></tr></table></figure><p>而 <code>isNaN</code>()  函数也会进行数据类型的转换, 它在处理的时候会去判断传入的变量值是否能转换为数字, 如果能转换为数字, 则会返回false, 如果无法转换则会返回true.</p><p>所以在 <code>isNaN(&#123;&#125;)</code>  返回true 的时候, 首先会对 <code>&#123;&#125;</code> 进行类型转换, 但是 <code>&#123;&#125;</code> 是一个字面量无法转换成数字,自然判断 <code>true</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">NaN</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(undeﬁned);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(&#123;&#125;);        <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">true</span>);      <span class="comment">// false，Number(true)会转换成数字1</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">null</span>);      <span class="comment">// false，Number(null)会转换成数字0</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">1</span>);         <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&#x27;&#x27;</span>);        <span class="comment">// false，Number(&#x27;&#x27;)会转换为成数字0</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;1&quot;</span>);            <span class="comment">// false，字符串&quot;1&quot;可以转换成数字1</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;JavaScript&quot;</span>);   <span class="comment">// true，字符串&quot;JavaScript&quot;无法转换成数字</span></span><br><span class="line"><span class="comment">// Date类型</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="keyword">new</span> <span class="title class_">Date</span>());     <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toString</span>());  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>关于 <code>new Date()</code> 函数生成的实例在转换为数值类型的时候 , 都会转换为对应的世界戳, 但是在调用 <code>toString</code> 函数的时候, 返回的是一串字符串表示的时间, 无法转化成数值类型,</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( date); <span class="comment">// 生成的是数字时间戳</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toString</span>()); <span class="comment">// 调用了toString()后返回的是字符串表示的时间戳</span></span><br></pre></td></tr></table></figure><h5 id="Number-isNaN"><a href="#Number-isNaN" class="headerlink" title="Number.isNaN()"></a>Number.isNaN()</h5><p>在全局环境中已经有了isNaN() 函数, 在es 6 为什么还要增加一个 <code>Number.isNaN()</code> 函数呢,.</p><p>那是因为全局中的 <code>isNaN</code> 会在传入的类型做类型转换, 而 <code>Number.isNaN</code> 不会去做类型转换,你传入的是什么就是什么, 同样的代码在es5 <code>isNaN</code> 和es6 的 <code>Number.isNaN</code> 的区别</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(&#123;&#125;) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>);        <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(undeﬁned);   <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="literal">null</span>);       <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="literal">true</span>);       <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&#x27;&#x27;</span>);         <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">123</span>);        <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h5 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h5><p>如果在非es6 的环境中 需要用用到 <code>Number.isNan</code> 函数呢,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myIsNaN</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 判断环境中是否存在Number.isNaN</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="property">isNaN</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果环境中并不存在 , 那么创建一个函数</span></span><br><span class="line">    <span class="title class_">Number</span>.<span class="property">isNaN</span> = <span class="keyword">function</span>(<span class="params">n</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> n !== n;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在所有类型的数据中, 如果一个变量和自身做比较, 只有变量值在为NaN的时候 , 才会返回false , 其他时候都是返回true,</p><h4 id="浮点型运算"><a href="#浮点型运算" class="headerlink" title="浮点型运算"></a>浮点型运算</h4><p>在javascript 中整数和浮点数都是属于Number 类型, 都统一采用64 位浮点数来进行存储.虽村存储数据的方式是一致,但是在进行浮点数运算的时候, 结果有时候却会有差异.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 加法</span></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> = <span class="number">0.30000000000000004</span></span><br><span class="line"><span class="number">0.7</span> + <span class="number">0.1</span> = <span class="number">0.7999999999999999</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 减法</span></span><br><span class="line"><span class="number">1.5</span> - <span class="number">1.2</span> = <span class="number">0.30000000000000004</span></span><br><span class="line"><span class="number">0.3</span> - <span class="number">0.2</span> = <span class="number">0.09999999999999998</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 乘法</span></span><br><span class="line"><span class="number">0.7</span> * <span class="number">180</span> = <span class="number">125.99999999999999</span></span><br><span class="line"><span class="number">9.7</span> * <span class="number">100</span> = <span class="number">969.9999999999999</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 除法</span></span><br><span class="line"><span class="number">0.3</span> / <span class="number">0.1</span> = <span class="number">2.9999999999999996</span></span><br><span class="line"><span class="number">0.69</span> / <span class="number">10</span> = <span class="number">0.06899999999999999</span></span><br></pre></td></tr></table></figure><p>经典问题来了 <code>0.1+0.2</code> 不等于0.3</p><p>这是因为在JavaScript 是因为双精度浮点数来表示数字, 而双精度浮点数又存在精度问题, 在双精度浮点数中使用有限的二进制位数来表示实数,在有些情况系会出现舍入误差,而0.1, 0.2 在转换为二进制数的时候会产生无循环的小数, 所以在进行计算的时候会存在一些误差.</p><p><img src="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202310082151157.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202310082151157.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>一个浮点数在计算机中长度为64位, 其中最高位为符号位, 接下来的11 位为 指数位, 最后的52 位为小数位, 即有效数字的部分.</p><p>因为使用64为存储, 除去 最高位0 位, 和11 位指数位, 接下来最多也就能存储52位的小数位, 对于一些无限循环的小数位浮点数, 也只会截取到钱52位,这也就是为什么前面说的会小出现舍入误差.</p><p>既然知道了为什么会出现这个问题, 那么我们来看看这个结果是这么在计算出来的.</p><p>首先在计算的过程中, 会将各个小数位按照乘 2 取整. 顺序排列的方法转换成2进制表示,具体做法, 就是用 2 乘以十进制小数得到积, 将积的部整数部分取出, 然后再用2 乘以余下的小数部分, 又得到一个积, 再将积的整数部分取出, 如此反复, 知道将积的小数部分为0 为止.</p><p>这时候把取出的整数部分按照顺序排列起来, 先取出的整数作为二进制小数的高位有效位, 后取的整数作作为地位有效位.</p><p><strong>这时候来看看0.1 转换成二进制的过程</strong></p><p><img src="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202310082227612.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202310082227612.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>后面就是0.00011, 0011,0011, 如此反复</p><p>然后还要对0.2 开始二进制转换, 计算过程和上面差不多, 只不过是从0.2开始少了第一位的0</p><p><img src="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202310082232153.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202310082232153.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>然后也是0.0011, 0011 不断反复.</p><p>这时候0.1 和0.2 开始相加, 转换成52 位精度的浮点型表示:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0.0001</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">1001</span>  <span class="number">1001</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">1001</span>   (<span class="number">0.1</span>)</span><br><span class="line">+ <span class="number">0.0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span>   (<span class="number">0.2</span>)</span><br><span class="line">= <span class="number">0.0100</span> <span class="number">1100</span> <span class="number">1100</span> <span class="number">1100</span> <span class="number">1100</span> <span class="number">1100</span> <span class="number">1100</span> <span class="number">1100</span> <span class="number">1100</span> <span class="number">1100</span> <span class="number">1100</span> <span class="number">1100</span> <span class="number">1100</span></span><br></pre></td></tr></table></figure><p>得到的结果就转换成十进制的值就是0.30000000000000004</p><h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><p>javascript中的String 类型 可以 通过 <code>“”</code>  也可以通过 <code>‘’</code> 来表示,   这和java 其他语言必须是 <code>“”</code> 是不同的.</p><p>在处理其他类型转换为String 的时候, 如果是引用数据恶灵, 在转换的时候会调用 <code>toString</code> 函数, 得到不同是类型值的字符串, 如果是基本数据类型, 则会直接将字面值转换为字符串表示.</p><p>例如 <code>null</code> 和 <code>undefined</code> 转换为字符串的时候， 就会直接返回字面量的值， <code>null</code> 和 <code>undefined</code> .</p><p>在将某写数据转换为字符串的时候, 最简单的方法就是使用 <code>+</code> 号拼接一个 空字符串 <code>‘ ’</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span> + <span class="string">&#x27;&#x27;</span>);    <span class="comment">// &#x27;123&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] + <span class="string">&#x27;&#x27;</span>);  <span class="comment">// &#x27;1,2,3&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> + <span class="string">&#x27;&#x27;</span>);   <span class="comment">// &#x27;true&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="String-定义"><a href="#String-定义" class="headerlink" title="String 定义"></a>String 定义</h4><pre><code>在javscirpt 中虽然单引号`‘’` 和双引号 `“”` 都可以定义字符串, 但是不能在定义一个字符串的时候, 出现一个单引号, 和一个双引号.</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello&quot;</span> <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">&#x27;hello&#x27;</span> <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">let</span> str3 = <span class="string">&#x27;hello&quot; // 错位</span></span><br></pre></td></tr></table></figure><h5 id="直接调用String-函数"><a href="#直接调用String-函数" class="headerlink" title="直接调用String 函数"></a>直接调用String 函数</h5><p>在直接使用String 函数的时候, 会将任何类型的值转换为字符串,</p><ul><li><p>如果是Number 类型的值, 则直接转换成对应的字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>(<span class="number">123</span>) <span class="comment">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>如果是Boolean 类型的值, 则会直接转换成‘true’ 或者‘false’</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>(<span class="literal">true</span>) <span class="comment">// &#x27;true&#x27;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">false</span>) <span class="comment">// &#x27;false&#x27;</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><blockquote><p>这时候如果直接传入Boolea呢? 会得到什么.</p><p>String(Boolean)</p><p>这时候输出的字符串表示的函数源代码. 因为传递的&#96;&#96;Boolean&#96; 是一个函数本身, 而不是一个布尔值.</p><p>所以这时候输出的是 <code>function Boolean() &#123; [native code] &#125;</code></p></blockquote></li><li><p>如果值为null , 则返回字符串‘null’</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>(<span class="literal">null</span>) <span class="comment">// &#x27;null&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>如果值为字符串, 则直接返回字符串本身</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>) <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>如果值是引用类型, 则会优先调用toString() 函数获取返回值, 然后按照上面的转换规则, 判断是否能准换成相应的字符串类型, 如果都不满足, 则会调用对对象的 <code>valueOf()</code> 函数获取返回值, 重新按照上面的步骤转换成对应的字符串类型, 如果都不满足, 则会抛出类型转换异常.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">  <span class="attr">toString</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(obj)); <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><p>这时候来通过valueOf() 函数来转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">  <span class="comment">// toString: function () &#123;</span></span><br><span class="line">  <span class="comment">//   return `$&#123;this.age&#125;`;</span></span><br><span class="line">  <span class="comment">// &#125;,</span></span><br><span class="line">  <span class="attr">valueOf</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(obj));</span><br></pre></td></tr></table></figure><p>如果 <code>valueOf</code> 和 <code>toString</code> 都无法转换成原生类型的话, 那么则会抛出类型转换的异常</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line"><span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line"><span class="attr">valueOf</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">toString</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">String</span>(obj) <span class="comment">// 抛出异常TypeError</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="newString-定义"><a href="#newString-定义" class="headerlink" title="newString 定义"></a>newString 定义</h5><p><code>new String()</code> 函数使用 <code>new</code>  运算符号生成一个String 类型的实例, 传入的参数和String() 函数一样类型的转换策略</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">str <span class="comment">// &quot;[string hello]&quot;</span></span><br></pre></td></tr></table></figure><h4 id="不同定义方方式的String-区别"><a href="#不同定义方方式的String-区别" class="headerlink" title="不同定义方方式的String 区别"></a>不同定义方方式的String 区别</h4><p>使用字符串字面量和直接调用String() 函数的方式得到的字符串都是基本字符串, 但是通过 <code>new String()</code> 函数生成的字符串是字符对象.</p><p>在基本字符串做比较的时候, 只要比较字符串的值就可以了.</p><p>但是在比较字符串对象的时候, 比较的是对象所在的地址.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello&quot;</span>; <span class="comment">//</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> str3 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> str4 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> str5 = str4;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str === str2); <span class="comment">// true 因为是两个基本字符串, 只要比较值就好了</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str3 === str4); <span class="comment">// false, 因为new String 函数生成的, 所以比较的两个字符串对象的地址, 虽然值都是一样, 但是是两个不同的new 出来的实例对象, 所以引用的对象地址是不一样的,</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str4 === str5); <span class="comment">// str5 是str4 的引用, 这也意味着他们引用的同一个对象地址,</span></span><br></pre></td></tr></table></figure><h4 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h4><p>在String 对象的原型链上有着一系列的函数, 但是在没用使用 <code>new String</code> 生成的基本字符串也可以调用原型链上的函数.</p><p>实际上基本字符串本身没有办法调用字符串对象的函数的,但是在基本字符串在调用字符串对象的函数的时候, 是因为JavaScript 会自动将基本字符串转换为对象字符串, 形成以一种包装类型, 这样基本字符串就可以正常调用字符串对象的方法了</p><h4 id="String类型常见用法"><a href="#String类型常见用法" class="headerlink" title="String类型常见用法"></a>String类型常见用法</h4><h5 id="字符逆向输出"><a href="#字符逆向输出" class="headerlink" title="字符逆向输出"></a>字符逆向输出</h5><p>给定一个字符串’abcdefg’，执行一定的算法后，输出的结果为’gfedcba’。</p><h6 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h6><p>首先使用 <code>split()</code> 将字符串转换成数组, 使用数组的 <code>reverse</code> 方法,将字符串进行逆行排序, 再使用 <code>join() </code> 函数生成字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverseString</span>(<span class="params">str</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> str.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h6><p>使用循环遍历出字符串, 然后在使用 <code>chatAt()</code> 返回对应索引字符串的字符, 然后再拼接.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">funciton <span class="title function_">reverseString</span>(<span class="params">str</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> res= <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = str.<span class="property">length</span>-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        res += str.<span class="title function_">charAt</span>(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h6><p>递归逆向输出, 从字符出最后一个索引位置开始递归, 然后通过 <code>charAt()</code> 获取字符,拼接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverseString</span>(<span class="params">strlegnth,pos,strOut</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> strout;</span><br><span class="line">&#125;</span><br><span class="line">    strout += strlen.<span class="title function_">charAt</span>(pos--)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reverseString</span>(strlen,pos, strout)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> res = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="title function_">reverseStrng</span>(str, str.<span class="property">length</span>, res)</span><br></pre></td></tr></table></figure><h6 id="方法4"><a href="#方法4" class="headerlink" title="方法4"></a>方法4</h6><p>使用 <code>slice()</code> 方法, 截取字符串返回一个新的数组, 然后在调用 <code>Array.reverse()</code>  让新生成的数组逆向输出, 在使用 <code>join</code>转换成逆向的字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverse4</span>(<span class="params">str</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> strArr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(str)</span><br><span class="line">  <span class="keyword">return</span> strArr.<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="方法5"><a href="#方法5" class="headerlink" title="方法5"></a>方法5</h6><p>使用栈结构,利用栈结构先进后出的原则, 先通过一个数组, 进行数据存储, 然后使用一个变量记录栈顶的位置, 然后出栈时, 返回张栈顶的元素, 即数组中索引值最大的元素, 然后栈顶变量-1, 入栈时往栈顶追加元素, 然后栈顶变量+1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Stack</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 存储数据</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">strData</span> = [];</span><br><span class="line">  <span class="comment">// 记录栈顶位置</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">top</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再原型上增加出入栈</span></span><br><span class="line"><span class="title class_">Stack</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="comment">// 入栈</span></span><br><span class="line">  <span class="attr">push</span>: <span class="keyword">function</span> <span class="title function_">push</span>(<span class="params">el</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">strData</span>[<span class="variable language_">this</span>.<span class="property">top</span>++]= el</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 出栈</span></span><br><span class="line">  <span class="attr">pop</span>: <span class="keyword">function</span> <span class="title function_">pop</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">strData</span>[--<span class="variable language_">this</span>.<span class="property">top</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 返回栈内的元素个数</span></span><br><span class="line">  <span class="attr">length</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">top</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse6</span>(<span class="params">str</span>)&#123;</span><br><span class="line">  <span class="comment">// 创建栈的实例</span></span><br><span class="line">  <span class="keyword">const</span> stack = <span class="keyword">new</span> <span class="title class_">Stack</span>()</span><br><span class="line">  <span class="comment">// 将字符串转换成数组</span></span><br><span class="line">  <span class="keyword">let</span> strArr = str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>),</span><br><span class="line">  len = strArr.<span class="property">length</span>,</span><br><span class="line">  res = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">    stack.<span class="title function_">push</span>(strArr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 输出栈内的元素</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">    res += stack.<span class="title function_">pop</span>(strArr[j])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="统计字符串中出现次数最多的字符-以及次数"><a href="#统计字符串中出现次数最多的字符-以及次数" class="headerlink" title="统计字符串中出现次数最多的字符,以及次数"></a>统计字符串中出现次数最多的字符,以及次数</h5><p>假如存在一个字符串’helloJavascripthellohtmlhellocss’，其中出现次数最多的字符是l，出现的次数是7次</p><h6 id="方法1-1"><a href="#方法1-1" class="headerlink" title="方法1"></a>方法1</h6><p>通过 <code>key value</code> 的形式来存储字符串以及出现的次数, 然后再一个个判断.首先创建一个空对象, 遍历传递进来的字符串,使用&#96;&#96;charAt()&#96; 查找unicode 来判断这个对象中是否存在这个key, 如果不存在, 那么当前的字符为key, value: 1.(因为不存在只出现了一次), 如果出现过则value加一次.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getMaxStringOrdinal</span>(<span class="params">str</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> json= &#123;&#125;</span><br><span class="line">  <span class="comment">// 遍历字符串</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++)&#123;</span><br><span class="line">      <span class="comment">// 如果不存在则创建key value</span></span><br><span class="line">    <span class="keyword">if</span>(!json[str.<span class="title function_">charAt</span>(i)])&#123;</span><br><span class="line">      json[str.<span class="title function_">charAt</span>(i)] = <span class="number">1</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 如果存在则 value ++</span></span><br><span class="line">      json[str.<span class="title function_">charAt</span>(i)]++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(json);</span><br><span class="line">  <span class="keyword">let</span> maxCountChar = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> maxCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> json)&#123;</span><br><span class="line">    <span class="keyword">if</span>(json[key] &gt; maxCount)&#123;</span><br><span class="line">      maxCount = json[key]</span><br><span class="line">      maxCountChar = key</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`出现次数最多的值是: <span class="subst">$&#123;maxCountChar&#125;</span> , 出现次数为: <span class="subst">$&#123;maxCount&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getMaxStringOrdinal</span>(str));</span><br></pre></td></tr></table></figure><h6 id="方法2-1"><a href="#方法2-1" class="headerlink" title="方法2"></a>方法2</h6><p>同样使用都使用key,value. 来存储数据, key 表示不重复出现的字符,value表示字符出现的次数.</p><p>1: 先将字符串处理成数组, 然后通过 <code>foreach</code> 遍历每个字符,判断当前处理的字符是否已经存在 <code>key-value</code>对象中, 如果已经存在则表示已经处理过相同的字符无须在处理, 如果不存在则处理传入的<code>item</code></p><p>通过split() 函数传入待处理的字符, 得到一个数组, 该数组长度-1即为该字符出现的次数</p><p>获取到字符出现的次数后, 和表示出现最大次数<code>maxCount</code> 和最大次数对应的字符串变量<code>maxCountChar</code> 相比,如果比<code>maxCount</code> 大则写入<code>key-value</code> 对象中, 并更新<code>maxCount</code>和<code>maxCountChar</code>的值, </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getMaxCount</span>(<span class="params">str</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> json = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> maxCount =<span class="number">0</span>,</span><br><span class="line">  maxCountChar = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>)&#123;</span><br><span class="line">    <span class="comment">// 判断json 对象中是否有对应的key</span></span><br><span class="line">      <span class="keyword">if</span>(!json.<span class="title function_">hasOwnProperty</span>(item))&#123;</span><br><span class="line">        <span class="keyword">let</span> number = str.<span class="title function_">split</span>(item).<span class="property">length</span>  -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 直接与出现次数最大的值比较</span></span><br><span class="line">        <span class="keyword">if</span>(number &gt; maxCount)&#123;</span><br><span class="line">          json[item] = number;</span><br><span class="line">          maxCount = number</span><br><span class="line">          maxCountChar = item</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`出现次数最多的值是: <span class="subst">$&#123;maxCountChar&#125;</span> , 出现次数是:<span class="subst">$&#123;maxCount&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getMaxCount</span>(str));</span><br></pre></td></tr></table></figure><h6 id="方法3-1"><a href="#方法3-1" class="headerlink" title="方法3"></a>方法3</h6><p>  该方法主要通过对字符串进行排序, 然后通过<code>lastIndexOf()</code> 函数获取索引值后, 判断该索引值的大小以获取出现的最大次数</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getMaxCount</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> maxCount = <span class="number">0</span>,</span><br><span class="line">    maxCountChar = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  str.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">sort</span>().<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = str.<span class="property">length</span>; i &lt; j; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> char = str[i];</span><br><span class="line">    <span class="comment">//记录每个字符串出现的次数</span></span><br><span class="line">    <span class="keyword">let</span> charCount = str.<span class="title function_">lastIndexOf</span>(char) - i + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 与次数最大值比较</span></span><br><span class="line">    <span class="keyword">if</span> (charCount &gt; maxCount) &#123;</span><br><span class="line">      maxCount = charCount;</span><br><span class="line">      maxCountChar = char;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 变更索引为字符串出现的最后位置</span></span><br><span class="line">    i = str.<span class="title function_">lastIndexOf</span>(char);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">` 出现次数最多的值是: <span class="subst">$&#123;maxCountChar&#125;</span>, 出现次数是: <span class="subst">$&#123;maxCount&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getMaxCount</span>(str));</span><br></pre></td></tr></table></figure><h5 id="去除字符串中的重复字符串"><a href="#去除字符串中的重复字符串" class="headerlink" title="去除字符串中的重复字符串"></a>去除字符串中的重复字符串</h5><h6 id="方法1-2"><a href="#方法1-2" class="headerlink" title="方法1"></a>方法1</h6><p>还是使用key-value 类型的对象存储, <code>key</code> 表示唯一字符, 处理完成后, 将所有的<code>key</code> 拼接到一起<br>通过<code>key-value</code> 形式的对象来存储数据, <code>key</code> 表示不重复的字符串,<code>value</code>表示<code>boolean</code>类型的值, 为<code>true</code> 则表示字符串出现过.</p><p>然后遍历字符串,判断当前处理的字符串是否存在对象中, 如果存在则不处理, 如果不存在则添加到数组中.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">removeDuplicateChar</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="comment">// 结果数组</span></span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="comment">// 存储对象</span></span><br><span class="line">  <span class="keyword">const</span> json = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 循环字符</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 处理当前的字符</span></span><br><span class="line">    <span class="keyword">let</span> char = str[i];</span><br><span class="line">    <span class="comment">// 如果不存在</span></span><br><span class="line">    <span class="keyword">if</span> (!json[char]) &#123;</span><br><span class="line">      json[char] = <span class="literal">true</span>;</span><br><span class="line">      result.<span class="title function_">push</span>(char);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">removeDuplicateChar</span>(str));</span><br></pre></td></tr></table></figure><h6 id="方法2-2"><a href="#方法2-2" class="headerlink" title="方法2"></a>方法2</h6><p>该方法借助数组的<code>fillter()</code> 函数, 然后在该函数中使用<code>indexOf()</code> 函数判断.</p><p>使用<code>call</code> 函数改变<code>this</code> 让<code>str</code>字符串可以使用<code>Array</code> 数组方法.</p><p>然后再定义<code>fillter()</code> 函数中, 通过<code>indexOf</code>函数判断第一次出现索引的位置, 如果和<code>fillter()</code> 函数的<code>index</code> 一样, 则表示第一次出现, 符合条件的就rerun 出去, 而其他重复的字符串则被忽略掉.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">removeDuplicateChar2</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">filter</span>.<span class="title function_">call</span>(str, <span class="keyword">function</span> (<span class="params">char, index, arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">indexOf</span>(char) === index;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">removeDuplicateChar2</span>(str));</span><br></pre></td></tr></table></figure><h6 id="方法3-2"><a href="#方法3-2" class="headerlink" title="方法3"></a>方法3</h6><p>该方法借助<code>es6</code>的<code>set</code> 数据结构, 再<code>set</code>数据结构中<code>set</code> 具有自动去重的特性,  可以直接将元素去重<br>    将字符串转成数组作为形参, 传入进入生成的<code>set</code>实例中 然后通过<code>...</code>展开运算符号, 直接生成数组, 然后转换成字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">removeDuplicateChar3</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(str.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">  <span class="keyword">return</span> [...set].<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="判断一个字符串是否是回文字符串"><a href="#判断一个字符串是否是回文字符串" class="headerlink" title="判断一个字符串是否是回文字符串"></a>判断一个字符串是否是回文字符串</h5><p>回文字符串是指一个字符串的正序和倒序 是相同的, 如<code>adcdcba</code> 就是一个回文字符串, 该方法不区分大小写.</p><h6 id="方法1-3"><a href="#方法1-3" class="headerlink" title="方法1"></a>方法1</h6><p>该方法主要是将字符串从前往后顺序的字符串按从后往前的顺序的字符逐个比较, 遇到不一样的直接返回<code>false</code>, 否则返回<code>true</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPalindrom1</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果是空字符串, 返回true</span></span><br><span class="line">  <span class="keyword">if</span> (!str.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将字符同意转成小写, 并转换成数组</span></span><br><span class="line">  str = str.<span class="title function_">toLowerCase</span>().<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> strStart = <span class="number">0</span>,</span><br><span class="line">    strEnd = str.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (strStart &lt; strEnd) &#123;</span><br><span class="line">    <span class="comment">// 如果相等责则更改正序和倒叙的字母</span></span><br><span class="line">    <span class="keyword">if</span> (str[strStart] === str[strEnd]) &#123;</span><br><span class="line">      strStart++;</span><br><span class="line">      strEnd--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abcba&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isPalindrom1</span>(str));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="引用数据"><a href="#引用数据" class="headerlink" title="引用数据"></a>引用数据</h2><p>引用类型的数据,和基本数据类型不同的是, 引用类型数据是具有属性和函数的镀锡那个.</p><p>javascript 常用的引用数据类型包括Object ,Array,Date,RegExp,Math,Function以及基本数据类型的包装类型Number, String, Boolean.</p><ul><li>引用数据类型的实例需要通过new 实例来生成, 有的是实例覅用, 有的是隐式调用</li><li>引用数据类型的值是可变的, 基本数据类型的值是不可变的</li><li>引用数据类型比较的是对象的内存地址 而基本数据类型是值的比较.</li></ul><p>Object 类型</p><p>object类型是javascript 中类型中最常用的一种类型, 但是object 类型的操作有何new 操作符号息息相关.</p><h3 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h3><p>在javascript 中new 操作符在执行过程中会改变this 的指向,</p><pre><code>function Person(name, age) &#123;  this.name = name;  this.age = age;&#125;console.log(new Person(&quot;names&quot;, 19));</code></pre><p>上面的代码输出结果包含了name 和age 信息, 但是我们在Person 函数中并未通过return 返返回任何值, 这是为什么呢?看下面代码</p><pre><code>function Person(name, age) &#123;  console.log(this);  this.name = name;  this.age = age;&#125;new Person(&quot;name&quot;, 19);</code></pre><p>在浏览器控制台中我们可以看到, Perosn 的this 打印了自己本身的空的对象, 后面的两句就存粹是给Person 对象添加的属性.</p><p>其实在javascript 中, 如果一个函数没有返回值, 那么默认则return this,但是和又为什么和new 操作符又影响呢~</p><pre><code>function Person(name, age) &#123;  console.log(this);  this.name = name;  this.age = age;&#125;const person = new Person(&quot;name&quot;, 19);</code></pre><p>首先new 一个对象的实例的时候, </p><ul><li>首先会创建一个新的空对象</li><li>然后将新对象的__proto__  属性指向原对象的prototype, 建立新对象和原对之间的链接关系.</li><li>然后执行原对象的构造函数, 并将新对象的上下作为上下文对象(this)传递给构造函数 , 在构造函数内部给新对象添加属性</li><li>再隐式的返回新对象</li></ul><h3 id="Object-类型实例函数"><a href="#Object-类型实例函数" class="headerlink" title="Object 类型实例函数"></a>Object 类型实例函数</h3><p>实例函数是指函数的调用时基于Object 类型的是实例的</p><pre><code>const obj = new Object()</code></pre><h4 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a>hasOwnProperty</h4><p>这个函数的作用是判断该对象自身是否拥有指定名称的实例属性, 但是不会检查实例对象原型链上方的属性</p><pre><code>const o = new Object();o.name = &quot;oname&quot;;console.log(o.hasOwnProperty(&quot;name&quot;)); // trueconsole.log(o.hasOwnProperty(&quot;toString&quot;)); // falseconst Student = function (name) &#123;  this.name = name;&#125;;// 给student 的原型添加一个函数Student.prototype.sayHi = function () &#123;  console.log(&quot;sayhi&quot;, this.name);&#125;;// 初始化函数const stu = new Student(&quot;namea&quot;);stu.sayHi();console.log(stu.hasOwnProperty(&quot;name&quot;)); // trueconsole.log(stu.hasOwnProperty(&quot;sayHi&quot;)); // false</code></pre><h4 id="propertyIsEnumerable-NaN"><a href="#propertyIsEnumerable-NaN" class="headerlink" title="propertyIsEnumerable"></a>propertyIsEnumerable</h4><p>该函数用来判断指定名称的属性是否是实例属性并且是否可以枚举的, 如果 是原型上的属性或者不可枚举的属性返回false</p><pre><code>const arr = [1, 2, 3];arr.name = &quot;Array&quot;;console.log(arr.propertyIsEnumerable(&quot;1&quot;)); //true 实例属性console.log(arr.propertyIsEnumerable(&quot;length&quot;)); //  false 属性继承字Arrayconsole.log(arr.propertyIsEnumerable(&quot;toString&quot;)); // false 属性继承字Object</code></pre><p>自定义对象</p><pre><code>const Perosn = function (name, age) &#123;  this.name = name;  this.age = age;&#125;;Perosn.prototype.address = &quot;shanghai&quot;;Perosn.prototype.say = function () &#123;  console.log(&quot;sayhi&quot;);&#125;;const person = new Perosn(&quot;namas&quot;, 19);console.log(person.propertyIsEnumerable(&quot;name&quot;)); // true 实例对象自身属性console.log(person.propertyIsEnumerable(&quot;address&quot;)); // false 实例对象原型属性console.log(person.propertyIsEnumerable(&quot;say&quot;)); // false 实例对象原型函数// 设置name 属性不可枚举Object.defineProperties(person, &#123;  name: &#123;    enumerable: false,  &#125;,&#125;);console.log(person.propertyIsEnumerable(&quot;name&quot;)); // false</code></pre><h3 id="Object静态函数"><a href="#Object静态函数" class="headerlink" title="Object静态函数"></a>Object静态函数</h3><p>静态函数指的是方法的调用是基于Object类型自身, 不需要通过Object类型的实例</p><h4 id="Obejct-create"><a href="#Obejct-create" class="headerlink" title="Obejct.create()"></a>Obejct.create()</h4><p>该函数的主要作用是创建并返回一个指定原型和指定属性的对象.</p><pre><code>Object.create(proto, propertiesObject)</code></pre><ul><li>proto<br>为新创建对象的原型对象</li><li>propertyObject<br>如果传入的属性为null, 则对象的原型为undefined<br>如果该参数被指定且不为undefined, 则传入该对象可枚举的的自有属性为新创建对象的对应属性名称和描述符.<br>属性的的描述符号对应Object.definePropertyes()的的第二个参数</li></ul><p>创建对象</p><pre><code>const obj = Object.create(null, &#123;  name: &#123;    value: &#39;names&#39;,    writable: true,    enumerable: true,    configurable: true  &#125;&#125;)console.log(obj) // [Object: null prototype] &#123; name: &#39;names&#39; &#125;</code></pre><p>类式继承</p><pre><code>// 父类function Shape() &#123;  this.x = 0;  this.y = 0;&#125;// 父类方法Shape.prototype.move = function (x, y) &#123;  this.x += x;  this.y += y;  console.log(`shape moved x:$&#123;x&#125;, y: $&#123;y&#125; `);&#125;;// 子类function Rectangle() &#123;  //调用父类构造函数  Shape.call(this);&#125;// 继承Rectangle.prototype = Object.create(Shape.prototype, &#123;     /*    这里如果不见Rectangle.prototype.constructor 设置为Rctangle ,    那么它将采用Shape 的 prototype.constructor   */  constructor: &#123;    value: Rectangle,  &#125;,&#125;);const rec = new Rectangle();console.log(&quot;rec 式rectangle 的实例吗? :&quot;, rec instanceof Rectangle);console.log(&quot;rec 是 shape 的实例吗:?:&quot;, rec instanceof Shape);rec.move(1, 1);---------------------rec 式rectangle 的实例吗? : truerec 是 shape 的实例吗:?: true   shape moved x:1, y: 1           </code></pre><p>再性能上Object.create() 比Object.setPrototypeOf() 修改原型更具有性能优势, 但是在创建实例并且访问属性还没有被优化的时候, 他们之间的差异实际上也是可以忽略不计的,</p><p>使用Object.create() 的propertyObject 参数</p><p>Object.create() 方法创建对象在创建的过程中可以更精细的控制对象,它实际上是字面量初始化都西昂的一个语法糖. 在使用Object.create() 创建对象的时候, 我们可以指定对象的原型, 第二个参数可以映射到属性描述符,控制每个属性的可枚举型和可配置性</p><pre><code>const obj = &#123;&#125;;// 等价于const obj = Object.create(Object.prototype);//创建一个新对象, 它的原型是一个新的空对象,并添加了一个名为p, 值为42 的谁能够const obj1 = Object.create(&#123;&#125;, &#123; p: &#123; value: 12 &#125; &#125;);</code></pre><p>前面说到, 在使用Object.create()的时候, 可以传入一个属性为null 的参数, 创建一个原型为null 的对象,在字面量初始化对象的语法中相当使用__proto__</p><pre><code>const obj = Object.create(null)// 等价于const obj = &#123;__proto__: null&#125;</code></pre><p>默认情况下, 使用Object.create() 创建的对象的属性值,属性是不可写,但是不可枚举和不可配置的,如果有需要, 需要显示指定writetable, enumerable, configurable:</p><pre><code>const obj1 = Object.create(&#123;&#125;, &#123; p: &#123; value: 12 &#125; &#125;);console.log(Object.getOwnPropertyDescriptors(obj1));--------------p: &#123;                           value: 12,                   writable: false,             enumerable: false,           configurable: false        &#125;  ---------------  // 如果有需要请显示指定属性描述符  const obj1 = Object.create(&#123;&#125;, &#123; p: &#123; value: 12, writable: true, configurable: true, enumerable: true &#125; &#125;);</code></pre><p>ObJect.create()模仿new 行为</p><pre><code>function Obj2() &#123;&#125;const obj2 = new Obj2();// 等价于const obj3 = Object.create(Obj2.prototype);</code></pre><h4 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames"></a>Object.getOwnPropertyNames</h4><p>ObJect.getOwnProperyNames返回以一个数组, 返回指定对象自身所有的属性,, 包括不可枚举(但不博爱阔使用symbol值作为名称的属性和原型继承的属性)</p><pre><code>function Perosn(name, age) &#123;  this.name = name;  this.age = age;  getName = function () &#123;    return this.name;  &#125;;&#125;Perosn.prototype.eat = function () &#123;  return `吃饭`;&#125;;const p = new Perosn();Object.defineProperty(p, &quot;newvalue&quot;, &#123;  value: &quot;test&quot;,  writable: false,  enumerable: false,  configurable: false,&#125;);console.log(Object.getOwnPropertyNames(p));// [ &#39;name&#39;, &#39;age&#39;, &#39;newvalue&#39; ]</code></pre><p>如果下只是获取不可枚举的属性</p><pre><code>const target = p;const enumAndNonenum = Object.getOwnPropertyNames(target);const enumOnly = new Set(Object.keys(target));const nonenumOnly = enumAndNonenum.filter((key) =&gt; !enumOnly.has(key));</code></pre><h4 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h4><p>该函数主要获取对象的可枚举的实例属性, 不包含原型链继承是属性,数据格式为数组;</p><p>如果需要获取属性的值, 可以使用Object.values()</p><p>如果同时需要获取属性的键值, 可以使用Object.entries</p><pre><code>const objarr = &#123;  a: 1,  b: 2,&#125;;console.log(Object.keys(objarr)); //[a,b]// 获取值console.log(Object.values(objarr));// 同时获取键值console.log(Object.entries(bjarr));</code></pre><h3 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h3><p>判断一个变量是数组还是对象</p><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>在使用typeof 判断数据类型的时候,是不能直接判断一个变量是对象还是数据类型, 因为typeof 在判断基本数据类型的是偶很有用, 但是在判断引用类型的数据的时候,往往不能返回预期的结果类型</p><pre><code>const arr = [1, 2, 3];console.log(typeof arr); // object</code></pre><p>在使用instanceof 虽然不能直接判断一个变量是引用数据类型还是基本数据类型, 但是它可以判断该变量是否是某个数据类型的实例</p><pre><code>const arr = [1, 2, 3];console.log(typeof arr); // objectconsole.log(arr instanceof Array); // trueconst obj = &#123;&#125;;console.log(typeof obj); // objectconsole.log(obj instanceof Object); // true</code></pre><p>判断构造函数 constructor</p><p>判断一个变量是否是数组还是对象, 从另外一个层面将就是判断变量的构造函数时Array 还是Object 类型, 因为一个对象的实例都是通过构造函数的来生成的, 所以可以直接判断一个变量的constructor</p><pre><code>const a = [1, 2, 3];console.log(a.constructor === Array); // trueconsole.log(a.constructor === Object); // falseconst obj = &#123;&#125;;console.log(obj.constructor === Array); // trueconsole.log(obj.constructor === Object); // false</code></pre><p>在javaScript 中每个变量都有一个__proto__ 属性, 表示的是隐式原型. 一个对象的隐式原型指向的是构造函数该对象的构造函数的原型</p><p>toString 函数</p><p>每种引用数据类型都会直接或者间接继承自Object 类型, 因此他们都会包含toString() 函数. 不同的数据类型的toString() 的返回值也是不一样的.</p><p>借助call 函数直接带哦用Object 原型上的toString() 函数, 然后通过返回值判断</p><pre><code>const arr = [1, 2, 3];const obj = &#123;&#125;;const symbol = Symbol();console.log(Object.prototype.toString.call(arr));//[object Array]console.log(Object.prototype.toString.call(obj));//[object Object]console.log(Object.prototype.toString.call(symbol));//[object Symbol]</code></pre><h4 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h4><p>在es5 中数组增加了isArray() 静态函数, 用来判断变量是否为数组. 传入需要判断的变量, 返回一个布尔值,.</p><pre><code>console.log(Array.isArray([]));console.log(Array.isArray(Array.prototype));</code></pre><p>isArray 只能判断一个变量是否为数组, 对于变量是否是变量类型无法判断.</p><h3 id="数组常用"><a href="#数组常用" class="headerlink" title="数组常用"></a>数组常用</h3><h4 id="求数组的最大值和最小值"><a href="#求数组的最大值和最小值" class="headerlink" title="求数组的最大值和最小值"></a>求数组的最大值和最小值</h4><h5 id="自定义扩展函数"><a href="#自定义扩展函数" class="headerlink" title="自定义扩展函数"></a>自定义扩展函数</h5><p>自定义函数. 循环第一个值和后面的值做比较</p><pre><code>Array.prototype.min = function () &#123;  let min = this[0];  let len = this.length;  for (let i = 0; i &lt; len; i++) &#123;    if (this[i] &lt; min) &#123;      min = this[i];    &#125;  &#125;  return min;&#125;;Array.prototype.max = function () &#123;  let max = this[0];  let len = this.length;  for (let i = 0; i &lt; len; i++) &#123;    if (this[i] &gt; max) &#123;      max = this[i];    &#125;  &#125;  return max;&#125;;</code></pre><h5 id="使用Math-对象min-函数和max-函数"><a href="#使用Math-对象min-函数和max-函数" class="headerlink" title="使用Math 对象min  函数和max 函数"></a>使用Math 对象min  函数和max 函数</h5><pre><code>Array.max = function (arr) &#123;  return Math.max.apply(Math, arr);&#125;;Array.min = function (arr) &#123;  return Math.min.apply(Math, arr);&#125;;</code></pre><h5 id="使用reduce-函数"><a href="#使用reduce-函数" class="headerlink" title="使用reduce() 函数"></a>使用reduce() 函数</h5><pre><code>Array.prototype.max = function () &#123;  return this.reduce(function (pre, cur) &#123;    return pre &gt; cur ? pre : cur;  &#125;);&#125;;Array.prototype.min = function () &#123;  return this.reduce((pre, cur) =&gt; &#123;    return pre &lt; cur ? pre : cur;  &#125;);&#125;;</code></pre><h5 id="使用sort-函数"><a href="#使用sort-函数" class="headerlink" title="使用sort() 函数"></a>使用sort() 函数</h5><p>使用sort() 函数的时候如果省略参数的话那么数组元素会被转换为字符串, 然后根据每个字符串的Unicode 排序.</p><p>例如再数值排序中9 出现80 之前, 但是因为数字会被转换为字符串,字符串80 出现9 之前, 所以实际上会80 会排在9 之前.</p><p>如果提供了callback , 那么所有非undefined 的数组元素都会按照函数的返回值进行排序, 如果含有undefined 元素, 那么也会排在末尾.</p><p>  callback 返回值         怕排位顺序     </p><blockquote><p>o             a 在 b 后 如[a, b]<br>&lt; 0              a 在b 前 如[b,a]<br>&#x3D;&#x3D;&#x3D; 0               保持原来的排序    </p></blockquote><pre><code>sort()sort(compareFn)const arrSort = function (a, b) &#123;  return a - b;&#125;;console.log(arr.sort(arrSort)[0]);console.log(arr.sort(arrSort)[arr.length - 1]);</code></pre><h5 id="使用es6-扩展运算符"><a href="#使用es6-扩展运算符" class="headerlink" title="使用es6 扩展运算符"></a>使用es6 扩展运算符</h5><pre><code>Math.max(...arr)// 最大值Math.min(..arr)/ 最小值</code></pre><h5 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h5><p>最原始的for 循环</p><pre><code>const arr = [1,2,3]for(let i = 0; i &lt; arr.length; i++)&#123;    console.log(arr[i])&#125;</code></pre><h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h5><p>按照索引升序的为数组中的每个元素调用一次提供的callback 函数.</p><p>forEach 总是返回undefined,且不能链式调用, 不会改变原数组.</p><p>而且期待的时一个同步函数, 他不会等待Promise 兑现</p><pre><code>array.forEach(callback);array.forEach(callback, thisArr);</code></pre><p>callback :</p><p>为数组中的每个元素执行的函数, 会丢弃的它的返回值, 该函数被调用的时候, hi传入以下的参数.</p><pre><code>element:当前正在处理的元素index:数组中正在处理的当前元素的索引array:调用了forEach 的数组本身.</code></pre><p>thisArr:</p><pre><code>可选参数,在执行callback 时的this值, 如果使用了箭头函数, 则会忽略传入的参数.const arr = [5, 5, 4];arr.forEach((el, index) =&gt; &#123;  console.log(index, el);&#125;);</code></pre><p>ForEach 兼容函数</p><pre><code>Array.prototype.forEach =   Array.prototype.forEach ||  function (fn, context) &#123;    for (let i = 0; (length = this.length); i &lt; length, i++) &#123;      if (typeof fn === &quot; function&quot; &amp;&amp; Object.prototype.hasOwnProperty.call(this, i)) &#123;        fn.call(context, this[i], i, this);      &#125;    &#125;  &#125;;</code></pre><h5 id="map-遍历"><a href="#map-遍历" class="headerlink" title="map() 遍历"></a>map() 遍历</h5><p>map 迭代, 会为数组中的每一个元素调用一次提供的callback, 并用结果构建一个数组.</p><p>map 是一个复制方法, 他不会改变this .在第一次调用callback之前, 数组的长度就已经被保存.</p><ul><li><p>在开始调用map()的时候, callback 不会访问超出数组的初始长度.</p></li><li><p>对已访索引的更改不会导致再次在这些元素上调用callback</p></li><li><p>如果数组中有一个现有的, 尚未被访问的元素被callback 更改, 那么它访问的是该元素被修改后的值, 被删除的元素则不会访问</p><p>  map(callbackFn)<br>  map(callbackFn, thisArg)</p></li></ul><p>callback:</p><pre><code>为数组中的每个元素执行的函数, 它的返回值, 作为一个元素被添加为到新的数组中.element:    数组中当前正在处理的元素index:    正在处理的元素在数组中的索引.array:    调用了map() 的数组的本身let arr = [1, 2, 3];arr.map((el) =&gt; &#123;  console.log(el);&#125;);</code></pre><p>map 重新格式化数组中的对象</p><pre><code>const kvArray = [  &#123; key: 1, value: 10 &#125;,  &#123; key: 2, value: 20 &#125;,  &#123; key: 3, value: 30 &#125;,];const kv = kvArray.map((&#123; key, value &#125;) =&gt; &#123;  return &#123; [key]: value &#125;;&#125;);//[ &#123; &#39;1&#39;: 10 &#125;, &#123; &#39;2&#39;: 20 &#125;, &#123; &#39;3&#39;: 30 &#125; ]// 或者上面对象中的数组转换const arr2 = kv.map((obj) =&gt; &#123;  const key = Object.keys(obj)[0];  const value = obj[key];  return &#123; key, value &#125;;&#125;);/*[  &#123; key: &#39;1&#39;, value: 10 &#125;,  &#123; key: &#39;2&#39;, value: 20 &#125;,  &#123; key: &#39;3&#39;, value: 30 &#125;] */</code></pre><h6 id="parseInt-和-map-一起使用"><a href="#parseInt-和-map-一起使用" class="headerlink" title="parseInt 和 map 一起使用"></a>parseInt 和 map 一起使用</h6><p>再使用map 的时候我们通常都是使用一个参数, 即正在遍历的值.但是再实际应用中, 有些函数是可以接受额外参数. </p><pre><code>[&quot;1&quot;,&quot;2&quot;, &quot;3&quot;].map(parseInt)</code></pre><p>在上面的代码中我峨嵋你期望输出的是[1,2,3] 但是实际结果是[1,nan,nan]<br>在parseInt 函数中通常都是使用一个参数, 即传入的字符串, 但是还有一个可选参数,表示传入的字符以什么进制的基数来转换该字符串.(默认为10<br>进制).<br>但是map在使用的时候, 会传递三个参数:</p><ul><li>元素</li><li>索引</li><li>数组</li></ul><p>在传入parseInt的时候, map 传递进来的参数, 会被默认接受前面两个参数即, 即元素, 索引. 至于为什么不接受数组,<br>是因为parseInt 只接受两个参数, 第三个参数会被忽略.<br>所以上面的代码在迭代的时候大概就是</p><pre><code>// parseInt(string, radix) -&gt; map(parseInt(value, index))/* 第一次迭代 (index 是 0): */ parseInt(&quot;1&quot;, 0); // 1/* 第二次迭代 (index 是 1): */ parseInt(&quot;2&quot;, 1); // NaN/* 第三次迭代 (index 是 2): */ parseInt(&quot;3&quot;, 2); // NaN</code></pre><p>所以在map 和parseInt一起搭配使用的时候, parseInt 需要显示指定进制基数.</p><pre><code>const returnInt = (element) =&gt; parseInt(element, 10);[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(returnInt); // [1, 2, 3]// 实际结果是一个数字数组（如预期）// 与上面相同，但使用简洁的箭头函数语法[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map((str) =&gt; parseInt(str)); // [1, 2, 3]// 实现上述目标更简单的方法，同时避免了“骗招”：[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(Number); // [1, 2, 3]// 但与 parseInt() 不同，Number() 还会返回一个浮点数或（解析）指数表示法：[&quot;1.1&quot;, &quot;2.2e2&quot;, &quot;3e300&quot;].map(Number); // [1.1, 220, 3e+300]// 为了进行比较，如果我们对上面的数组使用 parseInt():[&quot;1.1&quot;, &quot;2.2e2&quot;, &quot;3e300&quot;].map((str) =&gt; parseInt(str)); // [1, 2, 3]</code></pre><p>map 兼容函数</p><pre><code>Array.prototype.map =  Array.prototype.map ||  function (fn, context) &#123;    const arr = [];    if (typeof fn === &quot;function&quot;) &#123;      for (let i = 0; (length = this.length); i &lt; length, i++) &#123;        if (typeof fn == &quot;function&quot; &amp;&amp; Object.prototype.hasOwnProperty.call(this, i)) &#123;          arr.push(fn.call(context, this[i], i, this));        &#125;      &#125;    &#125;    return arr;  &#125;;</code></pre><h5 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter() 函数"></a>filter() 函数</h5><p>为数组中的每个元素执行的函数. 它返回一个真值将元素保留在结果数组中, 否则返回一个假值.<br>filter 是一个复制方法, 他不会改变this, 而是返回一个包含与原始数组相同的元素(其中某些元素已经被过滤掉)的浅拷贝.<br>在第一次第哦啊用callback 之前,数组的长度已经被保存.</p><ul><li><p>但开始调用filter 的时候, callback 不会访问超出数组初始长度的任何元素</p></li><li><p>如果已经数组中的元素已经被访问,如果再发生更改,  那么callback 不会再次访问更改的元素.</p></li><li><p>如果数组中尚有元素没有被callback访问, 那么传递给callback 的值是被修改后的值,</p><p>  filter(callbackFn)<br>  filter(callbackFn, thisArg)</p></li></ul><p>callback</p><p>element</p><pre><code>    数组当前正在处理的元素</code></pre><p>index </p><pre><code>    正在处理的元素在数组中的索引</code></pre><p>array</p><pre><code>    调用fileter() 数组的本身</code></pre><p>thisArg: 可选参数</p><p>返回给定数组的一部分的浅拷贝</p><p>筛选排除所有较小的值</p><p>使用filter 创建一个过滤数组, 该数组删除了小于指定的值的元素, 如:删除所有值小于10 的元素</p><pre><code>function isBigEnough(value) &#123;  return value &gt; 10;&#125;const filterd = arr.filter(isBigEnough);</code></pre><p>找出数组中的所有素数</p><pre><code>const res = arr.filter((value) =&gt; &#123;  for (let i = 2; value &gt; i; i++) &#123;    if (value % i === 0) &#123;      return false;    &#125;  &#125;  return value &gt; 1;&#125;);</code></pre><p>过滤无效数据</p><p>兼容性写法</p><pre><code>Array.prototype.filters =  Array.prototype.filter ||  function (fn, context) &#123;    const arr = [];    if (typeof fn === &quot;function&quot;) &#123;      for (let i = 0, length = this.length; i &lt; length; i++) &#123;        if (typeof fn === &quot;function&quot; &amp;&amp; Object.prototype.hasOwnProperty.call(this, i)) &#123;          fn.call(context, this[i], i, this) &amp;&amp; arr.push(this[i]);        &#125;      &#125;    &#125;    return arr;  &#125;;</code></pre><h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><h5 id="for-遍历数组"><a href="#for-遍历数组" class="headerlink" title="for 遍历数组"></a>for 遍历数组</h5><pre><code>function delRepeat(arr) &#123;  // 新建一个数组保存不重复的值  const res = [];  //  遍历传递进来的数组  for (let i = 0; i &lt; arr.length; i++) &#123;    // 判断当前循环的值是否存在 保存结果的数组    if (res.indexOf(arr[i]) === -1) &#123;      res.push(arr[i]);    &#125;    return res  &#125;</code></pre><h5 id="键值对判断"><a href="#键值对判断" class="headerlink" title="键值对判断"></a>键值对判断</h5><p>对传入的数组进行遍历, 判断当前遍历的值是否是对象的键, 如果是则表示该元素出现过,不作处理, 如果没有出现过, 则表示该元素第一次出现,<br>则给对象插入键, 同时插入新的数组</p><pre><code>function delRepeat(arr) &#123;  const obj = &#123;&#125;,    res = [];  let val, type;  for (let i = 0; i &lt; arr.length; i++) &#123;    val = arr[i];    type = typeof val;    if (!obj[val]) &#123;      obj[val] = [type];      res.push(val);    &#125; else if (obj[val].indexOf(type) &lt; 0) &#123;      // 判断数据类型是否存在      obj[val].push(type);      res.push(val);    &#125;  &#125;  return res;&#125;</code></pre><h5 id="排序去重"><a href="#排序去重" class="headerlink" title="排序去重"></a>排序去重</h5><p>对出传入的数组排序后, 然后对排序后的数组进行相邻元素去重,再将去重后的元素添加到新的数组中</p><pre><code>function delRepeat(arr) &#123;  const res = [arr[0]];  arr.sort((a, b) =&gt; &#123;    return a - b;  &#125;);  for (let i = 0; i &lt; arr.length; i++) &#123;    if (arr[i] !== res[res.length - 1]) &#123;      res.push(arr[i]);    &#125;  &#125;  return res;&#125;</code></pre><h5 id="优先遍数组"><a href="#优先遍数组" class="headerlink" title="优先遍数组"></a>优先遍数组</h5><p>双重fo循环,指定循环的索引i 与j, j的初始值为i + 1. 在每层循环中, 比较索引i 和j 的值是否i案等, 如果相等则表示数组中出现了相同的值.<br>出现了相同的值后, 更新索引i 与 j, 操作为++i, 同时赋值给j, 再对新的索引i 与 j 的值进行比较.</p><pre><code>function delRepeat(arr) &#123;  const res = [];  for (let i = 0; i &lt; arr.length; i++) &#123;    for (let j = i + 1; j &lt; arr.length; j++) &#123;      if (arr[i] === arr[j]) &#123;        j = ++i;        console.log(j);      &#125;    &#125;    res.push(arr[i]);  &#125;  return res;&#125;</code></pre><h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><pre><code>function delRepeat(arr) &#123;  const obj = &#123;&#125;;  let type;  return arr.reduce((previous, current) =&gt; &#123;    type = typeof current;    if (!obj[current]) &#123;      obj[current] = [type];      previous.push(current);    &#125; else if (obj[current].indexOf(type) &lt; 0) &#123;      obj[current].push(type);      previous.push(current);    &#125;    return previous;  &#125;, []);&#125;</code></pre><h5 id="es6-Set-数据结构"><a href="#es6-Set-数据结构" class="headerlink" title="es6 Set 数据结构"></a>es6 Set 数据结构</h5><pre><code>function delRepeat(arr) &#123;  return Array.from(new Set(arr));&#125;</code></pre><h5 id="es6-map-数据结构"><a href="#es6-map-数据结构" class="headerlink" title="es6 map 数据结构"></a>es6 map 数据结构</h5><pre><code>function delRepeat(arr) &#123;  const map = new Map();  return arr.filter((item) =&gt; &#123;    return !map.has(item) &amp;&amp; map.set(item, 1);  &#125;);&#125;</code></pre><p>寻找数组中出现次数最多的元素</p><p>利用键值对</p><p>利用key-value型的键值对数据进行存储.<br>定义一个对象, 再遍历数组的时候, 将数组元素作为对象的键, 将出现的次数作为值.  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">function</span> <span class="title function_">findMost</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (!arr.<span class="property">length</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="property">length</span> === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!res[arr[i]]) &#123;</span><br><span class="line">      res[arr[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(res);</span><br><span class="line">  <span class="keyword">let</span> maxnun = <span class="number">0</span>,</span><br><span class="line">    maxItem;</span><br><span class="line">  len = keys.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res[keys[i]] &gt; maxnun) &#123;</span><br><span class="line">      maxnun = res[keys[i]];</span><br><span class="line">      maxItem = keys[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`出现次数最多的元素是<span class="subst">$&#123;maxItem&#125;</span>, 出现次数是: <span class="subst">$&#123;maxnun&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个方法哟啊遍历两次,第一次遍历传递进来的数组, 第二次遍历对对象, 效率会相对较低.<br>下面对上面的方法优化</p><pre><code>function findMost(arr) &#123;  const res = &#123;&#125;;  let maxNum = 0,    maxItem = null,    len = arr.length;  for (let i = 0; i &lt; len; i++) &#123;    // 保存每次遍历的值    let val = arr[i];    // 再新建对象中判断当前遍历的值是否窜在对象中, 不存在则    // 出现了一次, 如果存在则++    res[val] === undefined ? (res[val] = 1) : res[val]++;    if (res[val] &gt; maxNum) &#123;      maxItem = val;      maxNum = res[val];    &#125;  &#125;  return `出现次数最多的元素是$&#123;maxItem&#125;, 出现次数是: $&#123;maxNum&#125;`;&#125;</code></pre><h5 id="使用reduce"><a href="#使用reduce" class="headerlink" title="使用reduce()"></a>使用reduce()</h5><pre><code>function findMost(arr) &#123;  let maxNum = 1,    maxItem;  const obj = arr.reduce((previous, current) =&gt; &#123;    previous[current] ? previous[current]++ : (previous[current] = 1);    if (previous[current] &gt; maxNum) &#123;      maxNum++;      maxItem = current;    &#125;    return previous;  &#125;, &#123;&#125;);  return `出现次数最多的元素是$&#123;maxItem&#125;, 出现次数是: $&#123;maxNum&#125;`;&#125;</code></pre><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>  在<code>javascript</code> 中的相等分为双等<code>==</code> 和三等<code>===</code> 比较. 和java 那些强类型语言在变量前面需要声明变量类型, 所以在比较的时候就不需要判断变量类型, 只要双等就可以了. 但是<code>javscript</code> 是弱类型语言, 一个变量可以声明任何类型的值, 在比较的时候, 采用的的运算符号不同, 得到的结果也是不同的.</p><ul><li>双等于运算符号在比较的时候, 会将两端的变量进行隐式类型比转换然后比较值的大小</li><li>三等于运算符号在比较的时候, 会优先比较数据类型, 数据类型相同才会去判断值的大小, 对于类型不同的值返回<code>false</code></li></ul><h3 id="等于运算-x3D-x3D-x3D"><a href="#等于运算-x3D-x3D-x3D" class="headerlink" title="等于运算(&#x3D;&#x3D;&#x3D;)"></a>等于运算(&#x3D;&#x3D;&#x3D;)</h3><ul><li>如果比较的值不同直接返回<code>false</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="string">&#x27;1&#x27;</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">true</span> === <span class="string">&#x27;true&#x27;</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>在基本数据类型中存在包装类型, 在未使用<code>new</code> 操作符的时候, 简单类型的数据比较实际上是为值的比较, 在使用了<code>new</code>操作符号以后, 实际得到的值类型, 又会变为引用类型, 在判断的时候会因为值的类型不同返回<code>false</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="title class_">Number</span>(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> === <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">1</span>) <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;str&#x27;</span> == <span class="title class_">String</span>(<span class="string">&#x27;str&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;str&#x27;</span> === <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;str&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>在比较的时候, 如果值的类型都是数值类型, 则直接比较值的大小, 相等则返回<code>true</code> , <code>NaN</code> 和任何数值类型比较都是<code>false</code> 包括自身</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span>;</span><br></pre></td></tr></table></figure><ul><li>比较的如果都是字符串类型, 则判断每个位置的字符是否都一样, 如果一样返回<code>true</code> 否则返回<code>false</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;str&#x27;</span> === <span class="string">&#x27;str&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;str1&#x27;</span> === <span class="string">&#x27;str1&#x27;</span>  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>如果比较的四<code>Boolean</code> 类型, 则两者同时为<code>true</code> 或者<code>false</code> 的时候, 返回<code>true</code>否则返回<code>fasle</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span> === <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">true</span> === <span class="literal">false</span> <span class="comment">// fasle</span></span><br></pre></td></tr></table></figure><ul><li>如果比较的值的是<code>null</code> 或者是<code>undefined</code> ,同理两者都是<code>null</code> 或者<code>undefined</code> 的时候为true, 否则为false</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> === <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">undefined</span> === <span class="literal">undefined</span>  <span class="comment">// true</span></span><br><span class="line"><span class="literal">undefined</span>  === <span class="literal">null</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>如果比较的值是引用类型,则两个引用指向同一个地址的时候, 返回<code>true</code>, 否则返回<code>false</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = []</span><br><span class="line"><span class="keyword">const</span> b = a</span><br><span class="line"><span class="keyword">const</span> c = []</span><br><span class="line">a === b <span class="comment">//true</span></span><br><span class="line">a === c <span class="comment">// false</span></span><br><span class="line">&#123;&#125; === &#123;&#125; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><blockquote><p>在比较引用类型的时候, 只要有一个比那阿联是通过<code>new</code>操作符号等到的, 都会返回<code>false</code> , 无论是引用类型还是基本类型的包装类型  </p></blockquote> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="string">&#x27;hello&#x27;</span> = <span class="keyword">new</span> <span class="title class_">Sritng</span>(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>) === <span class="keyword">new</span> <span class="title class_">Srtring</span>(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line">p1 === p2  <span class="comment">// fasle</span></span><br></pre></td></tr></table></figure><h3 id="typeof-运算符号"><a href="#typeof-运算符号" class="headerlink" title="typeof() 运算符号"></a>typeof() 运算符号</h3><p><code>tyepeof </code> 运算符, 主要用于返回操作数的数据类型, 有两种使用形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tyepeof &#123;&#125;</span><br><span class="line"><span class="title function_">typeof</span>(&#123;&#125;)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">类型</th><th align="center">结果</th></tr></thead><tbody><tr><td align="left">Undefined</td><td align="center">“undefined”</td></tr><tr><td align="left">Null</td><td align="center">“object”</td></tr><tr><td align="left">Boolena</td><td align="center">“boolean”</td></tr><tr><td align="left">Number</td><td align="center">‘number’</td></tr><tr><td align="left">String</td><td align="center">“string”</td></tr><tr><td align="left">Symbol</td><td align="center">“symbol”</td></tr><tr><td align="left">函数对象</td><td align="center">‘function’</td></tr><tr><td align="left">其他任何对象</td><td align="center">‘object’</td></tr></tbody></table><h4 id="typeof-判断null"><a href="#typeof-判断null" class="headerlink" title="typeof 判断null"></a>typeof 判断<code>null</code></h4><p>使用<code>typeof</code> 处理 基本数据类型 <code>null</code> 返回的是<code>Object</code>, 这是因为<code>javascript</code> 在设计的时候一种缺陷.  </p><p>在<code>javascript</code> 最初的时候吗,每种数据类型都会使用<code>3bit</code> 来表示.</p><ul><li>000  表示的是Object 类型  </li><li>001 表示的是Int 类型的数据</li><li>010 表示的是Double 类型的数据</li><li>100 表示的string 类型的数据</li><li>110 表示的Boolean 类型的数据</li></ul><p>由于<code>null</code> 代表的是空指针, 在大多数的平台中的值都是<code>0*00</code> , 因此<code>null</code> 的数据标签就还成了0, 所以在<code>typeof</code> 判断的时候, 返回的是’Object’  </p><h4 id="typeof-运算中的优先级"><a href="#typeof-运算中的优先级" class="headerlink" title="typeof 运算中的优先级"></a>typeof 运算中的优先级</h4><p>在<code>typeof</code> 中有时候括号是必须要存在的, 不然会因为括号的优先级的问题, 导致无法得到我们预想的结果  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">123</span></span><br><span class="line"><span class="keyword">typeof</span> (number + <span class="string">&quot;hello&quot;</span>) <span class="comment">// String</span></span><br><span class="line"><span class="keyword">typeof</span> number + <span class="string">&#x27;hello&#x27;</span> <span class="comment">// Number hello</span></span><br></pre></td></tr></table></figure><p>在<code>typeof</code> 运算中,它自己本身的的优先级会高于字符串拼接符号<code>+</code>, 但是又低于小括号<code>()</code>, 所以在上面代码中, 在没有使用括号的时候, 又优先处理<code>typeof number</code> , 然后返回了<code>number</code> 再和字符串<code>hello</code> 拼接, 得到了<code>number hello</code></p><h3 id="逗号运算"><a href="#逗号运算" class="headerlink" title="逗号运算"></a>逗号运算</h3><p>在<code>javascript</code> 中逗号运算符号, 属于最基本的分隔符号,.</p><p>在另外一方面它也可以作为一个运算符号, , 将多个表达式连接起来, 从左到右依次执行.</p><h4 id="for循环中批量执行表达式"><a href="#for循环中批量执行表达式" class="headerlink" title="for循环中批量执行表达式"></a>for循环中批量执行表达式</h4><p>在<code>for</code>循环中,可以让多个变量表达式变为一个表达式, 然后一次执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i0,j = <span class="number">10</span>; i &lt; <span class="number">10</span>, j &lt; <span class="number">20</span>; i++,j++)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i,j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="交换变量-无须额外的变量"><a href="#交换变量-无须额外的变量" class="headerlink" title="交换变量, 无须额外的变量"></a>交换变量, 无须额外的变量</h4><p>通常我们在交换变量的时候, 都会这样子做,借助一个临时变量存储一个变量的值, 然后再互相复制, 然后实现变量交换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">let</span> c;</span><br><span class="line">c = a;</span><br><span class="line">a = b;</span><br><span class="line">b = c;</span><br></pre></td></tr></table></figure><p>但是我们可以使用逗号运算符号同样达到这个效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="comment">// 方法1</span></span><br><span class="line">a = [b, b = a[<span class="number">0</span>]]</span><br><span class="line"><span class="comment">// 方案2</span></span><br><span class="line">a = [b][b = a , <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>再第一个方案中, <code>[b , b = a]</code> 是一个一维数组, 第二项值是<code>b = a</code>, 也就是a 的值赋值给了 b, 数组的值最终就是 <code>[b,a]</code>, 然后取出索引为 0 的值<code>b</code> , 复赋值给了 变量<code>a</code>, 最终得到了, <code>a = b, b = a</code>,的变量交换.</p><p>在方案2 里面前面的<code>[b]</code> 是一个一维数组, , 后面一部分是[b &#x3D; a, 0], 会先执行<code>b = a</code>, 将a 的值赋值给 b, 然后返回0, 因此得到的击鼓哦是修改了b的值, 斌返回了索引<code>0</code> 最后得到的结果是<code>a = [b][0]</code></p><h4 id="使用小括号保证逗号运算符的优先级"><a href="#使用小括号保证逗号运算符的优先级" class="headerlink" title="使用小括号保证逗号运算符的优先级"></a>使用小括号保证逗号运算符的优先级</h4><p>在所有的运算符号中, 逗号运算符的优先级是最低的, 因此字某些设计优先的级的问题上, 我们需要用到小括号, 将含有逗号运算符的表达式扩起来.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> b = ++a, <span class="number">10</span>; <span class="comment">// 直接报错</span></span><br></pre></td></tr></table></figure><p>对于面的代码为什么会直接报错 是因为同时粗线了赋值运算符和逗号运算符号, 因为逗号运算符的优先级最低, 在执行的时候, 最先执行的肯定是<code>b = ++a</code> 然后再去执行后面的10, 但这不死一个合法的语句, 所以会报错, 解决的办法就是加上小括号.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> b = (++a, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h3 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h3><p>在javscript 中每个运算符号都又自己的优先级, 优先级决定了表达式在执行时的先后顺序, 优先级最高的最先执行, 优先级最低的最后执行. 如果优先级相同那么按照顺序从左往右依次执行.</p><h3 id="toString-函数和valuOf-函数"><a href="#toString-函数和valuOf-函数" class="headerlink" title="toString() 函数和valuOf() 函数"></a>toString() 函数和valuOf() 函数</h3><p>在JavaScript 中<code>toString()</code> 和<code>valueOf</code> 函数解决的时值的运算和显示问题, 在所有的引用类型中都拥有者两个函数.</p><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p>toString() 函数的作用是吧一个逻辑值转换为字符串, 并返回结果.<code>Object</code> 类型数据的<code>toString</code> 函数默认的返回结果是<code>[object Object]</code> 当我们自定义新类的时候, 剋重写<code>toString</code> 函数, 返回可读性更高的结果</p><ul><li><p>Array 函数返回的是以逗号分隔的数组成员</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">toString</span>() <span class="comment">//function Array() &#123; [native code] &#125;</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">toString</span>() <span class="comment">// 1,2 ,3</span></span><br></pre></td></tr></table></figure></li><li><p>Function() 返回的为函数的文本定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toString</span>()); <span class="comment">// function foo() &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="title function_">toString</span>());  <span class="comment">// function Function() &#123; [native code] &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Date 返回的是具有可读性的时间字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toString</span>()); <span class="comment">// Sun Oct 15 2023 18:15:46 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="title function_">toString</span>()); <span class="comment">// function Date() &#123; [native code] &#125;valueOf()函数</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="valueOf-函数"><a href="#valueOf-函数" class="headerlink" title="valueOf() 函数"></a>valueOf() 函数</h4><p>valueOf () 函数的作用是返回最适合应用类的原始值, 如果每日有原始值, 则会返回引用了类型自身.</p><ul><li><p>Array 返回的数组本身</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">valueOf</span>());<span class="comment">//[Function: Array]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">valueOf</span>());<span class="comment">//[ 1, 2 ]</span></span><br></pre></td></tr></table></figure></li><li><p>Function 返回的函数本身</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="title function_">valueOf</span>());<span class="comment">//[Function: Function]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">valueOf</span>());<span class="comment">//[Function: foo]</span></span><br></pre></td></tr></table></figure></li><li><p>Date 返回的指定日期的时间戳</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="title function_">valueOf</span>());<span class="comment">//[Function: Date]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">valueOf</span>());<span class="comment">//1697365471832</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="如果一个引用数据类型同时存在toString-和valueOf-函数"><a href="#如果一个引用数据类型同时存在toString-和valueOf-函数" class="headerlink" title="如果一个引用数据类型同时存在toString() 和valueOf() 函数"></a>如果一个引用数据类型同时存在toString() 和valueOf() 函数</h4><p>如果出现了这种情况, 一般分为两种场景,:</p><ul><li>引用类型转换成String 类型</li><li>引用类型转换成Number类型</li></ul><h5 id="引用类型转换String-类型"><a href="#引用类型转换String-类型" class="headerlink" title="引用类型转换String 类型"></a>引用类型转换String 类型</h5><p>以个引用类型的数据转换成<code>String</code> 类型的时候, 一般是用于数据展示, 转换的时候, 遵循这些规则.</p><ul><li>如果对象具有toString() 函数, 则会优先调用<code>toString()</code> 函数,. 如果返回值是一个原始值, 那么该原始值则会直接转换成字符串表示, 并返回该字符串</li><li>如果对象没有<code>toString</code> 函数, 或者<code>toString()</code> 函数返回的不是一个原始值, 则会去调用<code>valueOf()</code> 函数, 如果<code>valuOf()</code> 返回的是一个引用指, 则会将这个结果转换为字符串类型, 并返回该字符串.</li><li>如果<code>toString()</code> 和<code>valueOf()</code> 函数都获得一个原始值, 那么会直接抛出转换异常</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line">arr.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;toString 函数执行了&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> [];</span><br><span class="line">&#125;;</span><br><span class="line">arr.<span class="property">valueOf</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;valueOf函数执行了&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> [];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">toString</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(arr));</span><br><span class="line"><span class="comment">//toString 函数执行了</span></span><br><span class="line"><span class="comment">// valueOf函数执行了</span></span><br><span class="line"><span class="comment">//Error: Cannot convert object to primitive value</span></span><br></pre></td></tr></table></figure><blockquote><p>在上面的代码中执行String(str) 的时候, 代码期望将arr 转换成一个String 类型,.那么根据转换规则则会优先执行<code>toString()</code> 但是在重写的代码中<code>toString</code>返回的是一个数据, 并不能转换成原生数据, 接下来则会去调用<code>valueOf</code>()  函数, 但是也是返回的是<code>[]</code> 两则都无法转换成基本类型, 则, 抛出了异常</p></blockquote><h5 id="引用类型转换number-类型"><a href="#引用类型转换number-类型" class="headerlink" title="引用类型转换number 类型"></a>引用类型转换number 类型</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line">arr.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;toString 被调用了&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> [];</span><br><span class="line">&#125;;</span><br><span class="line">arr.<span class="property">valueOf</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;valueOf 函数被调用了&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> [];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(arr));</span><br></pre></td></tr></table></figure><p>结果也同样是报错connot convert object to primitive value . 其原理和上面String 转换成 Number大致一样.  </p><h3 id="判空方法"><a href="#判空方法" class="headerlink" title="判空方法"></a>判空方法</h3><p>判断一个变量是否为空数组的时候, 首先需要判断该变量是否是一个数组, 然后通过数组的<code>length</code>属来确定.</p><p>首先使用<code>instanceof</code> 来判断该变量是否是数组的<code>Array</code>的实例, 然后再判断边变量是否有<code>length</code> 属性.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const obj = &#123;&#125;;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="number">1</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Array</span> &amp;&amp; obj.<span class="property">length</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h4 id="判断变量是否为空字符串"><a href="#判断变量是否为空字符串" class="headerlink" title="判断变量是否为空字符串"></a>判断变量是否为空字符串</h4><p>判断一个变量是否为空字符串的时候, 可以直接将其与空字符串相比较, 或者调用<code>trim()</code> 函数去掉字符前后空, 然后判断字符串的长度, 当这两个条件满足任意一个的时候, 变量是一个空字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;&quot;</span> || str.<span class="title function_">trim</span>().<span class="title function_">length</span>()</span><br></pre></td></tr></table></figure><h4 id="判断变量为0-或者NaN"><a href="#判断变量为0-或者NaN" class="headerlink" title="判断变量为0 或者NaN"></a>判断变量为0 或者NaN</h4><p>当一个变量为<code>number</code> 的时候, 判空即判断变量是否为0 或者NaN , 因为NaN 和任何值比较都是<code>false</code> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!(<span class="title class_">Number</span>(num) &amp;&amp; num) == <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="测试标题2"><a href="#测试标题2" class="headerlink" title="测试标题2"></a>测试标题2</h2>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript</title>
      <link href="/2023/10/04/Typescript/"/>
      <url>/2023/10/04/Typescript/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm</title>
      <link href="/2023/10/02/npm/"/>
      <url>/2023/10/02/npm/</url>
      
        <content type="html"><![CDATA[<h2 id="npm-下载源设置"><a href="#npm-下载源设置" class="headerlink" title="npm 下载源设置"></a>npm 下载源设置</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry  <span class="comment">// 查看npm当前镜像源</span></span><br><span class="line"></span><br><span class="line">npm config set registry <span class="attr">https</span>:<span class="comment">//registry.npm.taobao.org/  // 设置npm镜像源为淘宝镜像</span></span><br><span class="line"></span><br><span class="line">yarn config get registry  <span class="comment">// 查看yarn当前镜像源</span></span><br><span class="line"></span><br><span class="line">yarn config set registry <span class="attr">https</span>:<span class="comment">//registry.npm.taobao.org/  // 设置yarn镜像源为淘宝镜像</span></span><br><span class="line"># https -&gt; http，这样网速就会好很多</span><br><span class="line"></span><br><span class="line">npm config set registry <span class="attr">http</span>:<span class="comment">//registry.npmjs.org</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2023/10/02/git/"/>
      <url>/2023/10/02/git/</url>
      
        <content type="html"><![CDATA[<h2 id="git-设置"><a href="#git-设置" class="headerlink" title="git 设置"></a>git 设置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name gitaccount</span><br><span class="line">git config --global user.email gitaccount@example.com</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="git-取消全局设置"><a href="#git-取消全局设置" class="headerlink" title="git 取消全局设置"></a>git 取消全局设置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset user.name</span><br><span class="line">git config --global --unset user.email</span><br><span class="line">git config --global user.name</span><br><span class="line">#全局配置账户已经移除</span><br><span class="line">git config --global user.email</span><br></pre></td></tr></table></figure><h2 id="git-取消代理"><a href="#git-取消代理" class="headerlink" title="git 取消代理"></a>git 取消代理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset https.proxy</span><br><span class="line">git config --global --unset http.proxy</span><br></pre></td></tr></table></figure><h2 id="error-RPC-failed；-curl-28-OpenSSL-SSL-read-Connection-was-reset-errno-10054-fatal-expected-证书错误"><a href="#error-RPC-failed；-curl-28-OpenSSL-SSL-read-Connection-was-reset-errno-10054-fatal-expected-证书错误" class="headerlink" title="error: RPC failed； curl 28 OpenSSL SSL_read: Connection was reset, errno 10054 fatal: expected 证书错误"></a>error: RPC failed； curl 28 OpenSSL SSL_read: Connection was reset, errno 10054 fatal: expected 证书错误</h2><p>忽略证书错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的javascript阅读笔记</title>
      <link href="/2023/10/01/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/10/01/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>在JavaScript 中对象可以通过两种形式定义,: 声明和构造形式.</p><p>对象声明:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br></pre></td></tr></table></figure><p>构造声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cosnt obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj.<span class="property">value</span> = value</span><br></pre></td></tr></table></figure><p>上面两种生成的对象是一样. 区别只在在于, 在对象声明中我们可以一次性添加多个键值对, 而构造声明需要诸葛添加属性</p><h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>在JavaScript 中主要有六种数据类型:</p><ul><li>string</li><li>number</li><li>boolean</li><li>null</li><li>undefined</li><li>object</li></ul><p>在上面的(string, boolean, number, null, undefined) 本省并不是一个对象, null 又时候虽然也被当做一个对象, 但这其实本身是语言的一个bug,是因为对null 执行 <code>type of </code>  的时候会返回字符串“object”, 但严格意义来说null 本身属于基本类型.</p><p>JavaScript 中的函数也属于对象的一个子类型, </p><h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><ul><li>String</li><li>Number</li><li>Boolean</li><li>Object</li><li>Function</li><li>Array</li><li>Date</li><li>RegExp</li><li>Error</li></ul><h3 id="对象键值"><a href="#对象键值" class="headerlink" title="对象键值"></a>对象键值</h3><p>对象的内容本身是由任意类型的值,组成的我们统称为属性,</p><p>在需要访问对象的值的时候我们通常使用<code>.</code> 操作符, 或者<code>[]</code> 操作符来访问. 其中前者被称为属性访问, 后者被称为见访问.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 点操作符</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span>);</span><br><span class="line"><span class="comment">// 属性操作</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj[<span class="string">&#x27;a&#x27;</span>]);</span><br></pre></td></tr></table></figure><p>这两种属性访问的区别在于,<code>.</code> 操作符需要满足标识符的命名规范, 而<code>[“”]</code> 操作符, 可以接受任何UTF-8&#x2F;Unicode字符串为属性名.</p><p>在对象中属性永远都是字符串,即使使用string 意外的字面量为属性名, 但是他也会隐性转换为字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cosnt obj = &#123;</span><br><span class="line"><span class="number">2</span>: a</span><br><span class="line"><span class="string">&quot;2&quot;</span>:b</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h3><p>在JavaScript 中如果访问的对象属性是一个函数在其他语言中, 在理解中这个函数可以被称为对象的访问, 但是在JavaScript 语法规范中, 函数永远不会属于一个对象,. 这是因为函数具有<code>this</code>的引用, 虽然有时这些<code>this</code> 确实会指向调用位置的对象引用. 但是JavaScript 的 this 是在运行时根据调用位置动态绑定, 函数和对象的关系只能称为间接关系</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> someFoo = foo;</span><br><span class="line"><span class="keyword">const</span> myObject = &#123;</span><br><span class="line">  <span class="attr">someFoo</span>: foo,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(someFoo);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myObject.<span class="property">someFoo</span>);</span><br></pre></td></tr></table></figure><p>正如上面的代码中, <code>someFoo</code> 和 <code> Object.someFoo</code>  中都是对同一个函数 <code>foo</code> 的引用, 同理这也能说明 对象中的函数,它并不是属于对象的一个方法.</p><h3 id="对象复制Object-assign"><a href="#对象复制Object-assign" class="headerlink" title="对象复制Object.assign()"></a>对象复制Object.assign()</h3><p>对象的复制分为浅拷贝和深拷贝.</p><p>浅拷贝:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">const</span> newobj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;p1&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> person2 = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> person1) &#123;</span><br><span class="line">    person2[key] = person1[key];</span><br><span class="line">  &#125;</span><br><span class="line">  person2.<span class="property">name</span> = <span class="string">&#x27;p2&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(person1, person2);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>深拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">origin, target</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> target = target || &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> toStr = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>;</span><br><span class="line">    <span class="keyword">var</span> arrType = <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> origin) &#123;</span><br><span class="line">      <span class="keyword">if</span> (origin.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> origin[key] === <span class="string">&#x27;object&#x27;</span> &amp;&amp; origin[key] !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (toStr.<span class="title function_">call</span>(origin[key]) === arrType) &#123;</span><br><span class="line">            target[key] = [];</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target[key] = &#123;&#125;;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="title function_">deepClone</span>(origin[key], target[key]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          target[key] = origin[key];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>JSON 拷贝</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 对象属性描述符 getOwnPropertyDescriptor</span><br><span class="line"></span><br><span class="line">在ES5 之前, javascript 本身没有提供可以直接检测属性特性的方法,  比如判断属性是否只读, 但是从es5开始, 所有的属性都具备了属性描述符.</span><br><span class="line"></span><br><span class="line">`getOwnPropertyDescriptor` 来查看对象属性</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">const obj = &#123;</span><br><span class="line">  a: 2,</span><br><span class="line">&#125;;</span><br><span class="line">Object.getOwnPropertyDesscriptor(&#x27;obj&#x27;, &quot;a&quot;) // &#123; value: 2, writable: true, enumerable: true, configurable: true &#125;</span><br></pre></td></tr></table></figure><p>返回的对象包含了, 该对象的属性描述</p><ul><li><p>value : 表示该属性的值</p></li><li><p>writable:  表示该值是否可以 更改</p></li><li><p>enumerable: 表示该值是否可以枚举</p></li><li><p>configurable:  表示该值是否可以配置</p></li></ul><p><code>getOwnPropertyDescriptors</code> 产看该对对象的所有属性描述</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj));</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">a</span>: &#123; <span class="attr">value</span>: <span class="number">2</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="attr">b</span>: &#123; <span class="attr">value</span>: <span class="number">2</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的对象时我们我自己声明了一个对象, 看到声明对象的属性个的默认配置, 全部为true, 那么是否是在任何时候对象的属性描述都是true呢?</p><p>在创建普通属性时, 属性描述符都是使用的默认值,默认值都为true, 那么在使用<code>Object.defineProperty</code>  给一个对象添加属性或者修改一个属性,(如果configurable : true的话)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">2</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj));</span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line">  <span class="attr">a</span>: &#123; <span class="attr">value</span>: <span class="number">2</span>, <span class="attr">writable</span>: <span class="literal">false</span>, <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">configurable</span>: <span class="literal">false</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码可以看到在使用<code>Object.difinePeoperty</code> 为对象添加的属性在不显式执行描述符的时候, 该属性描述符这时候为false,当然也可以在对象添加对属性的时候, 显示的指定的添加.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="对象禁止扩展Object-preventExtensions"><a href="#对象禁止扩展Object-preventExtensions" class="headerlink" title="对象禁止扩展Object.preventExtensions(..)"></a>对象禁止扩展Object.preventExtensions(..)</h3><p>禁止一个对象添加属性, 并且保留自己的属性, 在非严格模式下, 创建新属性会静默失败, 在严格模式下, 会抛出<code>typeError</code> 错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(obj);</span><br><span class="line">obj.<span class="property">b</span> = <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj));</span><br><span class="line"><span class="comment">// 可以看到新添加的属性无法添加进去</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">a</span>: &#123; <span class="attr">value</span>: <span class="number">2</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象密封-Object-seal"><a href="#对象密封-Object-seal" class="headerlink" title="对象密封 Object.seal()"></a>对象密封 Object.seal()</h3><p>该方法是在<code>Object.preventExtensions</code> 的扩展,把现有对象属性的描述符<code>configurable</code> 标记改为false.  在使用该方法后 , 不仅不能添加新符属性,, 也不能重新配置或者删除现有属性, 但是可以修改现有属性值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Object.seal() 前</span></span><br><span class="line"><span class="comment">// a: &#123; value: 2, writable: true, enumerable: true, configurable: true &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.seal() 后</span></span><br><span class="line"><span class="comment">//a: &#123; value: 2, writable: true, enumerable: true, configurable: false &#125;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">seal</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj));</span><br></pre></td></tr></table></figure><h3 id="对象冻结Object-freeze"><a href="#对象冻结Object-freeze" class="headerlink" title="对象冻结Object.freeze()"></a>对象冻结Object.freeze()</h3><p>该方法h会在现有对象上调用<code>Object.seal</code> 把数据属性标记为<code> writable: fale</code> 使用了该方法可以禁止该对象本身任意属性的直接修改, 但是对象用用的其他对象不受影响.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Object.frreze 前</span></span><br><span class="line"><span class="comment">// a: &#123; value: 2, writable: true, enumerable: true, configurable: true &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj));</span><br><span class="line"><span class="comment">// Object.freeze 后</span></span><br><span class="line"><span class="comment">// a: &#123; value: 2, writable: false, enumerable: true, configurable: false &#125;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj));</span><br><span class="line"><span class="comment">// 修改属性本身也是失败</span></span><br><span class="line">obj.<span class="property">a</span> = <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>在冻结之前对象引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;a : <span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">// 在冻结之前浅拷贝复制一个对象</span></span><br><span class="line"><span class="keyword">const</span> newObj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj)</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj)</span><br><span class="line"><span class="comment">// a: &#123; value: 2, writable: false, enumerable: true, configurable: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj));</span><br><span class="line"><span class="comment">// a: &#123; value: 2, writable: true, enumerable: true, configurable: true &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(newObj));</span><br><span class="line"><span class="comment">// 修改成功</span></span><br><span class="line">newObj.<span class="property">a</span> = <span class="number">2</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="对象解冻Object-isFrozen"><a href="#对象解冻Object-isFrozen" class="headerlink" title="对象解冻Object.isFrozen"></a>对象解冻Object.isFrozen</h3><p>该方法判断一个对象是否被冻结, 如果被冻结,将返回true.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(Object.isFrozen(obj))&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象枚举"><a href="#对象枚举" class="headerlink" title="对象枚举"></a>对象枚举</h3><p>在对象属性描述中有一个属性: <code>enumerable</code> 配置对象属性是否可以枚举,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(obj, &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 可枚举</span></span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">b</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 不可枚举</span></span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 属性访问全部都能正常访问</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span>, obj.<span class="property">b</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b&quot;</span> <span class="keyword">in</span> obj)</span><br><span class="line">obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;b&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历对象</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="comment">// a: 1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(k, obj[k])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中 , 使用了<code>Object.defineProperties</code> 配置了<code>a, b</code> 两个属性, 一个<code>enumerable</code> 配置为false, 一个配置了true,在我们使用了<code>.</code> 访问的时候, 是都能访问到全部属性的, 但是在<code> for</code> 循环中却只出现了一个属性<code>a</code> </p><p>如果需要判断一个属性在对象中是否可以枚举:<strong>propertyIsEnumerable</strong>()</p><p>该方法会检查给定的属性是否直存在对象中, (不会检查原型链)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&quot;a&quot;</span>)<span class="comment">// true</span></span><br><span class="line">obj.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&quot;b&quot;</span>)<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>至于in 和hasOwnProperty 也可以判断一个属性是否存在对象中, 他们的区别在于, <code>in</code> 只会判断对象本身自身是否包含, <code>hasOwnProperty</code> 则会查找原型链</p><p>下面的方法, 要可以枚举对象的属性</p><h4 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h4><p>该方法会返回一个数组, 包含所有可枚举的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)</span><br></pre></td></tr></table></figure><h4 id="Object-gerOwnProeprtyNames"><a href="#Object-gerOwnProeprtyNames" class="headerlink" title="Object.gerOwnProeprtyNames()"></a>Object.gerOwnProeprtyNames()</h4><p>该方法也会返回指定对象中所有的属性, 无论是否可以枚举</p><h3 id="对象遍历"><a href="#对象遍历" class="headerlink" title="对象遍历"></a>对象遍历</h3><h2 id="混合对象“类”"><a href="#混合对象“类”" class="headerlink" title="混合对象“类”"></a>混合对象“类”</h2><p>在面向对象对象编程语言中, 关于对象一直有着这几种机制: 多态, 类, 继承, 封装</p><ul><li>类描述了对象的属性(数据)和方法(行为,) 类也是对象的抽象</li><li>多态: 描述了对象可以根据上下文的不同的表现的多种状态, 可以使用类定义或接口定义的抽象类型的子类对象, 极大的提高了对象的灵活性和扩展性</li><li>继承: 允许一个类继承另外一个类, 通过继承子类可以重用父类的代码, 并可以扩展或修改父类的行为</li><li>封装: 指的是将数据和操作数据的行为包装在一起的机制, 以防止外部直接访问和修改对象内部的状态. 通过封装, 内部的对象细节对外是影藏的, 只提供公共接口来给其他对象使用</li></ul><p>在hjavascript 中想要实现一个类:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">color</span> = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">show</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> car = <span class="keyword">new</span> <span class="title class_">Car</span>()</span><br><span class="line">car.<span class="title function_">show</span>()</span><br></pre></td></tr></table></figure><p>在以前都是使用构造函数来生成一个类,然后<code>new</code> 一个实例出来</p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="prototype"><a href="#prototype" class="headerlink" title="[[prototype]]"></a>[[prototype]]</h3><p>[[prototype]] 是javascript 对象的内置属性, 他是对象之间继承关系的基础, 在javascript 中, 每一个对象都有一个[[prototype]] , 它指向另外一个对象或者为null . 这个指向的对象被称为原型<code>prototype</code> 当我们访问一个对象的属性时, 如果该对象本身没有该属性, 那么javascript 就会一层层的自动向上去原型上查找,称之为原型链</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj1name&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;obj2value&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202310052114724.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202310052114724.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>上面的代码可以看到这时候两个obj 的<code>prototype</code> 指向的是<code>Object</code> </p><p>我们使<code>Object.setPrototypeOf()</code> 设置一下原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将obj1 ,设置为obj2 的原型</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj2, obj1)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202310052235802.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202310052235802.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这时候呢个看到<code>obj2</code> 上的原型属性已经变为<code>obj1</code> 的属性了.</p><p>每一个<code>Object.prototype</code> 的顶部都是<code>Object</code>的 原型</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>在严格意义上来说javascript 是一个只有对象没有类的语言. 因为javascript 的无法创造类, 即使后面推出了<code>class</code> 之流的关键字, 但是本质上依旧是原型的改版而已</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><p>在javscript 中经常使用模拟类的行为的方法,但是只有类不能继承的话, 那就是一个空架子, 虽然在es5 之后推出了<code>extend</code> 关键字来解决了类的继承问题. 那在es5 之前是这么解决的呢~</p><h2 id="行为委托"><a href="#行为委托" class="headerlink" title="行为委托"></a>行为委托</h2><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript 高级程序设计阅读笔记</title>
      <link href="/2023/10/01/javascript%20%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/10/01/javascript%20%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo</title>
      <link href="/2023/09/30/hexo%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/09/30/hexo%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="关于hexo-git-上传老是超时报错"><a href="#关于hexo-git-上传老是超时报错" class="headerlink" title="关于hexo git 上传老是超时报错"></a>关于hexo git 上传老是超时报错</h2><p>在配置完hexo 上传发布到 git 的时候老是会报错ssl, 超时错误.</p><p><img src="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202309302337039.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202309302337039.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这时候可以修改hexo 根目录下的<code>_config.yml</code>的<code> deploy</code> 项的<code>repo</code> 下面是默认的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## repo: https://github.com/rongchaoChen/rongchaoChen.github.io.git</span><br></pre></td></tr></table></figure><p>修改成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">repo: git@github.com:git用户名/git用户名.github.io</span><br></pre></td></tr></table></figure><h2 id="hexo-文章模版"><a href="#hexo-文章模版" class="headerlink" title="hexo 文章模版"></a>hexo 文章模版</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">titile:文章名称</span><br><span class="line">author: chen</span><br><span class="line">categories: [文章分类]</span><br><span class="line">tag: &quot;文章标签&quot;</span><br><span class="line"></span><br><span class="line">文章摘要</span><br><span class="line">&lt;!--more --&gt;</span><br><span class="line">正文</span><br></pre></td></tr></table></figure><table><thead><tr><th>page</th><th>独立页面</th></tr></thead><tbody><tr><td>post</td><td>文章页面</td></tr><tr><td>docs</td><td>文档页面</td></tr><tr><td>category</td><td>分类页面</td></tr><tr><td>tag</td><td>标签页面</td></tr><tr><td>friends</td><td>友链页面</td></tr><tr><td>list</td><td>列表页面</td></tr></tbody></table><h2 id="文章布局"><a href="#文章布局" class="headerlink" title="文章布局"></a>文章布局</h2><h3 id="文章分类"><a href="#文章分类" class="headerlink" title="文章分类"></a>文章分类</h3><p>多个分类有两种关系，一种是层级（等同于文件夹），一种是并列（等同于标签）。</p><p>多级分类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">categories: [分类A, 分类B]</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - 分类A</span><br><span class="line">  - 分类B</span><br></pre></td></tr></table></figure><p>并列分类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - [分类A]</span><br><span class="line">  - [分类B]</span><br></pre></td></tr></table></figure><p>多级加并列分类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - [分类A, 分类B]</span><br><span class="line">  - [分类C, 分类D]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript this</title>
      <link href="/2023/04/09/javascript%20this/"/>
      <url>/2023/04/09/javascript%20this/</url>
      
        <content type="html"><![CDATA[<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>在javascript 中, 因为是一门弱类型语言, 在很多时候, 总是会和强类型语言,如java python 这种强类型语言又着一些很不同的区别.</p><p>就如this 而言, 在常规认知理解中, this 顾名思义从英语的语法角度来说 把他理解成指向函数的本身.但是事实真的是这样的吗.</p><p>首先我们来看下面这段代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">num</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo:&quot;</span> + num)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">&#125;</span><br><span class="line">foo.<span class="property">count</span>= <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt; <span class="number">5</span>)&#123;</span><br><span class="line">    <span class="title function_">foo</span>(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">count</span>)</span><br></pre></td></tr></table></figure><p>在上面的代码中我们声明了一个foo ()函数, 并给foo()函数传递了一个形参,在函数内部中我们打印了这个传递进来的形参,并调用了一个count的参数, 来记录当前foo()函数被调用的次数, 在外面for()循环中, 当i &gt; 5  的时候, 这时候i 就会传递进去foo(num)形参当中, 最后我们consloe.log(foo.count)来记录foo()一共被调用了几次. 运行代码的结果如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">foo</span>: <span class="number">6</span></span><br><span class="line"><span class="attr">foo</span>: <span class="number">7</span></span><br><span class="line"><span class="attr">foo</span>: <span class="number">8</span></span><br><span class="line"><span class="attr">foo</span>: <span class="number">9</span></span><br><span class="line"><span class="attr">count</span>: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>count 为什么是0呢?从输出结果来看foo()函数确实是被被调用了四次, 但是里面的this.count++ , 却没有增加.那是因为this.count 的this 的本身没有指向foo() 函数半身. 可是我在外面已经foo.count &#x3D; 0; 声明了啊</p><p>首先我们来看foo()本身的this, 其实是指向 全局的, this.count 也就相当于说是在全局创建了一个count 的变量.当我们在调用foo 函数的时候, foo.count是会被自增的, 但是它所在的对象this.count 却不会自增.那么我该怎么解决呢!</p><p>首先我们可以把foo 函数中的this.count .改成foo.count . 这时候虽然能解决当下的问题, 但是却没有解决实质性的问题,  如何指向当前的this.</p><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>call函数 使用一个指定的this 值和单独给出的一个或多个参数来调用一个函数.那么来改变一下上面的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">num</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo:&quot;</span> + num)</span><br><span class="line"><span class="comment">// 因为当前this 不指向foo 函数本身</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">&#125;</span><br><span class="line">foo.<span class="property">count</span>= <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt; <span class="number">5</span>)&#123;</span><br><span class="line"><span class="comment">// 那么在这里使用call 函数让this指向foo 函数</span></span><br><span class="line">    foo.<span class="title function_">call</span>(foo,i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这时候输出结果符合我们</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">count</span>)</span><br></pre></td></tr></table></figure><p>- </p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>intellij配置Tomcat</title>
      <link href="/2023/03/26/intellij%E9%85%8D%E7%BD%AETomcat/"/>
      <url>/2023/03/26/intellij%E9%85%8D%E7%BD%AETomcat/</url>
      
        <content type="html"><![CDATA[<p>记录一下intellij配置Tomcat, 首先intellij 和 tomcat 是肯定要的, intellij 版本为2022.1 ,tomcat为9.</p><h2 id="第一步打开Intellij"><a href="#第一步打开Intellij" class="headerlink" title="第一步打开Intellij"></a>第一步打开Intellij</h2><p>这时后在打开的目录下, 创建一个 new module, 选择java , 然后next 输入这个mdoule 名就好</p><img src="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202303262148791.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202303262148791.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="图片alt"  /><ul><li>然后再这个新module 上右键选择 Add Framewrok Support 选择</li></ul><p><img src="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202303262150533.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202303262150533.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><ul><li><p>然后这时候的目录就是这样,然后我们再WEB-INF下面创建一个lib 文件和一个classes 文件 , lib 用来解压tomcat的jar包, classes,这时候我们的目录就搭建好了, 开始配置Tomcat</p><p><img src="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202303262151014.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202303262151014.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></li></ul><h2 id="配置Tomcat"><a href="#配置Tomcat" class="headerlink" title="配置Tomcat"></a>配置Tomcat</h2><p>注意Tomcat 和TomEE 不要选错 , 然后点击local  确认</p><p><img src="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202303262156082.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202303262156082.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><ul><li><p>这时候来到这里 选择自己安装好的Tomcat, </p><p><img src="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202303262221159.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202303262221159.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></li><li><p>这时候再点击Deployment</p><p><img src="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202303262225486.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202303262225486.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></li></ul><p><img src="C:\Users\chenr\AppData\Roaming\Typora\typora-user-images\image-20230326222336713.png" class="lazyload" data-srcset="C:\Users\chenr\AppData\Roaming\Typora\typora-user-images\image-20230326222336713.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230326222336713"></p><p><img src="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202303262226215.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202303262226215.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h2 id="项目设置"><a href="#项目设置" class="headerlink" title="项目设置"></a>项目设置</h2><p><img src="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202303262228947.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202303262228947.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><ul><li>这里Jar 包的目录选择之前创建的lib 文件中,</li></ul><p><img src="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202303262236722.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202303262236722.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202303262238289.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202303262238289.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><ul><li><p>然后点击Paths把再把之前创建好的classes 文件设置成output path 的路径</p><p><img src="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202303262242011.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/rongchaoChen/mypic/main/img/202303262242011.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></li></ul><p>然后启动Tomcat j就好了</p>]]></content>
      
      
      <categories>
          
          <category> intellij </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack/vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack4配置vue2\3</title>
      <link href="/2023/03/26/webpack4%E9%85%8D%E7%BD%AEvue23/"/>
      <url>/2023/03/26/webpack4%E9%85%8D%E7%BD%AEvue23/</url>
      
        <content type="html"><![CDATA[<p>这样配置的时候适合再学习vu2&#x2F;3 学习切换的时候,到时就不用切换项目,只要每次重新配置一下webpack.config.js 就可以了.</p><h2 id="vue2配置"><a href="#vue2配置" class="headerlink" title="vue2配置"></a>vue2配置</h2><p>首先我们创建一个文件. </p><ul><li><p>在根目录下初始化文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure></li><li><p>创建vue 目录文件夹, src, public.在publuc 目录下创建index.html,引入vue2 cdn</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>然后我们在 src 目录下创建一个main.js 来作为我们的入口文件</p></li><li><p>然后开始下载依赖.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">webpack@<span class="number">4.44</span><span class="number">.2</span></span><br><span class="line">webpack-cli@<span class="number">3.3</span><span class="number">.12</span></span><br><span class="line">webpack-dev-server@<span class="number">3.11</span><span class="number">.2</span></span><br><span class="line">html-webpack-plugin@<span class="number">4.5</span></span><br><span class="line">vue-template-compiler@<span class="number">2.7</span><span class="number">.14</span></span><br><span class="line">vue-loader@<span class="number">15.0</span>-<span class="number">15.9</span></span><br></pre></td></tr></table></figure></li><li><p>然后我们开始配置webpack.config.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const &#123; resolve &#125; = require(&#x27;path&#x27;);</span><br><span class="line">const htmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);</span><br><span class="line">// 注意这里的vue-loader 一定要在16.0版本一下, 不然版本不兼容</span><br><span class="line">const VueLoaderPlugin = require(&#x27;vue-loader/lib/plugin&#x27;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &#x27;development&#x27;,</span><br><span class="line">  entry: &#x27;./src/main.js&#x27;,</span><br><span class="line">  output:&#123;</span><br><span class="line">    path: resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">    filename: &#x27;main.js&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  externals:&#123;</span><br><span class="line">    &#x27;vue&#x27;: &#x27;Vue&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: &#x27;source-map&#x27;,</span><br><span class="line">  module:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.vue$/,</span><br><span class="line">        loader: &#x27;vue-loader&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins:[</span><br><span class="line">    new VueLoaderPlugin(),</span><br><span class="line">    new htmlWebpackPlugin( &#123;</span><br><span class="line">      template:resolve(__dirname,&#x27;public/index.html&#x27;)</span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在main.js 创建Vue的实例挂载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  render:h =&gt; h(App)</span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure></li><li><p>在src 下创建一个App.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;App&quot;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      title: &quot;hello word vue2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>修改package.json, 位置启动项webpack-server-cli</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">   &quot;dev&quot;: &quot;webpack-dev-server&quot;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>这时候,如果没有出现插件兼容的问题, 基本就是没问题,可以npm run dev 启动了</p></li></ul><h2 id="vue3-配置"><a href="#vue3-配置" class="headerlink" title="vue3 配置"></a>vue3 配置</h2><p>在切换vue 的3 我们主要是替换vue-loader 就好了</p><ul><li><p>下载@vue&#x2F;compiler-sfc&#96;是Vue.js 3的一个核心软件包, 而且这时候vue-loader 也要更新16.0 以上的版本最好不要17,不然需要处理兼容性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vue-loader@next@16.1.1</span><br><span class="line">npm i -d @vue/compiler-sfc@3.1.2</span><br></pre></td></tr></table></figure></li><li><p>下载好插件后, 修改一下webpack.config.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const VueLoaderPlugin = require(&#x27;vue-loader/lib/plugin&#x27;);</span><br><span class="line">// 这时候需要把之前引用vu2 的loader 修改成</span><br><span class="line">const &#123;VueLoaderPlugin&#125; = require(&#x27;vue-loader&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>然后修改main.js 的vue 挂载方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.createApp(App).mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure></li><li><p>修改index.html 中vue的cdn 引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@3.1.2/dist/vue.global.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>然后重新启动npm run dev</p></li></ul><h2 id="vue2-和vue3-切换"><a href="#vue2-和vue3-切换" class="headerlink" title="vue2 和vue3 切换"></a>vue2 和vue3 切换</h2><p>在配置好以后, 以后在这项目中, 每次切换的时候需要</p><ul><li><p>修改index.html 的Vue cdn 引用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// vue 2</span><br><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">// vue3</span><br><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@3.1.2/dist/vue.global.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>修改webcpack.comfig.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// vue2 loader</span><br><span class="line">// const VueLoaderPlugin = require(&#x27;vue-loader/lib/plugin&#x27;);</span><br><span class="line">// vue3 loader</span><br><span class="line">const &#123; VueLoaderPlugin &#125; = require(&#x27;vue-loader&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>注意每次vue 2 切换 3 的时候,vue-loader 都要重新下载依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// vue2 切换3</span><br><span class="line">vue-loader@next@16.1.1</span><br><span class="line"></span><br><span class="line">npm i -d @vue/compiler-sfc@3.1.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vue3 切换vue2 </span><br><span class="line"></span><br><span class="line">vue-loader@15.0-15.9</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实在官网说明现在说明建议使用脚手架来构建了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init vue@latest</span><br></pre></td></tr></table></figure><p>而且在vue3 @vue&#x2F;compiler-sfc 核心包,已经停止维护了, 但是这样搭建也可以在学习2&#x2F;3 的时候方便切换,</p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack/vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello</title>
      <link href="/2023/03/25/hello/"/>
      <url>/2023/03/25/hello/</url>
      
        <content type="html"><![CDATA[<h1 id="这是标题1"><a href="#这是标题1" class="headerlink" title="这是标题1"></a>这是标题1</h1><h2 id="这是标题2"><a href="#这是标题2" class="headerlink" title="这是标题2"></a>这是标题2</h2><h2 id="这是标题2-1"><a href="#这是标题2-1" class="headerlink" title="这是标题2"></a>这是标题2</h2><h3 id="这是标题3"><a href="#这是标题3" class="headerlink" title="这是标题3"></a>这是标题3</h3><h3 id="这是标题3-1"><a href="#这是标题3-1" class="headerlink" title="这是标题3"></a>这是标题3</h3><h3 id="这是标题3-2"><a href="#这是标题3-2" class="headerlink" title="这是标题3"></a>这是标题3</h3><h2 id="这是标题2-2"><a href="#这是标题2-2" class="headerlink" title="这是标题2"></a>这是标题2</h2><h3 id="这是标题3-3"><a href="#这是标题3-3" class="headerlink" title="这是标题3"></a>这是标题3</h3><h3 id="这是标题3-4"><a href="#这是标题3-4" class="headerlink" title="这是标题3"></a>这是标题3</h3><h3 id="这是标题3-5"><a href="#这是标题3-5" class="headerlink" title="这是标题3"></a>这是标题3</h3><h2 id="这是标题2-3"><a href="#这是标题2-3" class="headerlink" title="这是标题2"></a>这是标题2</h2><h3 id="这是标题3-6"><a href="#这是标题3-6" class="headerlink" title="这是标题3"></a>这是标题3</h3><h3 id="这是标题3-7"><a href="#这是标题3-7" class="headerlink" title="这是标题3"></a>这是标题3</h3><h3 id="这是标题3-8"><a href="#这是标题3-8" class="headerlink" title="这是标题3"></a>这是标题3</h3>]]></content>
      
      
      <categories>
          
          <category> 测试分类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tt</title>
      <link href="/2023/03/25/tt/"/>
      <url>/2023/03/25/tt/</url>
      
        <content type="html"><![CDATA[<h1 id="这是h1-标题"><a href="#这是h1-标题" class="headerlink" title="这是h1 标题"></a>这是h1 标题</h1><p>  Lorem ipsum dolor sit amet consectetur adipisicing elit. Incidunt aliquid soluta debitis, autem pariatur aut optio laboriosam nulla eius, nisi quibusdam praesentium dicta laudantium! Assumenda a dolor cum autem porro.</p><h1 id="这也是h1-标题"><a href="#这也是h1-标题" class="headerlink" title="这也是h1 标题"></a>这也是h1 标题</h1><p>  Lorem ipsum dolor sit amet consectetur adipisicing elit. Incidunt aliquid soluta debitis, autem pariatur aut optio laboriosam nulla eius, nisi quibusdam praesentium dicta laudantium! Assumenda a dolor cum autem porro.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br></pre></td></tr></table></figure><h2 id="h2-标题"><a href="#h2-标题" class="headerlink" title="h2 标题"></a>h2 标题</h2><p>22</p><h2 id="h2标题"><a href="#h2标题" class="headerlink" title="h2标题"></a>h2标题</h2><p>22</p><h1 id="h1标题"><a href="#h1标题" class="headerlink" title="h1标题"></a>h1标题</h1><p>11</p><h2 id="h2标题-1"><a href="#h2标题-1" class="headerlink" title="h2标题"></a>h2标题</h2><p>11</p>]]></content>
      
      
      <categories>
          
          <category> 测试分类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tt copy</title>
      <link href="/2023/03/25/tt%20copy/"/>
      <url>/2023/03/25/tt%20copy/</url>
      
        <content type="html"><![CDATA[<h1 id="这是h1-标题"><a href="#这是h1-标题" class="headerlink" title="这是h1 标题"></a>这是h1 标题</h1><p>  Lorem ipsum dolor sit amet consectetur adipisicing elit. Incidunt aliquid soluta debitis, autem pariatur aut optio laboriosam nulla eius, nisi quibusdam praesentium dicta laudantium! Assumenda a dolor cum autem porro.</p><h1 id="这也是h1-标题"><a href="#这也是h1-标题" class="headerlink" title="这也是h1 标题"></a>这也是h1 标题</h1><p>  Lorem ipsum dolor sit amet consectetur adipisicing elit. Incidunt aliquid soluta debitis, autem pariatur aut optio laboriosam nulla eius, nisi quibusdam praesentium dicta laudantium! Assumenda a dolor cum autem porro.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2022/08/25/test/"/>
      <url>/2022/08/25/test/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag>  test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo网站配置</title>
      <link href="/2022/03/16/hexo%E7%BD%91%E7%AB%99%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/03/16/hexo%E7%BD%91%E7%AB%99%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-安装gitbash"><a href="#1-安装gitbash" class="headerlink" title="1:安装gitbash"></a>1:安装gitbash</h1><h1 id="2-打开gitbash-设置user-name和email"><a href="#2-打开gitbash-设置user-name和email" class="headerlink" title="2: 打开gitbash 设置user.name和email"></a>2: 打开gitbash 设置user.name和email</h1><p>&#96;&#96;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;你的GitHub用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;你的GitHub注册邮箱&quot;</span></span><br></pre></td></tr></table></figure><h1 id="3-生成秘钥和github绑定"><a href="#3-生成秘钥和github绑定" class="headerlink" title="3: 生成秘钥和github绑定"></a>3: 生成秘钥和github绑定</h1><h1 id="4-安装node"><a href="#4-安装node" class="headerlink" title="4:安装node"></a>4:安装node</h1><h1 id="5-安装hexo"><a href="#5-安装hexo" class="headerlink" title="5: 安装hexo"></a>5: 安装hexo</h1><p>&#96;&#96;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli </span><br></pre></td></tr></table></figure><h1 id="6-然后新建一个新的空文件-进入到新建的空文件初始化"><a href="#6-然后新建一个新的空文件-进入到新建的空文件初始化" class="headerlink" title="6:然后新建一个新的空文件,进入到新建的空文件初始化"></a>6:然后新建一个新的空文件,进入到新建的空文件初始化</h1><p>&#96;&#96;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p>然后测试</p><p>&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo new test_my_site // 新建一篇文章</span><br><span class="line"></span><br><span class="line">hexo g  // hexo generate #生成</span><br><span class="line"></span><br><span class="line">hexo s // 打开本地服务器</span><br></pre></td></tr></table></figure><p>如果不出意外 服务器启动成功,显示访问端口: localhost: 4000</p><h1 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h1><p><a href="https://github.com/litten/hexo-theme-yilia">https://github.com/litten/hexo-theme-yilia</a></p><p>根据文档主题待定</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
