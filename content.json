{"meta":{"title":"chen","subtitle":"","description":"你是想说什么吗","author":"chen","url":"http://example.com","root":"/"},"pages":[{"title":"关于","date":"un66fin66","updated":"un66fin66","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"不要相信化妆和美颜的女孩子 年少的时候，我觉得孤单是很酷的一件事。长大以后，我觉得孤单是很凄凉的一件事。现在，我觉得孤单不是一件事。不合群是一回事，不将就又是另一回事。"},{"title":"所有分类","date":"un00fin00","updated":"un00fin00","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"un00fin00","updated":"un00fin00","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"这是分页标题","date":"un66fin66","updated":"un66fin66","comments":true,"path":"notes/tes/index.html","permalink":"http://example.com/notes/tes/index.html","excerpt":"","text":""},{"title":"这是分页标题","date":"un66fin66","updated":"un66fin66","comments":true,"path":"notes/项目笔记/index.html","permalink":"http://example.com/notes/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/index.html","excerpt":"","text":""}],"posts":[{"title":"Hexo主题代码复制","slug":"Hexo主题代码复制","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2023/12/03/Hexo主题代码复制/","link":"","permalink":"http://example.com/2023/12/03/Hexo%E4%B8%BB%E9%A2%98%E4%BB%A3%E7%A0%81%E5%A4%8D%E5%88%B6/","excerpt":"","text":"以前在hexo 配置的时候, 代码复制功能都是不存在的, 需要自己编辑, 但是现在随着hexo 的更新和更大的主题的进化, 基本都添加了这个代码复制的功能,. 尤其实在更新了主题后, 本身的代码代码插件和主题本身起了冲突, 强迫症简直不能忍. 现在关闭本身配置的代码复制, 保留主题的. 本身就是使用hexo 的注入器来完成, 然后代码的使用, 需要在博客目录下创建一个javscript 文件夹, 然后把代码复制进去, 文件名随意 把代码更新保存一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&quot;use strict&quot;;// code block copyhexo.extend.injector.register(&quot;body_end&quot;, function () &#123; return ` &lt;style&gt; .highlight &#123; position: relative; &#125; .highlight .code .copy-btn&#123; position: absolute; top: 0; right: 0; padding: 4px 0.5rem; opacity: 0.25; font-weight: 700; color: var(--theme); cursor: pointer; transination: opacity 0.3s; &#125; .highlight .code .copy-btn:hover&#123; color: var(--text-code); opacity: 0.75; &#125; .highlight .code .copy-btn.success &#123; color: var(--swiper-theme-color); opacity: 0.75; &#125; &lt;/style&gt; &lt;script&gt; const codeElementArr = document.querySelectorAll(&#x27;.code&#x27;) codeElementArr.forEach(code =&gt; &#123; const codeBeforeWidth = window.getComputedStyle(code, &#x27;::before&#x27;).width.split(&#x27;px&#x27;)[0] const codeBeforePadding = window.getComputedStyle(code, &#x27;::before&#x27;).padding.split(&#x27; &#x27;).pop().split(&#x27;px&#x27;)[0] // copy btn const codeCopyBtn = document.createElement(&#x27;div&#x27;) codeCopyBtn.classList.add(&#x27;copy-btn&#x27;) codeCopyBtn.style.right = Number(codeBeforeWidth) + Number(codeBeforePadding) * 2 + &#x27;px&#x27; codeCopyBtn.innerText = &#x27;复制代码&#x27; code.appendChild(codeCopyBtn) codeCopyBtn.addEventListener(&#x27;click&#x27;, async () =&gt; &#123; const currentCodeElement = code.children[0]?.innerText await copyCode(currentCodeElement) codeCopyBtn.innerText = &#x27;复制成功&#x27; codeCopyBtn.classList.add(&#x27;success&#x27;) setTimeout(() =&gt; &#123; codeCopyBtn.innerText = &#x27;复制代码&#x27; codeCopyBtn.classList.remove(&#x27;success&#x27;) &#125;,1000) &#125;) &#125;) async function copyCode(currentCode) &#123; console.log(currentCode) console.log(&#x27;复制代码&#x27;) if (navigator.clipboard) &#123; try &#123; await navigator.clipboard.writeText(currentCode) &#125; catch (error) &#123; // 未获得用户许可 console.error(error) &#125; &#125; else &#123; console.error(&#x27;当前浏览器不支持此api&#x27;) &#125; &#125; &lt;/script&gt; `;&#125;);","categories":[{"name":"-hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"web布局","slug":"web布局","date":"un44fin44","updated":"un55fin55","comments":true,"path":"2023/10/19/web布局/","link":"","permalink":"http://example.com/2023/10/19/web%E5%B8%83%E5%B1%80/","excerpt":"","text":"web布局最早期的互联网的页面是没有css布局的,仅仅以超文本语言来构建页面.这也导致html 本身的原始规范基本不具备能准确控制页面的布局能力. 早期的web 设计时代, web 页面上的信息元素都是按照正常的流排序来组织的, 它没有色块, 没有图形,只有文字. 表格布局互联网的发展是快速的, 在html2.0 之后, 新增了图片&lt;img&gt; 表单&lt;from&gt; 和表格&lt;table&gt; 后面用于展示数据的表格被用于web 的布局上, 且越来越受欢迎. 这个时候表格布局诞生了. 123456789&lt;table&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;顶部&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;左列&lt;/td&gt; &lt;td&gt;右列&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 虽然&lt;table&gt; 表格再布局上有着天生的不足, 但是它却改变了web 设计的历史, 因为这时候起诞生了web 布局这样一个概念. 然后再后来, 网景和微软发动了对html 的改革, 淘汰了展示用的html 标签, 这时候与html 结构分离的联级样式随之到来. 1996 年层叠样式表css 诞生, 允许了我们将WEB 页面结构HTML和样式信息CSS 分开. 样式规则可以保存至单独的文档 浮动布局","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"},{"name":"css","slug":"css","permalink":"http://example.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"Vue","slug":"vue","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2023/10/08/vue/","link":"","permalink":"http://example.com/2023/10/08/vue/","excerpt":"","text":"模板语法文本插值1&lt;span&gt;message &#123;&#123; msg &#125;&#125;&lt;/span&gt; 1234&lt;script setup&gt;import &#123; ref &#125; from &quot;vue&quot;;const msg = ref(&#x27;hello&#x27;)&lt;/script&gt; 双大括号中的标签会被替换为相应组件实例中msg 的值,同时每次更改msg 的值的时候, 它也会同步更新 原始HTML在vue 中双大括号会将数据解释为纯文本, 而不是html. 如果先插入html.则需要用到v-html指令 1const rawHtml = ref(`&lt;span style=&quot;color: red&quot;&gt;This should be red.&lt;/span&gt;`); 12&lt;p&gt;Using text interpolation: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;&lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt; 在没有使用 v-html 标签的时候, 双大括号中的rawhtml 不会被解析成html 内容, 而是以纯文本的方式展现, 在使用了v-html 的标签, 则会把双大括号中的rawhtml解析成html 标签渲染出来. Attribute 绑定1&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt; v-bind 指令可以将vue 的元素的id attribte 与组件的 id 属性保持一致, 如果绑定时的值是null 或者是undefined, 那么这个attribute 将会从渲染的元素移除 简写1&lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt; 布尔型Attribute布尔型的attribute 依据true 和false 来决定attribute 是否存在该元素上 动态绑定多个值123456const attributes = &#123; class = &#x27;box&#x27;, id = &#x27;content&#x27;&#125;&lt;div v-bind = &quot;attributes&quot;&gt; 这时候该元素就被同时被绑定上class, id 属性 指令Dirctives响应式ref()在vue3 组合式中推荐使用ref() 函数来声明响应式状态 1import &#123; ref &#125; from &quot;vue&quot;; 在ref() 接受参数的时候 , 包裹一个带有.value属性的ref 对象返回. 12345678910111213141516171819&lt;script&gt;import &#123; ref &#125; from &quot;vue&quot;;export default &#123; setup() &#123; const count = ref(0); function increment() &#123; count.value++; &#125; return &#123; count, increment, &#125;; &#125;,&#125;;&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt; &lt;script setup&gt;在上面的例子, 在setup 函数中暴露大量的状态和方法稍显繁琐, 但是,在v3 中可以使用单文件组件(sfc) 来避免这种情况, 1&lt;script setup&gt; 这时候只需要在顶层script 标签中添加一个 setup 1234567&lt;script setup&gt;import &#123; ref &#125; from &quot;vue&quot;;const count = ref(0)function increment()&#123; count.value+=&#125;&lt;/script&gt; 深层响应式ref 可以持有任何类型的值, 包括深层嵌套的对象, 数组或者javascript 内置的数据结构. ref 会使它的值具有深层响应性, 意味着即使改变嵌套对象或者数组时, 变化也会被检测到. DOM 更新时机当修改了响应式式状态时, dom 会自动更新, 但是需要注意的时, dom 的更新不是同步的, vue会咋爱next tick 更新周期中缓冲所有状态的修改, 以确保不管进行了多少次状态修改 , 每个组件都只会被更新一次. 12345import &#123;nextTick&#125; from &#x27;vue&#x27;async function increment()&#123; count.vaule++; awit nextTick()&#125; reactivereactive 和可以将内部的值包装在特殊对象中的ref 不同. reactive 可以使对象本身具有响应性. 1234import &#123; reactive &#125; from &#x27;vue&#x27;const state = reactive(&#123;count:0&#125;)&lt;button @click=&#x27;state.count++&#x27;&gt;&#123;&#123; state.count &#125;&#125;&lt;/button&gt; reactive 响应式对象是javascript 的代理, 其行为就和普通的对象一样, 不同的是vue 可以拦截对响应式对象所有属性的访问和修改, 方便进行依赖追踪和出发更新. Reactive Proxy vs. Originalreactive返回的是一个原始对象的Proxy . 它和原始对象是不相等的 123const raw = &#123;&#125;;const proxy = reactive(raw);console.log(proxy === raw); // false 也就是说在vue 中只有代理对象是响应式的, 更改原始对象的时候, 不会触发代理对象的更新,所以在使用reactive 响应式的时候在,最好是只使用声明对象的代理版本. 在对同一个原始对象使用reactive的时候总是会返回同样的代理对象, 而对一个已存在的代理对象调用reactive() 会返回本身 123456const raw = &#123;&#125;;const proxy = reactive(raw);// 在同一个对象上调用reactive() 会返回相同的代理reactive(raw) === proxy // true//在一个代理上调用reactive() 会返回自己reactive(proxy) === proxy // true reactive 局限性有限的值类型它只能用对象类型, 不能持有(string, number, boolean) 这样的原始类型 不能替换整个对象由于vue 的响应式式跟踪通过属性访问实现的, 所以在引用的时候必须始终保持对响应式对象的相同引用.如果更换了响应式对象, 那么与之前引用的响应性连接则会丢失. 123let state = reactive(&#123;count:0&#125;)// 上面的&#123;count: 0&#125; 引用不会在被跟踪, 响应性链接已经丢失state = reactive(&#123;count:1&#125;) 对解构不友好当响应式对象的原始类型结构为本地变量的时候, 或者将 该属性传递给函数的时候, 响应性连接也会丢失 123456789101112const state = reactive(&#123;count:0&#125;)// 解构式, count 会和state.count 断开连接let &#123;count&#125; = state// 但是不会原始的statecount++//当一个函数希望传递的参数式一个普通的数字的时候,希望它保持响应式// 但是如果只传递state的时候, callback(state)&#123;console.log(state) // undefined&#125;// 传递state 计算属性computed计算属性 的作用在于用来解构依赖复杂的数据显示. 计算属性computed 方法期望接收getter 函数, 返回值一个计算属性ref.该ref 和其他ref 一样. 也可以通过.value 访问计算结果 . 计算属性ref 也会在模板中自动解包. vue 的计算属性会自动追踪响应式依赖, 她会自动检测到依赖的数据, 当依赖的数据发生了改变, 依赖绑定的数据也会同时更新. vue 计算属性computed 是有缓存的. 也就意味着如果依赖的数据没有发生改变, 那么展现返回h的永远都是先前的计算结果, 不会重复执行getter函数 1234567891011121314151617&lt;script setup&gt;import &#123; reactive, computed &#125; from &quot;vue&quot;;const author = reactive(&#123; author: &quot;john&quot;, books: [&quot;v1&quot;, &quot;v2&quot;],&#125;);// computedconst publishedBooks = computed(() =&gt; &#123; return author.books.map((el) =&gt; &#123; return el; &#125;);&#125;);// 组件function fnBooks()&#123; return author.books.map((el)=&gt;&#123; el&#125;)&#125; 同样的逻辑在组件函数和在 计算属性中, 结果基本都是相同的, 不同的是, 组件函数会在重新渲染发生的时候,再次执行函数, 而计算属性属性是有缓存的, 如果在一个非常郝性能的列表的时候, 没有缓存的话每次渲染的时候都会重复计算,造成不必要的性能损耗, 而有了缓存再 没有数据发生变化的时候 ,就不用每次重新计算数据了. 可写计算属性计算属性默认是只读的, 在vue 中尝试修改一个计算属性的时候 , 会收到运行警告.只有在某些特殊场景中才会用到可写属性 , 这时候可以通过同时提供getter 和setter 来创建. 1234567891011121314151617&lt;script setup&gt;import &#123; ref, computed &#125; from &#x27;vue&#x27;const firstName = ref(&#x27;John&#x27;)const lastName = ref(&#x27;Doe&#x27;)const fullName = computed(&#123; // getter get() &#123; return firstName.value + &#x27; &#x27; + lastName.value &#125;, // setter set(newValue) &#123; // 注意：我们这里使用的是解构赋值语法 [firstName.value, lastName.value] = newValue.split(&#x27; &#x27;) &#125;&#125;) 注意:getter 应该子程序逻辑中只做计算不要有任何其他的副作用. 不要再getter 中做异步请求或者更改DOM 避免直接修改计算属性值vue 中计算属性返回的值是一个派生状态, 可以看成是一个零时快照, 每当原装态发生变化的时候, 就会创建一个新的快照, 所以更改快照是没有意义的, 因此计算属性的返回值应该被视为只读的, 并且永远不应该被给更改, 应该更新他所依赖的状态触发新的计算. Class 与Style 绑定再vue 中class 和style 都是属于Attribute . 所以同样的可以和其他的attribute 一样使用v-bind 将他们和动态的字符串绑定. 由于再处理复杂的绑定的时候, 通过拼接的字符串容易出错, 所以再vue中专门为class和style 的v-bind用法提供了特殊的功能和增强. 除了是字符串意外, 表达式的值还可以是对象或者是数组. 绑定Html Class12345678&lt;script setup&gt;import &#123; ref &#125; from &quot;vue&quot;;const isActive = ref(true);const hasError = ref(false);&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;static&quot; :class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;&gt;&lt;/div&gt;&lt;/template&gt; 再上面的代码中, 我们通过ref 定义了两个真假值, 来绑定到div 上, 再vue 中可以通过绑定的attribute 真假来决定该attribute 是否绑定到指定的元素上. 以这段代码的状态:配合上面的模板 12const isActive = ref(true);const hasError = ref(false); 再页面渲染出来的元素会是: 1&lt;div class = &#x27;static Active&#x27;&gt;&lt;/div&gt; 当isActive 和hasError 的真假值发生改变的时候,绑定是class 的列表也会更新 123const isActive = ref(false);const hasError = ref(true);&lt;div class = &#x27;static text-danger&#x27;&gt;&lt;/div&gt; 或者绑定成一个对象 12345678const classObject = reactive(&#123; active: true, hasError : false&#125;)&lt;template&gt;&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt;&lt;/template&gt; 1&lt;div class= &#x27;active&#x27;&gt;&lt;/div&gt; 或者绑定一个计算属性: 12345678910const isActive = ref(true)const error = ref(null)const classObject = computed(() =&gt; (&#123; active: isActive.value &amp;&amp; !error.value, &#x27;text-danger&#x27;: error.value &amp;&amp; error.value.type === &#x27;fatal&#x27;&#125;))&lt;template&gt;&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt; &lt;/template&gt; 上面的js代码通过计算属性, 返回一个对象有两个值, 一个active, 一个是text-danger,当active的值为true的时候, 且error.value的值为false 的时候, 那么就会绑定active到元素上, 当text-danger的值为true 或者他的值等于fatal的时候, 才会添加 在组件上使用条件渲染v-if该指令通常用来条件性的渲染某一部分内容, 该部分内容只有在指令表达式返回真值的时候,才会被渲染 1234567891011&lt;script setup&gt;import &#123; ref &#125; from &quot;vue&quot;;const show = ref(true);&lt;/script&gt;&lt;template&gt; &lt;h1 v-if=&quot;show&quot;&gt;hello&lt;/h1&gt; &lt;button @click=&quot;show = !show&quot;&gt;btn&lt;/button&gt; &lt;span v-if=&quot;show&quot;&gt;show&lt;/span&gt; &lt;span v-else&gt;no show&lt;/span&gt;&lt;/template&gt; 一个v-else 元素必须跟在一个v-if 或者v-if-else 的元素后面, 否则不会被识别 template 上的v-if因为v-if 是一个指令, 他必须依附在某个元素上,但是如果要切换的不值一个元素的时候, 这个时候可以在模板template 上使用v-if, 但是这是一个不见的包装器元素,最后渲染的结果并不会包含整个template 元素 1&lt;templat v-if=&quot;&quot;&gt;&lt;/template&gt; v-show和v-if 不同的是,在dom 渲染的时候会保留这个元素, v-show 仅切换了该元素上display的css 属性. v-show 不支持在template上使用,也不能和v-else 一起搭配使用 v-if 和v-showv-if 是按真实的条件渲染的, 它确保了在切换的时候, 条件区块内的事件监听器和子组件都会被销毁和重新构建, v-if 也是惰性的, 如果在初次渲染的时候, 条件值是false, 则不会做任何事, 只有当条件区块的首次变为true的时候才开始被渲染 v-show 则是无论初始条件如何, 始终都会被渲染,只有css 的display 属性在被切换. 总的来说,v-if 有更高的切换开销, v-show 有更高的初始渲染开销 v-if 和v-for在vue 中不推荐同时使用v-if 和v-for , 因为二者的优先级不明显 但是当v-if 和v-for 在同一元素的时候, v-if 是会被优先执行的 列表渲染-v-for使用v-for 指令基于一个数组来渲染一个列表. v-for指令的值使用item in items 棋手那个items 是原数组的数组, item 是迭代项的别名 123456789&lt;script setup&gt;import &#123; ref, toRef &#125; from &quot;vue&quot;;const _items = ref([&#123; message: &quot;foo&quot; &#125;, &#123; message: &quot;bar&quot; &#125;]);&lt;/script&gt;&lt;template&gt; &lt;ul v-for=&quot;(item, index) in _items&quot; :key=&quot;index&quot;&gt; &lt;li&gt;&#123;&#123; item.message &#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/template&gt; v-for对象在vue中, v-for 遍历的顺序会基于该对象调用的Object.keys()的返回值确定. 12345678910const myObject = reactive(&#123; title: &#x27;How to do lists in Vue&#x27;, author: &#x27;Jane Doe&#x27;, publishedAt: &#x27;2016-04-10&#x27;&#125;)&lt;ul&gt; &lt;li v-for=&quot;value in myObject&quot;&gt; &#123;&#123; value &#125;&#125; &lt;/li&gt;&lt;/ul&gt; v-for 遍历对象提供三个参数 1234value, key, indexvalue: 对应当前属性值key: 对应当前属性键index: 对应当前属性索引 123&lt;ul v-for=&quot;(index,key, value)&quot;&gt; &#123;&#123;index&#125;&#125;- &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;&lt;/ul&gt; 对应显示 1230: title: How to do lists in Vue 1: author: Jane Doe 2: publishedAt: &#x27;2016-04-10 v-for 里使用值范围v-for 可以接受一个整数值, 在这种模式中, 模板会基于1-n的取值范围重复 1&lt;span v-for=&quot;n in 10&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/span&gt; 112345678910 &lt;template&gt; 上的v-for可以在templat 标签上使用v-for 来渲染一个或者多个元素块 12345678910111213141516&lt;script setup&gt;import &#123; reactive &#125; from &quot;vue&quot;;const myObject = reactive(&#123; title: &quot;How to do lists in Vue&quot;, author: &quot;Jane Doe&quot;, publishedAt: &quot;2016-04-10&quot;,&#125;);&lt;/script&gt;&lt;template&gt; &lt;ul&gt; &lt;template v-for=&quot;item in myObject&quot;&gt; &lt;li&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt; &lt;/template&gt; &lt;/ul&gt;&lt;/template&gt; 在&lt;template&gt; 上挂载 v-for和在dom 元素上其实本质上没有太大的区别. v-for 和 v-if当他们都处于同一节点上的时候,v-if 的优先级比v-for 更高, 这也意味着, v-if 无法访问到v-for 作用域定义的变量别名 12345const todos = ref([ &#123; id: 1, title: &quot;one&quot; &#125;, &#123; id: 2, title: &quot;two&quot; &#125;, &#123; id: 3, title: &quot;three&quot; &#125;,]); 12345// Cannot read properties of undefined (reading &#x27;isComplete&#x27;)// 此时这段代码会报错无法读取isComplete 属性&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt; &#123;&#123; todo.name &#125;&#125;&lt;/li&gt; 改善, 使用template 挂载v-for 1234567&lt;template&gt; &lt;ul v-for=&quot;todo in todos&quot;&gt; &lt;template v-if=&quot;!todo.isComplete&quot;&gt; &#123;&#123; todo.id &#125;&#125; &lt;/template&gt; &lt;/ul&gt;&lt;/template&gt; key 管理状态在vue 中默认按照就地更新 的策略来更新通过v-for 渲染的元素 列表, 当数据项的顺序该表的时候, vue 也不会移动dom 元素的顺序, 而是就地更新每个元素, 确保他们在原本指定的索引位置上渲染. 这种模式在用于列表渲染输出的结果不依赖子组件状态或者零时DOM 的状态. 在大多数的时候, 我们需要给vue 一个节点的跟踪标识, 从而重用和重新排序现有的元素, 需要位每个元素提供一个唯一的‘key’ 123&lt;ul v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt; &#123;&#123; item &#125;&#125;&lt;/ul&gt; 如果v-for 是挂载在&lt;template&gt; 上, 那么这个key 也应该是被绑定在template 这个容器上 1&lt;template v-for=&quot;&quot; :key= &#x27;&#x27;&gt; 数组变化检测变更方法vue能够侦听响应数组的变更方法, 并在他们被调用的时候,触发更新. push() pop() shift() unshift() splice() sort() reverse() 事件处理在vue 中使用v-on 指令简写@来监听DOM 事件, 并在事件触发的时候执行对应的javascript 123v-on:click = &#x27;clickEvent&#x27;后者@click = &#x27;eventClick&#x27; 内联事件处理器 当事件被触发的时候执行内敛的javascript 方法事件处理器 一个指向组件上定义的方法的属性名或者是路径 内联事件处理器该处理器通常用于简单场景: 123456789&lt;script setup&gt;import &#123; ref &#125; from &quot;vue&quot;;const count = ref(0);&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;count++&quot;&gt;coun++&lt;/button&gt; &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;&lt;/template&gt; 事件方法处理器当事件处理器的逻辑变得复杂的时候, 内联代码的方式就会显得不够灵活, 这时候我们可以接收一个方法名或者一个方法的调用 1234567function greet(event) &#123; alert(`hello $&#123;name.value&#125;`); if (event) &#123; alert(event.target.tagName); &#125;&#125; &lt;button @click=&quot;greet&quot;&gt;greet&lt;/button&gt; 在上面代码中标注了一个greet 函数, 点击的时候,检查event 属性是否存在, 如果存在则获取的它的标签名. 事件处理器标注类型 方法与内联事件判断模板编译器会通过检查 v-on 的值是否是合法的 JavaScript 标识符或属性访问路径来断定是何种形式的事件处理器。举例来说，foo、foo.bar 和 foo[&#39;bar&#39;] 会被视为方法事件处理器，而 foo() 和 count++ 会被视为内联事件处理器。 在内联处理器中调用方法除了在元素上直接绑定方法名, 还可以在内联处理器中调用方法, 这种方式允许我们向方法中传入自定义参数,替换原生事件. 12345function say(message) &#123; document.write(message);&#125; &lt;button @click=&quot;say(&#x27;hello&#x27;)&quot;&gt;hello&lt;/button&gt; 在内联事件处理器中访问事件参数123456789&lt;!-- 使用特殊的 $event 变量 --&gt;&lt;button @click=&quot;warn(&#x27; 以阻止默认事件.&#x27;, $event)&quot;&gt; Submit&lt;/button&gt;&lt;!-- 使用内联箭头函数 --&gt;&lt;button @click=&quot;(event) =&gt; warn(&#x27;以阻止默认事件.&#x27;, event)&quot;&gt; Submit&lt;/button&gt; 事件修饰符在处理事件调用的时候, 使用event.preventDefault() 等是一个常用的操作, 但是在在vue 中可以更加专注于数据 逻辑, 而不用去触底DOM 事件的细节. 在vue中提供了v-on 事件修饰符.简写. , 包含以下. .stop 停止事件传递 .prevent 阻止事件默认行为,提交事件后, 不再重新加载页面 .self 只有event.target 是元素本身的时候, 才会触发事件处理器 .capture 和原生addeventListenner() 事件对应 开始捕获模式 表示内部的元素的事件, 在被内部元素处理前, 先被外部处理掉 .once 代表事件最多被触发一次 .passive 用于触摸事件的监听器, 用来改善移动端的滚屏性能 不允许同时使用.passive 和.prevent. .passive 本身已经向浏览器表明了你不想阻止事件的默认行为, 但是在使用.prevent 后又向浏览器表明了你要阻止事件的默认行为,则会造成冲突, 浏览器会发出警告, 且会忽略掉.prevent 事件修饰符顺序在调用修饰符的时候, 是由调用顺序的, 123@click.prevetn.self : 会阻止元素和子元素所有的默认行为@click.self.prevent : 则只会阻止元素事件本身的默认行为 按键修饰符在监听键盘事件时, vue允许在v-on 或者@ 监听案件事件的时候添加案件修饰符 123456&lt;template&gt; // 再按下enter 的时候调用kyes() 方法 &lt;input type=&quot;text&quot; @keyup.enter=&quot;keys()&quot; /&gt; // 使用暴露的案件作为修饰符, 咦keybab-case的形式 &lt;input type=&quot;text&quot; @keydown.page-down=&quot;pageDown&quot; /&gt;&lt;/template&gt; 按键别名 .enter .tab .delete .esc space up down .left .right 系统按键修饰符 .ctrl .alt .shift .meta 1234// alt + enter&lt;input @keyup.alt.enter&gt;// ctrl + 点击&lt;div @click.ctrl = &quot;btn&quot;&gt;&lt;div&gt; 表单输入绑定v-mdoel再处理表单的时候,我们需要将表单输入框的内容同步给javascript中响应的变量, 手动连接绑定的值和更改事件监听可能会稍显麻烦. v-model 可以简化着一个步骤: 123456789101112 &lt;script setup&gt;import &#123; ref &#125; from &quot;vue&quot;;let message = ref(&quot;初始值时&quot;);function mes(event) &#123; message.value = event.target.value; console.log();&#125;&lt;template&gt; &lt;p&gt;messg is &#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input type=&quot;text&quot; @input=&quot;mes&quot; :value=&quot;message&quot; /&gt;&lt;/template&gt; 使用v-model 1234&lt;template&gt; &lt;p&gt;messg is &#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot; /&gt;&lt;/template&gt; 在使用v-model 的时候, 她会自动根据使用的元素自动使用对应的dom属性和事件 文本类型的input 和textarea 元素会绑定 value property 并侦听input的事件 checkbox 和radio 会把安定checked, property 并侦听change事件 v-model 会忽略表单元素上的任何初始value, checked, selected 的attribute. 它将始终绑定javascript 的状态视为正确的数据来源. 如果需要绑定初始值, 应该使用响应式的api 来声明 复选框12345let checked = ref(&quot;true&quot;);&lt;template&gt; &lt;input type=&quot;checkbox&quot; id=&quot;checke&quot; v-model=&quot;checked&quot; /&gt; &lt;label for=&quot;checkbox&quot;&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt;&lt;/template&gt; 也可以将多个复选框绑定多一个数组或者集合","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"javascript重难点阅读","slug":"javascript重难点阅读","date":"un00fin00","updated":"un55fin55","comments":true,"path":"2023/10/08/javascript重难点阅读/","link":"","permalink":"http://example.com/2023/10/08/javascript%E9%87%8D%E9%9A%BE%E7%82%B9%E9%98%85%E8%AF%BB/","excerpt":"","text":"数据类型在javascript 中, 数据类型可以分为基本数据类型和引用数据类型. 基本数据类型包括: undefined null boolean number string symbol(es6新增) 引用数据类型包括: Object Function Array Date Undefined表示一个变量不存在, 或者声明了却没有赋值初始化. 声明了变量但是没有初始化的变量会返回undefined 12var a ;console.log(a) 获取一个对象的某个不存在的属性(自身属性和原型链属性)时, 会返回undefined 12345const obj = &#123; name: &#x27;name&#x27;&#125;obj.age; // undefined 函数没有明确返回值时, 但却在其他地方使用了返回值, 会发返回undeined, 这也是我们经常在控制台调试的时候, 在没有指定return 值的时候, 老是会有undefined的出现 12function foo()&#123;&#125;console.lof()foo()) 函数定义的时候使用了多个形式参数, 在调用传递的时候,参数的数量少于形参, 那么在没有匹配上的参数就位undefined, 在es6 中已经可以指定默认参数, 避免了这种情况发行 function foo(num1, num=2)&#123;&#125; 如果在传递形参的时候, 指定了默认参数, 那么就会使用 默认参数, 避免了undefined的发生 1234function foo(num1, mu2)&#123; console.log(num,num2)&#125;foo(1) Nullnull 类型只有一个唯一的字面值,null , 表示一个空指针对象, 所以在使用 typeof 检测null 值的时候也会返回一个 object 的原因. 如果生命的变量是为了以后保存某个值, 那么再声明的时候, 就会会赋值为null 123const obj = null;function foo()&#123;&#125;obj = foo javascript 中在获取dom 元素的时候, 如果没有获取到指定的元素对象, 也会返回null 1document.querySelector(&quot;#id&quot;) // null 使用正则表达式进行捕获的时候, 如果没有捕获结果, 就会返回null 1&#x27;test&#x27;.match(/a/) ; // null Null 和undefined 的异同 虽然null 和undefined 是两种不同的基本数据类型,虽然存在一些不同的特性, 但是某些表现上却也存在着相同之处. 相同点null 和undefined 两种数据类型都只有一个字面值, 分别是null 和undefined. null类和undefined 类在转换为boolea 类型的值时候, 都会转换为false. 123if (!undefined) &#123; console.log(1);&#125; 123if (!null) &#123; console.log(2);&#125; 在非严格相等的情况下, 两者是相等的 1null == undefined // true 不同点null 是javascript 中的关键字, 而undefined 是javascript 中的一个全局变量 在使用 typeof 运算检测的时候, undefined 类型的值会返回 undefined null 类型的会返回 object 12typeof undefined; // undefinedtypeof null; // object 通过call 调用 toString 函数的时候, undefined 类型的值会返回 [Object Undefined] 而 null 类型会返回 [Object Null] 12Object.prototype.toString.call(undefined) // [Object Undefined]Object.prototype.toString.call(null) // [Object NuLl] 在需要进行字符串转换的时候, null 会换转为字符串 null 而 undefined 会转换为字符串 undefined 12undefined + &quot;string&quot; // undefined stringnull + &quot;string&quot; // null string 在需要进行数值类型得转换 的时候, undefined 会转换为 nan 无法参与计算, null 会转换为0, 可以参与计算 12undefined + 0 ; // nannull+ 0 ; // 0 BooleanBoolean 又称为布尔类型, 字面值只有两个, 分别是 true 和 false, 他们是区分大小写, 例如True 和 False 并不是 boolean 类型. String 类型转换Boolean 类型 空字符串都转换为false 任何非空字符串都会转换为true, 包括空格字符串 number 类型 0 和nan 会转换为false 除了 0 和nan 都会转换为true, 包括无穷大和无穷小的 infinity 和 -infinity Object类型 当object 为null 的时候, 会转换为false 如果object不为null , 则都会转换为true, 包括空对象{} Function 类型任何Function 类型的值都会转换为true Null 类型Null 类型只有一个null 值, 会转换为false Undefined 类型 undefined 类型只有一个undefined , 会转换为false Number类型在javascript 中number 类型包括了整数类型, 也包括了浮点类型数据. Number 类型转换javascript 中基本是按照十进制数据类行转换. boolean 类型转换number true 转换wi1 false 转换为0 12Number(true) // 1Number(false) // 0 Null 类型转换 null 类型值只有一个字面值null, 直接转换为0 1Number(null) // 0 Undefined 转换 undefined 只有一个字面值undefined, 直接转换为nan String 类型转换 如果字符串中值包含数字, 则会转换成十进制数, 如果前面有0, 则会直接省略掉,例如 0123 , 直接转换为 123 如果字符串串中包含有效的十六进制格式的数据, 则会按照十进制转换 如果是空字符串, 则转换为 0 除了上面的格式, 其他的则会直接转换为 NaN Object 类型转换 Object 类型转在转换为Number 类型的时候, 会优先调用 valueof 函数, 燃烧后通过 valueof&#39; 函数的方绘制值,按照规则转换,如果转换的结果是 nan 则调用 toString 函数, 通过 toString 函数的返回值重新按照指定规则进行转换 &#96;&#96;&#96;javascriptconst obj &#x3D; { age: 21, valueOf: function () {return []; }, toString: function () {return this.age; },};console.log(Number(obj));1234567#### Number 方法##### parseInt()用于解析一个字符串, 并返回指定的基数对应的整数值 parseInt(string, radix) 12345678910111213141516171819&gt; string : 表示要被解析的值, 如果该参数不是一个字符串, 那么会调用 `toString` 函数转换成字符串&gt;&gt; radix: 表示进制转换的基数, 基数范围是2-36, 默认 为10 进制.&gt;&gt; 如果传入的字符串无法转换成 `number` 类型, 则会返回 `nan`###### map () 函数和parseInt() 函数的隐性坑在一个场景, 如果存在一个数组, 数组中的每个元素, 都是 `number`类型的字符串 `[“1”, ‘“2”, “3”]` 这时候如果将数组中的元素都转换为整数.```javascriptvar arr = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;];var result = arr.map(parseInt);console.log(result);// 预期结果是 [1,2,3,4]// 实际结果是: [1, nan] Array.prototype.map 在mdn 的定义是一个迭代方法, 它为数组中的每一个元素调用一次提供的 callback , 并用结果返回一个新数组 1map(callback, thisArray) map 的callback 接受三个参数, element: 数组当前正在处理的元素 index: 当前正在处理的元素数组索引 array: 调用了map 的数组本身 也就是类似于在使用map 的时候代码类似这样 123arr.map(function(el, index, array)&#123; return parseInt (el, index)&#125;) map 每次调用调用处理的数组元素的index 下标是在变化的.在处理到时候大概如下 1234parseInt(&#x27;1&#x27;, 0); // 1 任何整数以0 为基数取数的时候, 都会返回数值本身parseInt(&#x27;2&#x27;, 1); // NaN 基数只能是2-36parseInt(&#x27;3&#x27;, 2); // NaN 二进制数只有0,和1, 3超过了进制范围parseInt(&#x27;4&#x27;, 3); // NaN 4 无法使用3 进制表示 解决办法就是, 在每次使用 parseInt 的时候尽量指定基数, 不要将 parseInt 作为 map 的参数,而是在 map 的回调函数中使用 12const arr = []let res = arr.map((el)=&gt;&#123; return parseInt(10)&#125;) parseFloat()该方法用于解析一个字符串, 返回对应的符数点 , 如果给定的值不能转为数值, 则返回 nan. 在解析的过程中如果遇到了正负号, 数字0-9 , 小数点或者科学计数法以外的字符, 则会忽略该字符开始至结束的所有字符, 然后返回当前已经接卸的字符的浮点数形式 12345parseFloat(&#x27;+1.2&#x27;); // 1.2parseFloat(&#x27;-1.2&#x27;); // -1.2parseFloat(&#x27;++1.2&#x27;); // NaN，符号不能连续出现parseFloat(&#x27;--1.2&#x27;); // NaN，符号不能连续出现parseFloat(&#x27;1+1.2&#x27;); // 1，&#x27;+&#x27;出现在第二位，不会当作符号位处理 字符前面的空白会直接忽略, 如果无法解析, 则直接返回 nan 12parseFloat(&quot; 1.2&quot;) // 1.2parseFloat(&quot;f1.2&quot;) // nan 对于字符中出现的合法科学运算符, 在金蒜运算处理后会转换成浮点数 12parseFloat(&quot;4e3&quot;) // 400parseInt(&quot;4e3, 10&quot;) // 10 parseFloat: 在处理4e3 的时候 , 会先进行科学计数法的运算, 然后再转换为浮点数 parseInt : 在处理4e3 的时候, 则直接从字符串4 开始按进制基数10 转换, 然后返回整数4 对于小数点, 只能正确匹配第一个, 第二个小数点是无效的, 后面的字符也将被忽略 12parseFloat(&#x27;11.20&#x27;); // 11.2parseFloat(&#x27;11.2.1&#x27;); // 11.2 isNaN 与 Number.isNaN在number 数据类型中, 存在一个特殊的数值 nan 即not a number, 表示应该返回设置却没有返回数值. 在javascript 中nan 有两个明显的特点: 任何涉及nan 的操作都会返回nan nan 与任何值都不相等, 即使是与 nan 本身相比 在判断 nan 的时候, es5 提供了 isNaN 函数, 在es6 的时候, 又为number 类型添加了静态函数 isNaN isNaN () 函数用来确定一个变量是不是 NaN . NaN 是一个number 类型的数值, 只不过这个数值无法用真实的数字表示. 在传递参数的时候, 如果是number 类型的数据, 可以很容易判断是不是 NaN 但是在传递的参数是非number 类型的时候, 谈返回的结果往往让人费解. 1isNaN(&#123;&#125;) // true 空对象明明不是一个nan 数据, 应该返回的false, 但是却返回了true. 首先 nan 产生的条件是在数据运算的时候, 返回了一个无法表示的数值,如 1console.log(0/0) // nan 除了0&#x2F;0 , 其他数据除以0 都会返回Infinity 又或者在做强制数据类型转换的时候, 某些数据不能直接转换为数值类型, 也会返回 nan如 11- &quot;a &quot; // nan 而 isNaN() 函数也会进行数据类型的转换, 它在处理的时候会去判断传入的变量值是否能转换为数字, 如果能转换为数字, 则会返回false, 如果无法转换则会返回true. 所以在 isNaN(&#123;&#125;) 返回true 的时候, 首先会对 &#123;&#125; 进行类型转换, 但是 &#123;&#125; 是一个字面量无法转换成数字,自然判断 true 12345678910111213isNaN(NaN); // trueisNaN(undeﬁned); // trueisNaN(&#123;&#125;); // trueisNaN(true); // false，Number(true)会转换成数字1isNaN(null); // false，Number(null)会转换成数字0isNaN(1); // falseisNaN(&#x27;&#x27;); // false，Number(&#x27;&#x27;)会转换为成数字0isNaN(&quot;1&quot;); // false，字符串&quot;1&quot;可以转换成数字1isNaN(&quot;JavaScript&quot;); // true，字符串&quot;JavaScript&quot;无法转换成数字// Date类型isNaN(new Date()); // falseisNaN(new Date().toString()); // true 关于 new Date() 函数生成的实例在转换为数值类型的时候 , 都会转换为对应的世界戳, 但是在调用 toString 函数的时候, 返回的是一串字符串表示的时间, 无法转化成数值类型, 123const date = new Date();console.log( date); // 生成的是数字时间戳console.log(date.toString()); // 调用了toString()后返回的是字符串表示的时间戳 Number.isNaN()在全局环境中已经有了isNaN() 函数, 在es 6 为什么还要增加一个 Number.isNaN() 函数呢,. 那是因为全局中的 isNaN 会在传入的类型做类型转换, 而 Number.isNaN 不会去做类型转换,你传入的是什么就是什么, 同样的代码在es5 isNaN 和es6 的 Number.isNaN 的区别 12isNaN(&#123;&#125;) // trueNumber.isNaN(&#123;&#125;) // false 123456Number.isNaN(NaN); // trueNumber.isNaN(undeﬁned); // falseNumber.isNaN(null); // falseNumber.isNaN(true); // falseNumber.isNaN(&#x27;&#x27;); // falseNumber.isNaN(123); // false 兼容性如果在非es6 的环境中 需要用用到 Number.isNan 函数呢, 123456789function myIsNaN() &#123; // 判断环境中是否存在Number.isNaN if (!Number.isNaN) &#123; // 如果环境中并不存在 , 那么创建一个函数 Number.isNaN = function(n)&#123; return n !== n; &#125; &#125;&#125; 在所有类型的数据中, 如果一个变量和自身做比较, 只有变量值在为NaN的时候 , 才会返回false , 其他时候都是返回true, 浮点型运算在javascript 中整数和浮点数都是属于Number 类型, 都统一采用64 位浮点数来进行存储.虽村存储数据的方式是一致,但是在进行浮点数运算的时候, 结果有时候却会有差异. 12345678910111213141516// 加法0.1 + 0.2 = 0.300000000000000040.7 + 0.1 = 0.7999999999999999// 减法1.5 - 1.2 = 0.300000000000000040.3 - 0.2 = 0.09999999999999998// 乘法0.7 * 180 = 125.999999999999999.7 * 100 = 969.9999999999999// 除法0.3 / 0.1 = 2.99999999999999960.69 / 10 = 0.06899999999999999 经典问题来了 0.1+0.2 不等于0.3 这是因为在JavaScript 是因为双精度浮点数来表示数字, 而双精度浮点数又存在精度问题, 在双精度浮点数中使用有限的二进制位数来表示实数,在有些情况系会出现舍入误差,而0.1, 0.2 在转换为二进制数的时候会产生无循环的小数, 所以在进行计算的时候会存在一些误差. 一个浮点数在计算机中长度为64位, 其中最高位为符号位, 接下来的11 位为 指数位, 最后的52 位为小数位, 即有效数字的部分. 因为使用64为存储, 除去 最高位0 位, 和11 位指数位, 接下来最多也就能存储52位的小数位, 对于一些无限循环的小数位浮点数, 也只会截取到钱52位,这也就是为什么前面说的会小出现舍入误差. 既然知道了为什么会出现这个问题, 那么我们来看看这个结果是这么在计算出来的. 首先在计算的过程中, 会将各个小数位按照乘 2 取整. 顺序排列的方法转换成2进制表示,具体做法, 就是用 2 乘以十进制小数得到积, 将积的部整数部分取出, 然后再用2 乘以余下的小数部分, 又得到一个积, 再将积的整数部分取出, 如此反复, 知道将积的小数部分为0 为止. 这时候把取出的整数部分按照顺序排列起来, 先取出的整数作为二进制小数的高位有效位, 后取的整数作作为地位有效位. 这时候来看看0.1 转换成二进制的过程 后面就是0.00011, 0011,0011, 如此反复 然后还要对0.2 开始二进制转换, 计算过程和上面差不多, 只不过是从0.2开始少了第一位的0 然后也是0.0011, 0011 不断反复. 这时候0.1 和0.2 开始相加, 转换成52 位精度的浮点型表示: 123 0.0001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 (0.1)+ 0.0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 (0.2)= 0.0100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 得到的结果就转换成十进制的值就是0.30000000000000004 String 类型javascript中的String 类型 可以 通过 “” 也可以通过 ‘’ 来表示, 这和java 其他语言必须是 “” 是不同的. 在处理其他类型转换为String 的时候, 如果是引用数据恶灵, 在转换的时候会调用 toString 函数, 得到不同是类型值的字符串, 如果是基本数据类型, 则会直接将字面值转换为字符串表示. 例如 null 和 undefined 转换为字符串的时候， 就会直接返回字面量的值， null 和 undefined . 在将某写数据转换为字符串的时候, 最简单的方法就是使用 + 号拼接一个 空字符串 ‘ ’ 123console.log(123 + &#x27;&#x27;); // &#x27;123&#x27;console.log([1, 2, 3] + &#x27;&#x27;); // &#x27;1,2,3&#x27;console.log(true + &#x27;&#x27;); // &#x27;true&#x27; String 定义在javscirpt 中虽然单引号`‘’` 和双引号 `“”` 都可以定义字符串, 但是不能在定义一个字符串的时候, 出现一个单引号, 和一个双引号. 123let str = &quot;hello&quot; // oklet str2 = &#x27;hello&#x27; // oklet str3 = &#x27;hello&quot; // 错位 直接调用String 函数在直接使用String 函数的时候, 会将任何类型的值转换为字符串, 如果是Number 类型的值, 则直接转换成对应的字符串 1String(123) // &quot;123&quot; 如果是Boolean 类型的值, 则会直接转换成‘true’ 或者‘false’ 123String(true) // &#x27;true&#x27;String(false) // &#x27;false&#x27;// 这时候如果直接传入Boolea呢? 会得到什么. String(Boolean) 这时候输出的字符串表示的函数源代码. 因为传递的&#96;&#96;Boolean&#96; 是一个函数本身, 而不是一个布尔值. 所以这时候输出的是 function Boolean() &#123; [native code] &#125; 如果值为null , 则返回字符串‘null’ 1String(null) // &#x27;null&#x27; 如果值为字符串, 则直接返回字符串本身 1String(&quot;hello&quot;) // &quot;hello&quot; 如果值是引用类型, 则会优先调用toString() 函数获取返回值, 然后按照上面的转换规则, 判断是否能准换成相应的字符串类型, 如果都不满足, 则会调用对对象的 valueOf() 函数获取返回值, 重新按照上面的步骤转换成对应的字符串类型, 如果都不满足, 则会抛出类型转换异常. 1234567const obj = &#123; age: 21, toString: function () &#123; return `$&#123;this.age&#125;`; &#125;,&#125;;console.log(String(obj)); // 21 这时候来通过valueOf() 函数来转换 12345678910const obj = &#123; age: 21, // toString: function () &#123; // return `$&#123;this.age&#125;`; // &#125;, valueOf: function () &#123; return this.age; &#125;,&#125;;console.log(String(obj)); 如果 valueOf 和 toString 都无法转换成原生类型的话, 那么则会抛出类型转换的异常 12345678910const obj = &#123; age: 21, valueOf: function()&#123; return [] &#125;, toString: function()&#123; return [] &#125;&#125;String(obj) // 抛出异常TypeError newString 定义new String() 函数使用 new 运算符号生成一个String 类型的实例, 传入的参数和String() 函数一样类型的转换策略 12let str = new String(&quot;hello&quot;);str // &quot;[string hello]&quot; 不同定义方方式的String 区别使用字符串字面量和直接调用String() 函数的方式得到的字符串都是基本字符串, 但是通过 new String() 函数生成的字符串是字符对象. 在基本字符串做比较的时候, 只要比较字符串的值就可以了. 但是在比较字符串对象的时候, 比较的是对象所在的地址. 12345678let str = &quot;hello&quot;; //let str2 = String(&quot;hello&quot;);let str3 = new String(&quot;hello&quot;);let str4 = new String(&quot;hello&quot;);let str5 = str4;console.log(str === str2); // true 因为是两个基本字符串, 只要比较值就好了console.log(str3 === str4); // false, 因为new String 函数生成的, 所以比较的两个字符串对象的地址, 虽然值都是一样, 但是是两个不同的new 出来的实例对象, 所以引用的对象地址是不一样的,console.log(str4 === str5); // str5 是str4 的引用, 这也意味着他们引用的同一个对象地址, 函数的调用在String 对象的原型链上有着一系列的函数, 但是在没用使用 new String 生成的基本字符串也可以调用原型链上的函数. 实际上基本字符串本身没有办法调用字符串对象的函数的,但是在基本字符串在调用字符串对象的函数的时候, 是因为JavaScript 会自动将基本字符串转换为对象字符串, 形成以一种包装类型, 这样基本字符串就可以正常调用字符串对象的方法了 String类型常见用法字符逆向输出给定一个字符串’abcdefg’，执行一定的算法后，输出的结果为’gfedcba’。 方法1首先使用 split() 将字符串转换成数组, 使用数组的 reverse 方法,将字符串进行逆行排序, 再使用 join() 函数生成字符串 123function reverseString(str)&#123; return str.split(&quot;&quot;).reverse().join(&quot;&quot;)&#125; 方法2使用循环遍历出字符串, 然后在使用 chatAt() 返回对应索引字符串的字符, 然后再拼接. 1234567funciton reverseString(str)&#123; let res= &#x27;&#x27;; for(let i = str.length-1; i &gt;=0; i--)&#123; res += str.charAt(i) &#125; return res;&#125; 方法3递归逆向输出, 从字符出最后一个索引位置开始递归, 然后通过 charAt() 获取字符,拼接 123456789function reverseString(strlegnth,pos,strOut)&#123; if(pos &lt; 0)&#123; return strout; &#125; strout += strlen.charAt(pos--) return reverseString(strlen,pos, strout)&#125;let res = &quot;&quot;reverseStrng(str, str.length, res) 方法4使用 slice() 方法, 截取字符串返回一个新的数组, 然后在调用 Array.reverse() 让新生成的数组逆向输出, 在使用 join转换成逆向的字符串 1234function reverse4(str)&#123; let strArr = Array.prototype.slice.call(str) return strArr.reverse().join(&quot;&quot;)&#125; 方法5使用栈结构,利用栈结构先进后出的原则, 先通过一个数组, 进行数据存储, 然后使用一个变量记录栈顶的位置, 然后出栈时, 返回张栈顶的元素, 即数组中索引值最大的元素, 然后栈顶变量-1, 入栈时往栈顶追加元素, 然后栈顶变量+1 1234567891011121314151617181920212223242526272829303132333435363738function Stack()&#123; // 存储数据 this.strData = []; // 记录栈顶位置 this.top = 0&#125;// 再原型上增加出入栈Stack.prototype = &#123; // 入栈 push: function push(el)&#123; this.strData[this.top++]= el &#125;, // 出栈 pop: function pop()&#123; return this.strData[--this.top] &#125;, // 返回栈内的元素个数 length: function()&#123; return this.top &#125;&#125;//function reverse6(str)&#123; // 创建栈的实例 const stack = new Stack() // 将字符串转换成数组 let strArr = str.split(&#x27;&#x27;), len = strArr.length, res = &quot;&quot; for (let i = 0; i &lt; len; i++)&#123; stack.push(strArr[i]) &#125; // 输出栈内的元素 for (let j = 0; j &lt; len; j++)&#123; res += stack.pop(strArr[j]) &#125; return res;&#125; 统计字符串中出现次数最多的字符,以及次数假如存在一个字符串’helloJavascripthellohtmlhellocss’，其中出现次数最多的字符是l，出现的次数是7次 方法1通过 key value 的形式来存储字符串以及出现的次数, 然后再一个个判断.首先创建一个空对象, 遍历传递进来的字符串,使用&#96;&#96;charAt()&#96; 查找unicode 来判断这个对象中是否存在这个key, 如果不存在, 那么当前的字符为key, value: 1.(因为不存在只出现了一次), 如果出现过则value加一次. 12345678910111213141516171819202122232425function getMaxStringOrdinal(str)&#123; const json= &#123;&#125; // 遍历字符串 for (let i = 0; i &lt; str.length; i++)&#123; // 如果不存在则创建key value if(!json[str.charAt(i)])&#123; json[str.charAt(i)] = 1 &#125;else&#123; // 如果存在则 value ++ json[str.charAt(i)]++ &#125; &#125; console.log(json); let maxCountChar = &quot;&quot;; let maxCount = 0; for(let key in json)&#123; if(json[key] &gt; maxCount)&#123; maxCount = json[key] maxCountChar = key &#125; &#125; return `出现次数最多的值是: $&#123;maxCountChar&#125; , 出现次数为: $&#123;maxCount&#125;`&#125;let str = &quot;hello&quot;console.log(getMaxStringOrdinal(str)); 方法2同样使用都使用key,value. 来存储数据, key 表示不重复出现的字符,value表示字符出现的次数. 1: 先将字符串处理成数组, 然后通过 foreach 遍历每个字符,判断当前处理的字符是否已经存在 key-value对象中, 如果已经存在则表示已经处理过相同的字符无须在处理, 如果不存在则处理传入的item 通过split() 函数传入待处理的字符, 得到一个数组, 该数组长度-1即为该字符出现的次数 获取到字符出现的次数后, 和表示出现最大次数maxCount 和最大次数对应的字符串变量maxCountChar 相比,如果比maxCount 大则写入key-value 对象中, 并更新maxCount和maxCountChar的值, 1234567891011121314151617181920function getMaxCount(str)&#123; const json = &#123;&#125;; let maxCount =0, maxCountChar = &#x27;&#x27;; str.split(&#x27;&#x27;).forEach(function(item)&#123; // 判断json 对象中是否有对应的key if(!json.hasOwnProperty(item))&#123; let number = str.split(item).length -1; // 直接与出现次数最大的值比较 if(number &gt; maxCount)&#123; json[item] = number; maxCount = number maxCountChar = item &#125; &#125; &#125;) return `出现次数最多的值是: $&#123;maxCountChar&#125; , 出现次数是:$&#123;maxCount&#125;`&#125;let str = &quot;hello&quot;console.log(getMaxCount(str)); 方法3 该方法主要通过对字符串进行排序, 然后通过lastIndexOf() 函数获取索引值后, 判断该索引值的大小以获取出现的最大次数 1234567891011121314151617181920function getMaxCount(str) &#123; let maxCount = 0, maxCountChar = &quot;&quot;; str.split(&quot;&quot;).sort().join(&quot;&quot;); for (let i = 0, j = str.length; i &lt; j; i++) &#123; let char = str[i]; //记录每个字符串出现的次数 let charCount = str.lastIndexOf(char) - i + 1; // 与次数最大值比较 if (charCount &gt; maxCount) &#123; maxCount = charCount; maxCountChar = char; &#125; // 变更索引为字符串出现的最后位置 i = str.lastIndexOf(char); &#125; return ` 出现次数最多的值是: $&#123;maxCountChar&#125;, 出现次数是: $&#123;maxCount&#125;`;&#125;let str = &quot;hello&quot;;console.log(getMaxCount(str)); 去除字符串中的重复字符串方法1还是使用key-value 类型的对象存储, key 表示唯一字符, 处理完成后, 将所有的key 拼接到一起通过key-value 形式的对象来存储数据, key 表示不重复的字符串,value表示boolean类型的值, 为true 则表示字符串出现过. 然后遍历字符串,判断当前处理的字符串是否存在对象中, 如果存在则不处理, 如果不存在则添加到数组中. 12345678910111213141516171819function removeDuplicateChar(str) &#123; // 结果数组 const result = []; // 存储对象 const json = &#123;&#125;; // 循环字符 for (let i = 0; i &lt; str.length; i++) &#123; // 处理当前的字符 let char = str[i]; // 如果不存在 if (!json[char]) &#123; json[char] = true; result.push(char); &#125; &#125; return result.join(&quot;&quot;);&#125;let str = &quot;hello&quot;;console.log(removeDuplicateChar(str)); 方法2该方法借助数组的fillter() 函数, 然后在该函数中使用indexOf() 函数判断. 使用call 函数改变this 让str字符串可以使用Array 数组方法. 然后再定义fillter() 函数中, 通过indexOf函数判断第一次出现索引的位置, 如果和fillter() 函数的index 一样, 则表示第一次出现, 符合条件的就rerun 出去, 而其他重复的字符串则被忽略掉. 1234567function removeDuplicateChar2(str) &#123; let result = Array.prototype.filter.call(str, function (char, index, arr) &#123; return arr.indexOf(char) === index; &#125;); return result.join(&quot;&quot;);&#125;console.log(removeDuplicateChar2(str)); 方法3该方法借助es6的set 数据结构, 再set数据结构中set 具有自动去重的特性, 可以直接将元素去重 将字符串转成数组作为形参, 传入进入生成的set实例中 然后通过...展开运算符号, 直接生成数组, 然后转换成字符串 1234function removeDuplicateChar3(str) &#123; let set = new Set(str.split(&quot;&quot;)); return [...set].join(&quot;&quot;);&#125; 判断一个字符串是否是回文字符串回文字符串是指一个字符串的正序和倒序 是相同的, 如adcdcba 就是一个回文字符串, 该方法不区分大小写. 方法1该方法主要是将字符串从前往后顺序的字符串按从后往前的顺序的字符逐个比较, 遇到不一样的直接返回false, 否则返回true 1234567891011121314151617181920212223function isPalindrom1(str) &#123; // 如果是空字符串, 返回true if (!str.length) &#123; return true; &#125; //将字符同意转成小写, 并转换成数组 str = str.toLowerCase().split(&quot;&quot;); let strStart = 0, strEnd = str.length - 1; while (strStart &lt; strEnd) &#123; // 如果相等责则更改正序和倒叙的字母 if (str[strStart] === str[strEnd]) &#123; strStart++; strEnd--; &#125; else &#123; return false; &#125; &#125; return true;&#125;let str = &quot;abcba&quot;;console.log(isPalindrom1(str)); 引用数据引用类型的数据,和基本数据类型不同的是, 引用类型数据是具有属性和函数的镀锡那个. javascript 常用的引用数据类型包括Object ,Array,Date,RegExp,Math,Function以及基本数据类型的包装类型Number, String, Boolean. 引用数据类型的实例需要通过new 实例来生成, 有的是实例覅用, 有的是隐式调用 引用数据类型的值是可变的, 基本数据类型的值是不可变的 引用数据类型比较的是对象的内存地址 而基本数据类型是值的比较. Object 类型 object类型是javascript 中类型中最常用的一种类型, 但是object 类型的操作有何new 操作符号息息相关. new操作符在javascript 中new 操作符在执行过程中会改变this 的指向, function Person(name, age) &#123; this.name = name; this.age = age; &#125; console.log(new Person(&quot;names&quot;, 19)); 上面的代码输出结果包含了name 和age 信息, 但是我们在Person 函数中并未通过return 返返回任何值, 这是为什么呢?看下面代码 function Person(name, age) &#123; console.log(this); this.name = name; this.age = age; &#125; new Person(&quot;name&quot;, 19); 在浏览器控制台中我们可以看到, Perosn 的this 打印了自己本身的空的对象, 后面的两句就存粹是给Person 对象添加的属性. 其实在javascript 中, 如果一个函数没有返回值, 那么默认则return this,但是和又为什么和new 操作符又影响呢~ function Person(name, age) &#123; console.log(this); this.name = name; this.age = age; &#125; const person = new Person(&quot;name&quot;, 19); 首先new 一个对象的实例的时候, 首先会创建一个新的空对象 然后将新对象的__proto__ 属性指向原对象的prototype, 建立新对象和原对之间的链接关系. 然后执行原对象的构造函数, 并将新对象的上下作为上下文对象(this)传递给构造函数 , 在构造函数内部给新对象添加属性 再隐式的返回新对象 Object 类型实例函数实例函数是指函数的调用时基于Object 类型的是实例的 const obj = new Object() hasOwnProperty这个函数的作用是判断该对象自身是否拥有指定名称的实例属性, 但是不会检查实例对象原型链上方的属性 const o = new Object(); o.name = &quot;oname&quot;; console.log(o.hasOwnProperty(&quot;name&quot;)); // true console.log(o.hasOwnProperty(&quot;toString&quot;)); // false const Student = function (name) &#123; this.name = name; &#125;; // 给student 的原型添加一个函数 Student.prototype.sayHi = function () &#123; console.log(&quot;sayhi&quot;, this.name); &#125;; // 初始化函数 const stu = new Student(&quot;namea&quot;); stu.sayHi(); console.log(stu.hasOwnProperty(&quot;name&quot;)); // true console.log(stu.hasOwnProperty(&quot;sayHi&quot;)); // false propertyIsEnumerable该函数用来判断指定名称的属性是否是实例属性并且是否可以枚举的, 如果 是原型上的属性或者不可枚举的属性返回false const arr = [1, 2, 3]; arr.name = &quot;Array&quot;; console.log(arr.propertyIsEnumerable(&quot;1&quot;)); //true 实例属性 console.log(arr.propertyIsEnumerable(&quot;length&quot;)); // false 属性继承字Array console.log(arr.propertyIsEnumerable(&quot;toString&quot;)); // false 属性继承字Object 自定义对象 const Perosn = function (name, age) &#123; this.name = name; this.age = age; &#125;; Perosn.prototype.address = &quot;shanghai&quot;; Perosn.prototype.say = function () &#123; console.log(&quot;sayhi&quot;); &#125;; const person = new Perosn(&quot;namas&quot;, 19); console.log(person.propertyIsEnumerable(&quot;name&quot;)); // true 实例对象自身属性 console.log(person.propertyIsEnumerable(&quot;address&quot;)); // false 实例对象原型属性 console.log(person.propertyIsEnumerable(&quot;say&quot;)); // false 实例对象原型函数 // 设置name 属性不可枚举 Object.defineProperties(person, &#123; name: &#123; enumerable: false, &#125;, &#125;); console.log(person.propertyIsEnumerable(&quot;name&quot;)); // false Object静态函数静态函数指的是方法的调用是基于Object类型自身, 不需要通过Object类型的实例 Obejct.create()该函数的主要作用是创建并返回一个指定原型和指定属性的对象. Object.create(proto, propertiesObject) proto为新创建对象的原型对象 propertyObject如果传入的属性为null, 则对象的原型为undefined如果该参数被指定且不为undefined, 则传入该对象可枚举的的自有属性为新创建对象的对应属性名称和描述符.属性的的描述符号对应Object.definePropertyes()的的第二个参数 创建对象 const obj = Object.create(null, &#123; name: &#123; value: &#39;names&#39;, writable: true, enumerable: true, configurable: true &#125; &#125;) console.log(obj) // [Object: null prototype] &#123; name: &#39;names&#39; &#125; 类式继承 // 父类 function Shape() &#123; this.x = 0; this.y = 0; &#125; // 父类方法 Shape.prototype.move = function (x, y) &#123; this.x += x; this.y += y; console.log(`shape moved x:$&#123;x&#125;, y: $&#123;y&#125; `); &#125;; // 子类 function Rectangle() &#123; //调用父类构造函数 Shape.call(this); &#125; // 继承 Rectangle.prototype = Object.create(Shape.prototype, &#123; /* 这里如果不见Rectangle.prototype.constructor 设置为Rctangle , 那么它将采用Shape 的 prototype.constructor */ constructor: &#123; value: Rectangle, &#125;, &#125;); const rec = new Rectangle(); console.log(&quot;rec 式rectangle 的实例吗? :&quot;, rec instanceof Rectangle); console.log(&quot;rec 是 shape 的实例吗:?:&quot;, rec instanceof Shape); rec.move(1, 1); --------------------- rec 式rectangle 的实例吗? : true rec 是 shape 的实例吗:?: true shape moved x:1, y: 1 再性能上Object.create() 比Object.setPrototypeOf() 修改原型更具有性能优势, 但是在创建实例并且访问属性还没有被优化的时候, 他们之间的差异实际上也是可以忽略不计的, 使用Object.create() 的propertyObject 参数 Object.create() 方法创建对象在创建的过程中可以更精细的控制对象,它实际上是字面量初始化都西昂的一个语法糖. 在使用Object.create() 创建对象的时候, 我们可以指定对象的原型, 第二个参数可以映射到属性描述符,控制每个属性的可枚举型和可配置性 const obj = &#123;&#125;; // 等价于 const obj = Object.create(Object.prototype); //创建一个新对象, 它的原型是一个新的空对象,并添加了一个名为p, 值为42 的谁能够 const obj1 = Object.create(&#123;&#125;, &#123; p: &#123; value: 12 &#125; &#125;); 前面说到, 在使用Object.create()的时候, 可以传入一个属性为null 的参数, 创建一个原型为null 的对象,在字面量初始化对象的语法中相当使用__proto__ const obj = Object.create(null) // 等价于 const obj = &#123;__proto__: null&#125; 默认情况下, 使用Object.create() 创建的对象的属性值,属性是不可写,但是不可枚举和不可配置的,如果有需要, 需要显示指定writetable, enumerable, configurable: const obj1 = Object.create(&#123;&#125;, &#123; p: &#123; value: 12 &#125; &#125;); console.log(Object.getOwnPropertyDescriptors(obj1)); -------------- p: &#123; value: 12, writable: false, enumerable: false, configurable: false &#125; --------------- // 如果有需要请显示指定属性描述符 const obj1 = Object.create(&#123;&#125;, &#123; p: &#123; value: 12, writable: true, configurable: true, enumerable: true &#125; &#125;); ObJect.create()模仿new 行为 function Obj2() &#123;&#125; const obj2 = new Obj2(); // 等价于 const obj3 = Object.create(Obj2.prototype); Object.getOwnPropertyNamesObJect.getOwnProperyNames返回以一个数组, 返回指定对象自身所有的属性,, 包括不可枚举(但不博爱阔使用symbol值作为名称的属性和原型继承的属性) function Perosn(name, age) &#123; this.name = name; this.age = age; getName = function () &#123; return this.name; &#125;; &#125; Perosn.prototype.eat = function () &#123; return `吃饭`; &#125;; const p = new Perosn(); Object.defineProperty(p, &quot;newvalue&quot;, &#123; value: &quot;test&quot;, writable: false, enumerable: false, configurable: false, &#125;); console.log(Object.getOwnPropertyNames(p)); // [ &#39;name&#39;, &#39;age&#39;, &#39;newvalue&#39; ] 如果下只是获取不可枚举的属性 const target = p; const enumAndNonenum = Object.getOwnPropertyNames(target); const enumOnly = new Set(Object.keys(target)); const nonenumOnly = enumAndNonenum.filter((key) =&gt; !enumOnly.has(key)); Object.keys()该函数主要获取对象的可枚举的实例属性, 不包含原型链继承是属性,数据格式为数组; 如果需要获取属性的值, 可以使用Object.values() 如果同时需要获取属性的键值, 可以使用Object.entries const objarr = &#123; a: 1, b: 2, &#125;; console.log(Object.keys(objarr)); //[a,b] // 获取值 console.log(Object.values(objarr)); // 同时获取键值 console.log(Object.entries(bjarr)); Array类型判断一个变量是数组还是对象 instanceof在使用typeof 判断数据类型的时候,是不能直接判断一个变量是对象还是数据类型, 因为typeof 在判断基本数据类型的是偶很有用, 但是在判断引用类型的数据的时候,往往不能返回预期的结果类型 const arr = [1, 2, 3]; console.log(typeof arr); // object 在使用instanceof 虽然不能直接判断一个变量是引用数据类型还是基本数据类型, 但是它可以判断该变量是否是某个数据类型的实例 const arr = [1, 2, 3]; console.log(typeof arr); // object console.log(arr instanceof Array); // true const obj = &#123;&#125;; console.log(typeof obj); // object console.log(obj instanceof Object); // true 判断构造函数 constructor 判断一个变量是否是数组还是对象, 从另外一个层面将就是判断变量的构造函数时Array 还是Object 类型, 因为一个对象的实例都是通过构造函数的来生成的, 所以可以直接判断一个变量的constructor const a = [1, 2, 3]; console.log(a.constructor === Array); // true console.log(a.constructor === Object); // false const obj = &#123;&#125;; console.log(obj.constructor === Array); // true console.log(obj.constructor === Object); // false 在javaScript 中每个变量都有一个__proto__ 属性, 表示的是隐式原型. 一个对象的隐式原型指向的是构造函数该对象的构造函数的原型 toString 函数 每种引用数据类型都会直接或者间接继承自Object 类型, 因此他们都会包含toString() 函数. 不同的数据类型的toString() 的返回值也是不一样的. 借助call 函数直接带哦用Object 原型上的toString() 函数, 然后通过返回值判断 const arr = [1, 2, 3]; const obj = &#123;&#125;; const symbol = Symbol(); console.log(Object.prototype.toString.call(arr));//[object Array] console.log(Object.prototype.toString.call(obj));//[object Object] console.log(Object.prototype.toString.call(symbol));//[object Symbol] Array.isArray()在es5 中数组增加了isArray() 静态函数, 用来判断变量是否为数组. 传入需要判断的变量, 返回一个布尔值,. console.log(Array.isArray([])); console.log(Array.isArray(Array.prototype)); isArray 只能判断一个变量是否为数组, 对于变量是否是变量类型无法判断. 数组常用求数组的最大值和最小值自定义扩展函数自定义函数. 循环第一个值和后面的值做比较 Array.prototype.min = function () &#123; let min = this[0]; let len = this.length; for (let i = 0; i &lt; len; i++) &#123; if (this[i] &lt; min) &#123; min = this[i]; &#125; &#125; return min; &#125;; Array.prototype.max = function () &#123; let max = this[0]; let len = this.length; for (let i = 0; i &lt; len; i++) &#123; if (this[i] &gt; max) &#123; max = this[i]; &#125; &#125; return max; &#125;; 使用Math 对象min 函数和max 函数Array.max = function (arr) &#123; return Math.max.apply(Math, arr); &#125;; Array.min = function (arr) &#123; return Math.min.apply(Math, arr); &#125;; 使用reduce() 函数Array.prototype.max = function () &#123; return this.reduce(function (pre, cur) &#123; return pre &gt; cur ? pre : cur; &#125;); &#125;; Array.prototype.min = function () &#123; return this.reduce((pre, cur) =&gt; &#123; return pre &lt; cur ? pre : cur; &#125;); &#125;; 使用sort() 函数使用sort() 函数的时候如果省略参数的话那么数组元素会被转换为字符串, 然后根据每个字符串的Unicode 排序. 例如再数值排序中9 出现80 之前, 但是因为数字会被转换为字符串,字符串80 出现9 之前, 所以实际上会80 会排在9 之前. 如果提供了callback , 那么所有非undefined 的数组元素都会按照函数的返回值进行排序, 如果含有undefined 元素, 那么也会排在末尾. callback 返回值 怕排位顺序 o a 在 b 后 如[a, b]&lt; 0 a 在b 前 如[b,a]&#x3D;&#x3D;&#x3D; 0 保持原来的排序 sort() sort(compareFn) const arrSort = function (a, b) &#123; return a - b; &#125;; console.log(arr.sort(arrSort)[0]); console.log(arr.sort(arrSort)[arr.length - 1]); 使用es6 扩展运算符Math.max(...arr)// 最大值 Math.min(..arr)/ 最小值 数组遍历最原始的for 循环 const arr = [1,2,3] for(let i = 0; i &lt; arr.length; i++)&#123; console.log(arr[i]) &#125; forEach()按照索引升序的为数组中的每个元素调用一次提供的callback 函数. forEach 总是返回undefined,且不能链式调用, 不会改变原数组. 而且期待的时一个同步函数, 他不会等待Promise 兑现 array.forEach(callback); array.forEach(callback, thisArr); callback : 为数组中的每个元素执行的函数, 会丢弃的它的返回值, 该函数被调用的时候, hi传入以下的参数. element: 当前正在处理的元素 index: 数组中正在处理的当前元素的索引 array: 调用了forEach 的数组本身. thisArr: 可选参数,在执行callback 时的this值, 如果使用了箭头函数, 则会忽略传入的参数. const arr = [5, 5, 4]; arr.forEach((el, index) =&gt; &#123; console.log(index, el); &#125;); ForEach 兼容函数 Array.prototype.forEach = Array.prototype.forEach || function (fn, context) &#123; for (let i = 0; (length = this.length); i &lt; length, i++) &#123; if (typeof fn === &quot; function&quot; &amp;&amp; Object.prototype.hasOwnProperty.call(this, i)) &#123; fn.call(context, this[i], i, this); &#125; &#125; &#125;; map() 遍历map 迭代, 会为数组中的每一个元素调用一次提供的callback, 并用结果构建一个数组. map 是一个复制方法, 他不会改变this .在第一次调用callback之前, 数组的长度就已经被保存. 在开始调用map()的时候, callback 不会访问超出数组的初始长度. 对已访索引的更改不会导致再次在这些元素上调用callback 如果数组中有一个现有的, 尚未被访问的元素被callback 更改, 那么它访问的是该元素被修改后的值, 被删除的元素则不会访问 map(callbackFn) map(callbackFn, thisArg) callback: 为数组中的每个元素执行的函数, 它的返回值, 作为一个元素被添加为到新的数组中. element: 数组中当前正在处理的元素 index: 正在处理的元素在数组中的索引. array: 调用了map() 的数组的本身 let arr = [1, 2, 3]; arr.map((el) =&gt; &#123; console.log(el); &#125;); map 重新格式化数组中的对象 const kvArray = [ &#123; key: 1, value: 10 &#125;, &#123; key: 2, value: 20 &#125;, &#123; key: 3, value: 30 &#125;, ]; const kv = kvArray.map((&#123; key, value &#125;) =&gt; &#123; return &#123; [key]: value &#125;; &#125;); //[ &#123; &#39;1&#39;: 10 &#125;, &#123; &#39;2&#39;: 20 &#125;, &#123; &#39;3&#39;: 30 &#125; ] // 或者上面对象中的数组转换 const arr2 = kv.map((obj) =&gt; &#123; const key = Object.keys(obj)[0]; const value = obj[key]; return &#123; key, value &#125;; &#125;); /* [ &#123; key: &#39;1&#39;, value: 10 &#125;, &#123; key: &#39;2&#39;, value: 20 &#125;, &#123; key: &#39;3&#39;, value: 30 &#125; ] */ parseInt 和 map 一起使用再使用map 的时候我们通常都是使用一个参数, 即正在遍历的值.但是再实际应用中, 有些函数是可以接受额外参数. [&quot;1&quot;,&quot;2&quot;, &quot;3&quot;].map(parseInt) 在上面的代码中我峨嵋你期望输出的是[1,2,3] 但是实际结果是[1,nan,nan]在parseInt 函数中通常都是使用一个参数, 即传入的字符串, 但是还有一个可选参数,表示传入的字符以什么进制的基数来转换该字符串.(默认为10进制).但是map在使用的时候, 会传递三个参数: 元素 索引 数组 在传入parseInt的时候, map 传递进来的参数, 会被默认接受前面两个参数即, 即元素, 索引. 至于为什么不接受数组,是因为parseInt 只接受两个参数, 第三个参数会被忽略.所以上面的代码在迭代的时候大概就是 // parseInt(string, radix) -&gt; map(parseInt(value, index)) /* 第一次迭代 (index 是 0): */ parseInt(&quot;1&quot;, 0); // 1 /* 第二次迭代 (index 是 1): */ parseInt(&quot;2&quot;, 1); // NaN /* 第三次迭代 (index 是 2): */ parseInt(&quot;3&quot;, 2); // NaN 所以在map 和parseInt一起搭配使用的时候, parseInt 需要显示指定进制基数. const returnInt = (element) =&gt; parseInt(element, 10); [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(returnInt); // [1, 2, 3] // 实际结果是一个数字数组（如预期） // 与上面相同，但使用简洁的箭头函数语法 [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map((str) =&gt; parseInt(str)); // [1, 2, 3] // 实现上述目标更简单的方法，同时避免了“骗招”： [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(Number); // [1, 2, 3] // 但与 parseInt() 不同，Number() 还会返回一个浮点数或（解析）指数表示法： [&quot;1.1&quot;, &quot;2.2e2&quot;, &quot;3e300&quot;].map(Number); // [1.1, 220, 3e+300] // 为了进行比较，如果我们对上面的数组使用 parseInt(): [&quot;1.1&quot;, &quot;2.2e2&quot;, &quot;3e300&quot;].map((str) =&gt; parseInt(str)); // [1, 2, 3] map 兼容函数 Array.prototype.map = Array.prototype.map || function (fn, context) &#123; const arr = []; if (typeof fn === &quot;function&quot;) &#123; for (let i = 0; (length = this.length); i &lt; length, i++) &#123; if (typeof fn == &quot;function&quot; &amp;&amp; Object.prototype.hasOwnProperty.call(this, i)) &#123; arr.push(fn.call(context, this[i], i, this)); &#125; &#125; &#125; return arr; &#125;; filter() 函数为数组中的每个元素执行的函数. 它返回一个真值将元素保留在结果数组中, 否则返回一个假值.filter 是一个复制方法, 他不会改变this, 而是返回一个包含与原始数组相同的元素(其中某些元素已经被过滤掉)的浅拷贝.在第一次第哦啊用callback 之前,数组的长度已经被保存. 但开始调用filter 的时候, callback 不会访问超出数组初始长度的任何元素 如果已经数组中的元素已经被访问,如果再发生更改, 那么callback 不会再次访问更改的元素. 如果数组中尚有元素没有被callback访问, 那么传递给callback 的值是被修改后的值, filter(callbackFn) filter(callbackFn, thisArg) callback element 数组当前正在处理的元素 index 正在处理的元素在数组中的索引 array 调用fileter() 数组的本身 thisArg: 可选参数 返回给定数组的一部分的浅拷贝 筛选排除所有较小的值 使用filter 创建一个过滤数组, 该数组删除了小于指定的值的元素, 如:删除所有值小于10 的元素 function isBigEnough(value) &#123; return value &gt; 10; &#125; const filterd = arr.filter(isBigEnough); 找出数组中的所有素数 const res = arr.filter((value) =&gt; &#123; for (let i = 2; value &gt; i; i++) &#123; if (value % i === 0) &#123; return false; &#125; &#125; return value &gt; 1; &#125;); 过滤无效数据 兼容性写法 Array.prototype.filters = Array.prototype.filter || function (fn, context) &#123; const arr = []; if (typeof fn === &quot;function&quot;) &#123; for (let i = 0, length = this.length; i &lt; length; i++) &#123; if (typeof fn === &quot;function&quot; &amp;&amp; Object.prototype.hasOwnProperty.call(this, i)) &#123; fn.call(context, this[i], i, this) &amp;&amp; arr.push(this[i]); &#125; &#125; &#125; return arr; &#125;; 数组去重for 遍历数组function delRepeat(arr) &#123; // 新建一个数组保存不重复的值 const res = []; // 遍历传递进来的数组 for (let i = 0; i &lt; arr.length; i++) &#123; // 判断当前循环的值是否存在 保存结果的数组 if (res.indexOf(arr[i]) === -1) &#123; res.push(arr[i]); &#125; return res &#125; 键值对判断对传入的数组进行遍历, 判断当前遍历的值是否是对象的键, 如果是则表示该元素出现过,不作处理, 如果没有出现过, 则表示该元素第一次出现,则给对象插入键, 同时插入新的数组 function delRepeat(arr) &#123; const obj = &#123;&#125;, res = []; let val, type; for (let i = 0; i &lt; arr.length; i++) &#123; val = arr[i]; type = typeof val; if (!obj[val]) &#123; obj[val] = [type]; res.push(val); &#125; else if (obj[val].indexOf(type) &lt; 0) &#123; // 判断数据类型是否存在 obj[val].push(type); res.push(val); &#125; &#125; return res; &#125; 排序去重对出传入的数组排序后, 然后对排序后的数组进行相邻元素去重,再将去重后的元素添加到新的数组中 function delRepeat(arr) &#123; const res = [arr[0]]; arr.sort((a, b) =&gt; &#123; return a - b; &#125;); for (let i = 0; i &lt; arr.length; i++) &#123; if (arr[i] !== res[res.length - 1]) &#123; res.push(arr[i]); &#125; &#125; return res; &#125; 优先遍数组双重fo循环,指定循环的索引i 与j, j的初始值为i + 1. 在每层循环中, 比较索引i 和j 的值是否i案等, 如果相等则表示数组中出现了相同的值.出现了相同的值后, 更新索引i 与 j, 操作为++i, 同时赋值给j, 再对新的索引i 与 j 的值进行比较. function delRepeat(arr) &#123; const res = []; for (let i = 0; i &lt; arr.length; i++) &#123; for (let j = i + 1; j &lt; arr.length; j++) &#123; if (arr[i] === arr[j]) &#123; j = ++i; console.log(j); &#125; &#125; res.push(arr[i]); &#125; return res; &#125; reducefunction delRepeat(arr) &#123; const obj = &#123;&#125;; let type; return arr.reduce((previous, current) =&gt; &#123; type = typeof current; if (!obj[current]) &#123; obj[current] = [type]; previous.push(current); &#125; else if (obj[current].indexOf(type) &lt; 0) &#123; obj[current].push(type); previous.push(current); &#125; return previous; &#125;, []); &#125; es6 Set 数据结构function delRepeat(arr) &#123; return Array.from(new Set(arr)); &#125; es6 map 数据结构function delRepeat(arr) &#123; const map = new Map(); return arr.filter((item) =&gt; &#123; return !map.has(item) &amp;&amp; map.set(item, 1); &#125;); &#125; 寻找数组中出现次数最多的元素 利用键值对 利用key-value型的键值对数据进行存储.定义一个对象, 再遍历数组的时候, 将数组元素作为对象的键, 将出现的次数作为值. 1234567891011121314151617181920212223 function findMost(arr) &#123; const res = &#123;&#125;; if (!arr.length) return; if (arr.length === 1) return 1; for (let i = 0; i &lt; arr.length; i++) &#123; if (!res[arr[i]]) &#123; res[arr[i]] = 1; &#125; else &#123; res[arr[i]]++; &#125; &#125; const keys = Object.keys(res); let maxnun = 0, maxItem; len = keys.length; for (let i = 0; i &lt; len; i++) &#123; if (res[keys[i]] &gt; maxnun) &#123; maxnun = res[keys[i]]; maxItem = keys[i]; &#125; &#125; return `出现次数最多的元素是$&#123;maxItem&#125;, 出现次数是: $&#123;maxnun&#125;`;&#125; 但是这个方法哟啊遍历两次,第一次遍历传递进来的数组, 第二次遍历对对象, 效率会相对较低.下面对上面的方法优化 function findMost(arr) &#123; const res = &#123;&#125;; let maxNum = 0, maxItem = null, len = arr.length; for (let i = 0; i &lt; len; i++) &#123; // 保存每次遍历的值 let val = arr[i]; // 再新建对象中判断当前遍历的值是否窜在对象中, 不存在则 // 出现了一次, 如果存在则++ res[val] === undefined ? (res[val] = 1) : res[val]++; if (res[val] &gt; maxNum) &#123; maxItem = val; maxNum = res[val]; &#125; &#125; return `出现次数最多的元素是$&#123;maxItem&#125;, 出现次数是: $&#123;maxNum&#125;`; &#125; 使用reduce()function findMost(arr) &#123; let maxNum = 1, maxItem; const obj = arr.reduce((previous, current) =&gt; &#123; previous[current] ? previous[current]++ : (previous[current] = 1); if (previous[current] &gt; maxNum) &#123; maxNum++; maxItem = current; &#125; return previous; &#125;, &#123;&#125;); return `出现次数最多的元素是$&#123;maxItem&#125;, 出现次数是: $&#123;maxNum&#125;`; &#125; 运算符 在javascript 中的相等分为双等== 和三等=== 比较. 和java 那些强类型语言在变量前面需要声明变量类型, 所以在比较的时候就不需要判断变量类型, 只要双等就可以了. 但是javscript 是弱类型语言, 一个变量可以声明任何类型的值, 在比较的时候, 采用的的运算符号不同, 得到的结果也是不同的. 双等于运算符号在比较的时候, 会将两端的变量进行隐式类型比转换然后比较值的大小 三等于运算符号在比较的时候, 会优先比较数据类型, 数据类型相同才会去判断值的大小, 对于类型不同的值返回false 等于运算(&#x3D;&#x3D;&#x3D;) 如果比较的值不同直接返回false 121 === &#x27;1&#x27; // falsetrue === &#x27;true&#x27; // false 在基本数据类型中存在包装类型, 在未使用new 操作符的时候, 简单类型的数据比较实际上是为值的比较, 在使用了new操作符号以后, 实际得到的值类型, 又会变为引用类型, 在判断的时候会因为值的类型不同返回false 12341 === Number(1) // true1 === new Number(1) // false&#x27;str&#x27; == String(&#x27;str&#x27;) // true&#x27;str&#x27; === new String(&#x27;str&#x27;) // false 在比较的时候, 如果值的类型都是数值类型, 则直接比较值的大小, 相等则返回true , NaN 和任何数值类型比较都是false 包括自身 1NaN === NaN; 比较的如果都是字符串类型, 则判断每个位置的字符是否都一样, 如果一样返回true 否则返回false 12&#x27;str&#x27; === &#x27;str&#x27; // true&#x27;str1&#x27; === &#x27;str1&#x27; // false 如果比较的四Boolean 类型, 则两者同时为true 或者false 的时候, 返回true否则返回fasle 12false === false // truetrue === false // fasle 如果比较的值的是null 或者是undefined ,同理两者都是null 或者undefined 的时候为true, 否则为false 123null === null // trueundefined === undefined // trueundefined === null // false 如果比较的值是引用类型,则两个引用指向同一个地址的时候, 返回true, 否则返回false 123456const a = []const b = aconst c = []a === b //truea === c // false&#123;&#125; === &#123;&#125; // false 在比较引用类型的时候, 只要有一个比那阿联是通过new操作符号等到的, 都会返回false , 无论是引用类型还是基本类型的包装类型 123456 &#x27;hello&#x27; = new Sritng(&#x27;hello&#x27;) // falsenew String(&quot;hello&quot;) === new Srtring(&#x27;hello&#x27;) // falsefunction Person()&#123;&#125;const p1 = new Person()const p2 = new Person()p1 === p2 // fasle typeof() 运算符号tyepeof 运算符, 主要用于返回操作数的数据类型, 有两种使用形式 12tyepeof &#123;&#125;typeof(&#123;&#125;) 类型 结果 Undefined “undefined” Null “object” Boolena “boolean” Number ‘number’ String “string” Symbol “symbol” 函数对象 ‘function’ 其他任何对象 ‘object’ typeof 判断null使用typeof 处理 基本数据类型 null 返回的是Object, 这是因为javascript 在设计的时候一种缺陷. 在javascript 最初的时候吗,每种数据类型都会使用3bit 来表示. 000 表示的是Object 类型 001 表示的是Int 类型的数据 010 表示的是Double 类型的数据 100 表示的string 类型的数据 110 表示的Boolean 类型的数据 由于null 代表的是空指针, 在大多数的平台中的值都是0*00 , 因此null 的数据标签就还成了0, 所以在typeof 判断的时候, 返回的是’Object’ typeof 运算中的优先级在typeof 中有时候括号是必须要存在的, 不然会因为括号的优先级的问题, 导致无法得到我们预想的结果 123let number = 123typeof (number + &quot;hello&quot;) // Stringtypeof number + &#x27;hello&#x27; // Number hello 在typeof 运算中,它自己本身的的优先级会高于字符串拼接符号+, 但是又低于小括号(), 所以在上面代码中, 在没有使用括号的时候, 又优先处理typeof number , 然后返回了number 再和字符串hello 拼接, 得到了number hello 逗号运算在javascript 中逗号运算符号, 属于最基本的分隔符号,. 在另外一方面它也可以作为一个运算符号, , 将多个表达式连接起来, 从左到右依次执行. for循环中批量执行表达式在for循环中,可以让多个变量表达式变为一个表达式, 然后一次执行 123for(let i0,j = 10; i &lt; 10, j &lt; 20; i++,j++)&#123; console.log(i,j) &#125; 交换变量, 无须额外的变量通常我们在交换变量的时候, 都会这样子做,借助一个临时变量存储一个变量的值, 然后再互相复制, 然后实现变量交换 123456var a = &#x27;1&#x27;let b = &#x27;b&#x27;let c;c = a;a = b;b = c; 但是我们可以使用逗号运算符号同样达到这个效果 123456let a = &quot;a&quot;let b = &quot;b&quot;// 方法1a = [b, b = a[0]]// 方案2a = [b][b = a , 0] 再第一个方案中, [b , b = a] 是一个一维数组, 第二项值是b = a, 也就是a 的值赋值给了 b, 数组的值最终就是 [b,a], 然后取出索引为 0 的值b , 复赋值给了 变量a, 最终得到了, a = b, b = a,的变量交换. 在方案2 里面前面的[b] 是一个一维数组, , 后面一部分是[b &#x3D; a, 0], 会先执行b = a, 将a 的值赋值给 b, 然后返回0, 因此得到的击鼓哦是修改了b的值, 斌返回了索引0 最后得到的结果是a = [b][0] 使用小括号保证逗号运算符的优先级在所有的运算符号中, 逗号运算符的优先级是最低的, 因此字某些设计优先的级的问题上, 我们需要用到小括号, 将含有逗号运算符的表达式扩起来. 12let a = 10let b = ++a, 10; // 直接报错 对于面的代码为什么会直接报错 是因为同时粗线了赋值运算符和逗号运算符号, 因为逗号运算符的优先级最低, 在执行的时候, 最先执行的肯定是b = ++a 然后再去执行后面的10, 但这不死一个合法的语句, 所以会报错, 解决的办法就是加上小括号. 12let a = 10let b = (++a, 10) 运算符的优先级在javscript 中每个运算符号都又自己的优先级, 优先级决定了表达式在执行时的先后顺序, 优先级最高的最先执行, 优先级最低的最后执行. 如果优先级相同那么按照顺序从左往右依次执行. toString() 函数和valuOf() 函数在JavaScript 中toString() 和valueOf 函数解决的时值的运算和显示问题, 在所有的引用类型中都拥有者两个函数. toString()toString() 函数的作用是吧一个逻辑值转换为字符串, 并返回结果.Object 类型数据的toString 函数默认的返回结果是[object Object] 当我们自定义新类的时候, 剋重写toString 函数, 返回可读性更高的结果 Array 函数返回的是以逗号分隔的数组成员 12Array.toString() //function Array() &#123; [native code] &#125;[1,2,3].toString() // 1,2 ,3 Function() 返回的为函数的文本定义 1234function foo() &#123;&#125;console.log(foo.toString()); // function foo() &#123;&#125;console.log(Function.toString()); // function Function() &#123; [native code] &#125; Date 返回的是具有可读性的时间字符串 123const date = new Date();console.log(date.toString()); // Sun Oct 15 2023 18:15:46 GMT+0800 (中国标准时间)console.log(Date.toString()); // function Date() &#123; [native code] &#125;valueOf()函数 valueOf() 函数valueOf () 函数的作用是返回最适合应用类的原始值, 如果每日有原始值, 则会返回引用了类型自身. Array 返回的数组本身 123let arr = [1, 2];console.log(Array.valueOf());//[Function: Array]console.log(arr.valueOf());//[ 1, 2 ] Function 返回的函数本身 123function foo() &#123;&#125;console.log(Function.valueOf());//[Function: Function]console.log(foo.valueOf());//[Function: foo] Date 返回的指定日期的时间戳 123const date = new Date();console.log(Date.valueOf());//[Function: Date]console.log(date.valueOf());//1697365471832 如果一个引用数据类型同时存在toString() 和valueOf() 函数如果出现了这种情况, 一般分为两种场景,: 引用类型转换成String 类型 引用类型转换成Number类型 引用类型转换String 类型以个引用类型的数据转换成String 类型的时候, 一般是用于数据展示, 转换的时候, 遵循这些规则. 如果对象具有toString() 函数, 则会优先调用toString() 函数,. 如果返回值是一个原始值, 那么该原始值则会直接转换成字符串表示, 并返回该字符串 如果对象没有toString 函数, 或者toString() 函数返回的不是一个原始值, 则会去调用valueOf() 函数, 如果valuOf() 返回的是一个引用指, 则会将这个结果转换为字符串类型, 并返回该字符串. 如果toString() 和valueOf() 函数都获得一个原始值, 那么会直接抛出转换异常 1234567891011121314const arr = [];arr.toString = function () &#123; console.log(&quot;toString 函数执行了&quot;); return [];&#125;;arr.valueOf = function () &#123; console.log(&quot;valueOf函数执行了&quot;); return [];&#125;;console.log(arr.toString());console.log(String(arr));//toString 函数执行了// valueOf函数执行了//Error: Cannot convert object to primitive value 在上面的代码中执行String(str) 的时候, 代码期望将arr 转换成一个String 类型,.那么根据转换规则则会优先执行toString() 但是在重写的代码中toString返回的是一个数据, 并不能转换成原生数据, 接下来则会去调用valueOf() 函数, 但是也是返回的是[] 两则都无法转换成基本类型, 则, 抛出了异常 引用类型转换number 类型12345678910let arr = [];arr.toString = function () &#123; console.log(&quot;toString 被调用了&quot;); return [];&#125;;arr.valueOf = function () &#123; console.log(&quot;valueOf 函数被调用了&quot;); return [];&#125;;console.log(Number(arr)); 结果也同样是报错connot convert object to primitive value . 其原理和上面String 转换成 Number大致一样. 判空方法判断一个变量是否为空数组的时候, 首先需要判断该变量是否是一个数组, 然后通过数组的length属来确定. 首先使用instanceof 来判断该变量是否是数组的Array的实例, 然后再判断边变量是否有length 属性. 123456789// const obj = &#123;&#125;;const obj = &#123; 1: 1, length: 1,&#125;;if (obj instanceof Array &amp;&amp; obj.length) &#123; console.log(true);&#125; else &#123; console.log(false); 判断变量是否为空字符串判断一个变量是否为空字符串的时候, 可以直接将其与空字符串相比较, 或者调用trim() 函数去掉字符前后空, 然后判断字符串的长度, 当这两个条件满足任意一个的时候, 变量是一个空字符串 1str = &quot;&quot; || str.trim().length() 判断变量为0 或者NaN当一个变量为number 的时候, 判空即判断变量是否为0 或者NaN , 因为NaN 和任何值比较都是false 1!(Number(num) &amp;&amp; num) == true 测试标题2","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"},{"name":"阅读","slug":"阅读","permalink":"http://example.com/categories/%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"阅读","slug":"阅读","permalink":"http://example.com/tags/%E9%98%85%E8%AF%BB/"}]},{"title":"TypeScript","slug":"Typescript","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2023/10/04/Typescript/","link":"","permalink":"http://example.com/2023/10/04/Typescript/","excerpt":"","text":"","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/categories/TypeScript/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"}]},{"title":"npm","slug":"npm","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2023/10/02/npm/","link":"","permalink":"http://example.com/2023/10/02/npm/","excerpt":"","text":"npm 下载源设置12345678910npm config get registry // 查看npm当前镜像源npm config set registry https://registry.npm.taobao.org/ // 设置npm镜像源为淘宝镜像yarn config get registry // 查看yarn当前镜像源yarn config set registry https://registry.npm.taobao.org/ // 设置yarn镜像源为淘宝镜像# https -&gt; http，这样网速就会好很多npm config set registry http://registry.npmjs.org","author":"chen","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"npm","slug":"npm","permalink":"http://example.com/categories/npm/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://example.com/tags/npm/"}]},{"title":"git","slug":"git","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2023/10/02/git/","link":"","permalink":"http://example.com/2023/10/02/git/","excerpt":"","text":"git 设置123git config --global user.name gitaccountgit config --global user.email gitaccount@example.com git 取消全局设置12345git config --global --unset user.namegit config --global --unset user.emailgit config --global user.name#全局配置账户已经移除git config --global user.email git 取消代理12git config --global --unset https.proxygit config --global --unset http.proxy error: RPC failed； curl 28 OpenSSL SSL_read: Connection was reset, errno 10054 fatal: expected 证书错误忽略证书错误 1git config --global http.sslVerify &quot;false&quot;","author":"chen","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"pip install操作","slug":"pip install操作","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2023/10/02/pip install操作/","link":"","permalink":"http://example.com/2023/10/02/pip%20install%E6%93%8D%E4%BD%9C/","excerpt":"","text":"pip install 操作 pip install 包名 pip show –files 安装包名 查看是否安装 检查更新 pip list –outdated pip 升级包 pip install – upgrade 要升级的包名 pip 卸载 pip uninstall 要卸载的包","author":"chen","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"你不知道的javascript阅读笔记","slug":"你不知道的javascript阅读笔记","date":"un00fin00","updated":"un55fin55","comments":true,"path":"2023/10/01/你不知道的javascript阅读笔记/","link":"","permalink":"http://example.com/2023/10/01/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","excerpt":"","text":"对象在JavaScript 中对象可以通过两种形式定义,: 声明和构造形式. 对象声明: 1const obj = &#123;&#125; 构造声明 12cosnt obj = new Object();obj.value = value 上面两种生成的对象是一样. 区别只在在于, 在对象声明中我们可以一次性添加多个键值对, 而构造声明需要诸葛添加属性 对象类型在JavaScript 中主要有六种数据类型: string number boolean null undefined object 在上面的(string, boolean, number, null, undefined) 本省并不是一个对象, null 又时候虽然也被当做一个对象, 但这其实本身是语言的一个bug,是因为对null 执行 type of 的时候会返回字符串“object”, 但严格意义来说null 本身属于基本类型. JavaScript 中的函数也属于对象的一个子类型, 内置对象 String Number Boolean Object Function Array Date RegExp Error 对象键值对象的内容本身是由任意类型的值,组成的我们统称为属性, 在需要访问对象的值的时候我们通常使用. 操作符, 或者[] 操作符来访问. 其中前者被称为属性访问, 后者被称为见访问. 1234567const obj = &#123; a: 2,&#125;;// 点操作符console.log(obj.a);// 属性操作console.log(obj[&#x27;a&#x27;]); 这两种属性访问的区别在于,. 操作符需要满足标识符的命名规范, 而[“”] 操作符, 可以接受任何UTF-8&#x2F;Unicode字符串为属性名. 在对象中属性永远都是字符串,即使使用string 意外的字面量为属性名, 但是他也会隐性转换为字符串 12345cosnt obj = &#123; 2: a &quot;2&quot;:b&#125; 属性和方法在JavaScript 中如果访问的对象属性是一个函数在其他语言中, 在理解中这个函数可以被称为对象的访问, 但是在JavaScript 语法规范中, 函数永远不会属于一个对象,. 这是因为函数具有this的引用, 虽然有时这些this 确实会指向调用位置的对象引用. 但是JavaScript 的 this 是在运行时根据调用位置动态绑定, 函数和对象的关系只能称为间接关系 1234567891011function foo() &#123; console.log(&#x27;foo&#x27;);&#125;const someFoo = foo;const myObject = &#123; someFoo: foo,&#125;;foo();console.log(someFoo);console.log(myObject.someFoo); 正如上面的代码中, someFoo 和 Object.someFoo 中都是对同一个函数 foo 的引用, 同理这也能说明 对象中的函数,它并不是属于对象的一个方法. 对象复制Object.assign()对象的复制分为浅拷贝和深拷贝. 浅拷贝: 12const obj = &#123;a: 1&#125;const newobj = Object.assign(&#123;&#125;, obj) 1234567891011var person1 = &#123; name: &#x27;p1&#x27;, age: 18, &#125;; var person2 = &#123;&#125;; for (const key in person1) &#123; person2[key] = person1[key]; &#125; person2.name = &#x27;p2&#x27;; console.log(person1, person2); 深拷贝 1234567891011121314151617181920function deepClone(origin, target) &#123; var target = target || &#123;&#125;; var toStr = Object.prototype.toString; var arrType = &#x27;[object Array]&#x27;; for (const key in origin) &#123; if (origin.hasOwnProperty(key)) &#123; if (typeof origin[key] === &#x27;object&#x27; &amp;&amp; origin[key] !== null) &#123; if (toStr.call(origin[key]) === arrType) &#123; target[key] = []; &#125; else &#123; target[key] = &#123;&#125;; &#125; deepClone(origin[key], target[key]); &#125; else &#123; target[key] = origin[key]; &#125; &#125; &#125; return target; &#125; JSON 拷贝 123456789101112131415```### 对象属性描述符 getOwnPropertyDescriptor在ES5 之前, javascript 本身没有提供可以直接检测属性特性的方法, 比如判断属性是否只读, 但是从es5开始, 所有的属性都具备了属性描述符.`getOwnPropertyDescriptor` 来查看对象属性```javascriptconst obj = &#123; a: 2,&#125;;Object.getOwnPropertyDesscriptor(&#x27;obj&#x27;, &quot;a&quot;) // &#123; value: 2, writable: true, enumerable: true, configurable: true &#125; 返回的对象包含了, 该对象的属性描述 value : 表示该属性的值 writable: 表示该值是否可以 更改 enumerable: 表示该值是否可以枚举 configurable: 表示该值是否可以配置 getOwnPropertyDescriptors 产看该对对象的所有属性描述 12345678910 const obj = &#123; a: 2, b: 2,&#125;;console.log(Object.getOwnPropertyDescriptors(obj));//&#123; a: &#123; value: 2, writable: true, enumerable: true, configurable: true &#125;, b: &#123; value: 2, writable: true, enumerable: true, configurable: true &#125;&#125; 上面的对象时我们我自己声明了一个对象, 看到声明对象的属性个的默认配置, 全部为true, 那么是否是在任何时候对象的属性描述都是true呢? 在创建普通属性时, 属性描述符都是使用的默认值,默认值都为true, 那么在使用Object.defineProperty 给一个对象添加属性或者修改一个属性,(如果configurable : true的话) 12345678910const obj = &#123;&#125;;Object.defineProperty(obj, &#x27;a&#x27;, &#123; value: 2,&#125;);console.log(Object.getOwnPropertyDescriptors(obj));//&#123; a: &#123; value: 2, writable: false, enumerable: false, configurable: false &#125;&#125; 上面代码可以看到在使用Object.difinePeoperty 为对象添加的属性在不显式执行描述符的时候, 该属性描述符这时候为false,当然也可以在对象添加对属性的时候, 显示的指定的添加. 1234567const obj = &#123;&#125;;Object.defineProperty(obj, &#x27;a&#x27;, &#123; value: 2, writable: true, enumerable: true, configurable: true,&#125;); 对象禁止扩展Object.preventExtensions(..)禁止一个对象添加属性, 并且保留自己的属性, 在非严格模式下, 创建新属性会静默失败, 在严格模式下, 会抛出typeError 错误 12345678910const obj = &#123; a: 2,&#125;;Object.preventExtensions(obj);obj.b = 3;console.log(Object.getOwnPropertyDescriptors(obj));// 可以看到新添加的属性无法添加进去&#123; a: &#123; value: 2, writable: true, enumerable: true, configurable: true &#125;&#125; 对象密封 Object.seal()该方法是在Object.preventExtensions 的扩展,把现有对象属性的描述符configurable 标记改为false. 在使用该方法后 , 不仅不能添加新符属性,, 也不能重新配置或者删除现有属性, 但是可以修改现有属性值 1234567891011const obj = &#123; a: 2,&#125;;//Object.seal() 前// a: &#123; value: 2, writable: true, enumerable: true, configurable: true &#125;console.log(Object.getOwnPropertyDescriptors(obj));// Object.seal() 后//a: &#123; value: 2, writable: true, enumerable: true, configurable: false &#125;Object.seal(obj);console.log(Object.getOwnPropertyDescriptors(obj)); 对象冻结Object.freeze()该方法h会在现有对象上调用Object.seal 把数据属性标记为 writable: fale 使用了该方法可以禁止该对象本身任意属性的直接修改, 但是对象用用的其他对象不受影响. 12345678910111213const obj = &#123; a: 2,&#125;;// Object.frreze 前// a: &#123; value: 2, writable: true, enumerable: true, configurable: true &#125;console.log(Object.getOwnPropertyDescriptors(obj));// Object.freeze 后// a: &#123; value: 2, writable: false, enumerable: true, configurable: false &#125;Object.freeze(obj);console.log(Object.getOwnPropertyDescriptors(obj));// 修改属性本身也是失败obj.a = 3;console.log(obj.a); // 2 在冻结之前对象引用 1234567891011const obj = &#123;a : 1&#125;// 在冻结之前浅拷贝复制一个对象const newObj = Object.assign(&#123;&#125;, obj)Object.freeze(obj)// a: &#123; value: 2, writable: false, enumerable: true, configurable: false &#125;console.log(Object.getOwnPropertyDescriptors(obj));// a: &#123; value: 2, writable: true, enumerable: true, configurable: true &#125;console.log(Object.getOwnPropertyDescriptors(newObj));// 修改成功newObj.a = 2; 对象解冻Object.isFrozen该方法判断一个对象是否被冻结, 如果被冻结,将返回true. 123if(Object.isFrozen(obj))&#123;&#125; 对象枚举在对象属性描述中有一个属性: enumerable 配置对象属性是否可以枚举, 1234567891011121314151617181920212223const obj = &#123;&#125;;Object.defineProperties(obj, &#123; a: &#123; value: 1, // 可枚举 enumerable: true, &#125;, b: &#123; value: 2, // 不可枚举 enumerable: false, &#125;,&#125;);// 属性访问全部都能正常访问console.log(obj.a, obj.b)console.log(&quot;b&quot; in obj)obj.hasOwnProperty(&quot;b&quot;)// 遍历对象for(let key in obj)&#123; // a: 1 console.log(k, obj[k])&#125; 在上面的代码中 , 使用了Object.defineProperties 配置了a, b 两个属性, 一个enumerable 配置为false, 一个配置了true,在我们使用了. 访问的时候, 是都能访问到全部属性的, 但是在 for 循环中却只出现了一个属性a 如果需要判断一个属性在对象中是否可以枚举:propertyIsEnumerable() 该方法会检查给定的属性是否直存在对象中, (不会检查原型链) 12obj.propertyIsEnumerable(&quot;a&quot;)// trueobj.propertyIsEnumerable(&quot;b&quot;)// false 至于in 和hasOwnProperty 也可以判断一个属性是否存在对象中, 他们的区别在于, in 只会判断对象本身自身是否包含, hasOwnProperty 则会查找原型链 下面的方法, 要可以枚举对象的属性 Object.keys()该方法会返回一个数组, 包含所有可枚举的属性 1Object.keys(obj) Object.gerOwnProeprtyNames()该方法也会返回指定对象中所有的属性, 无论是否可以枚举 对象遍历混合对象“类”在面向对象对象编程语言中, 关于对象一直有着这几种机制: 多态, 类, 继承, 封装 类描述了对象的属性(数据)和方法(行为,) 类也是对象的抽象 多态: 描述了对象可以根据上下文的不同的表现的多种状态, 可以使用类定义或接口定义的抽象类型的子类对象, 极大的提高了对象的灵活性和扩展性 继承: 允许一个类继承另外一个类, 通过继承子类可以重用父类的代码, 并可以扩展或修改父类的行为 封装: 指的是将数据和操作数据的行为包装在一起的机制, 以防止外部直接访问和修改对象内部的状态. 通过封装, 内部的对象细节对外是影藏的, 只提供公共接口来给其他对象使用 在hjavascript 中想要实现一个类: 12345678function Car()&#123; this.color = &quot;red&quot;; this.show = function()&#123; console.log(this.color) &#125;&#125;const car = new Car()car.show() 在以前都是使用构造函数来生成一个类,然后new 一个实例出来 原型[[prototype]][[prototype]] 是javascript 对象的内置属性, 他是对象之间继承关系的基础, 在javascript 中, 每一个对象都有一个[[prototype]] , 它指向另外一个对象或者为null . 这个指向的对象被称为原型prototype 当我们访问一个对象的属性时, 如果该对象本身没有该属性, 那么javascript 就会一层层的自动向上去原型上查找,称之为原型链 123456const obj1 = &#123; name: &#x27;obj1name&#x27;,&#125;;const obj2 = &#123; value: &#x27;obj2value&#x27;,&#125;; 上面的代码可以看到这时候两个obj 的prototype 指向的是Object 我们使Object.setPrototypeOf() 设置一下原型 12// 将obj1 ,设置为obj2 的原型Object.setPrototypeOf(obj2, obj1) 这时候呢个看到obj2 上的原型属性已经变为obj1 的属性了. 每一个Object.prototype 的顶部都是Object的 原型 类在严格意义上来说javascript 是一个只有对象没有类的语言. 因为javascript 的无法创造类, 即使后面推出了class 之流的关键字, 但是本质上依旧是原型的改版而已 构造函数原型继承在javscript 中经常使用模拟类的行为的方法,但是只有类不能继承的话, 那就是一个空架子, 虽然在es5 之后推出了extend 关键字来解决了类的继承问题. 那在es5 之前是这么解决的呢~ 行为委托类型异步","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"},{"name":"阅读","slug":"阅读","permalink":"http://example.com/categories/%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"阅读","slug":"阅读","permalink":"http://example.com/tags/%E9%98%85%E8%AF%BB/"}]},{"title":"javascript 高级程序设计阅读笔记","slug":"javascript 高级程序设计阅读笔记","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2023/10/01/javascript 高级程序设计阅读笔记/","link":"","permalink":"http://example.com/2023/10/01/javascript%20%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"},{"name":"阅读","slug":"阅读","permalink":"http://example.com/categories/%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"阅读","slug":"阅读","permalink":"http://example.com/tags/%E9%98%85%E8%AF%BB/"}]},{"title":"hexo","slug":"hexo配置","date":"un66fin66","updated":"un22fin22","comments":true,"path":"2023/09/30/hexo配置/","link":"","permalink":"http://example.com/2023/09/30/hexo%E9%85%8D%E7%BD%AE/","excerpt":"","text":"关于hexo git 上传老是超时报错在配置完hexo 上传发布到 git 的时候老是会报错ssl, 超时错误. 这时候可以修改hexo 根目录下的_config.yml的 deploy 项的repo 下面是默认的 1## repo: https://github.com/rongchaoChen/rongchaoChen.github.io.git 修改成 12repo: git@github.com:git用户名/git用户名.github.io hexo 文章模版12345678titile:文章名称author: chencategories: [文章分类]tag: &quot;文章标签&quot;文章摘要&lt;!--more --&gt;正文 page 独立页面 post 文章页面 docs 文档页面 category 分类页面 tag 标签页面 friends 友链页面 list 列表页面 文章布局文章分类多个分类有两种关系，一种是层级（等同于文件夹），一种是并列（等同于标签）。 多级分类： 1categories: [分类A, 分类B] 或者 123categories: - 分类A - 分类B 并列分类 123categories: - [分类A] - [分类B] 多级加并列分类 123categories: - [分类A, 分类B] - [分类C, 分类D]","categories":[{"name":"-hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"javascript this","slug":"javascript this","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2023/04/09/javascript this/","link":"","permalink":"http://example.com/2023/04/09/javascript%20this/","excerpt":"","text":"this在javascript 中, 因为是一门弱类型语言, 在很多时候, 总是会和强类型语言,如java python 这种强类型语言又着一些很不同的区别. 就如this 而言, 在常规认知理解中, this 顾名思义从英语的语法角度来说 把他理解成指向函数的本身.但是事实真的是这样的吗. 首先我们来看下面这段代码: 1234567891011function foo(num)&#123; console.log(&quot;foo:&quot; + num) this.count++;&#125;foo.count= 0for(let i = 0; i &lt; 10 ; i++)&#123; if(i&gt; 5)&#123; foo(i) &#125;&#125;console.log(foo.count) 在上面的代码中我们声明了一个foo ()函数, 并给foo()函数传递了一个形参,在函数内部中我们打印了这个传递进来的形参,并调用了一个count的参数, 来记录当前foo()函数被调用的次数, 在外面for()循环中, 当i &gt; 5 的时候, 这时候i 就会传递进去foo(num)形参当中, 最后我们consloe.log(foo.count)来记录foo()一共被调用了几次. 运行代码的结果如下: 12345foo: 6foo: 7foo: 8foo: 9count: 0 count 为什么是0呢?从输出结果来看foo()函数确实是被被调用了四次, 但是里面的this.count++ , 却没有增加.那是因为this.count 的this 的本身没有指向foo() 函数半身. 可是我在外面已经foo.count &#x3D; 0; 声明了啊 首先我们来看foo()本身的this, 其实是指向 全局的, this.count 也就相当于说是在全局创建了一个count 的变量.当我们在调用foo 函数的时候, foo.count是会被自增的, 但是它所在的对象this.count 却不会自增.那么我该怎么解决呢! 首先我们可以把foo 函数中的this.count .改成foo.count . 这时候虽然能解决当下的问题, 但是却没有解决实质性的问题, 如何指向当前的this. callcall函数 使用一个指定的this 值和单独给出的一个或多个参数来调用一个函数.那么来改变一下上面的代码 1234567891011121314function foo(num)&#123; console.log(&quot;foo:&quot; + num) // 因为当前this 不指向foo 函数本身 this.count++;&#125;foo.count= 0for(let i = 0; i &lt; 10 ; i++)&#123; if(i&gt; 5)&#123; // 那么在这里使用call 函数让this指向foo 函数 foo.call(foo,i) &#125;&#125;// 这时候输出结果符合我们console.log(foo.count) -","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"intellij配置Tomcat","slug":"intellij配置Tomcat","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2023/03/26/intellij配置Tomcat/","link":"","permalink":"http://example.com/2023/03/26/intellij%E9%85%8D%E7%BD%AETomcat/","excerpt":"","text":"记录一下intellij配置Tomcat, 首先intellij 和 tomcat 是肯定要的, intellij 版本为2022.1 ,tomcat为9. 第一步打开Intellij这时后在打开的目录下, 创建一个 new module, 选择java , 然后next 输入这个mdoule 名就好 然后再这个新module 上右键选择 Add Framewrok Support 选择 然后这时候的目录就是这样,然后我们再WEB-INF下面创建一个lib 文件和一个classes 文件 , lib 用来解压tomcat的jar包, classes,这时候我们的目录就搭建好了, 开始配置Tomcat 配置Tomcat注意Tomcat 和TomEE 不要选错 , 然后点击local 确认 这时候来到这里 选择自己安装好的Tomcat, 这时候再点击Deployment 项目设置 这里Jar 包的目录选择之前创建的lib 文件中, 然后点击Paths把再把之前创建好的classes 文件设置成output path 的路径 然后启动Tomcat j就好了","categories":[{"name":"intellij","slug":"intellij","permalink":"http://example.com/categories/intellij/"},{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"webpack/vue","slug":"webpack-vue","permalink":"http://example.com/tags/webpack-vue/"}]},{"title":"webpack4配置vue2\\3","slug":"webpack4配置vue23","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2023/03/26/webpack4配置vue23/","link":"","permalink":"http://example.com/2023/03/26/webpack4%E9%85%8D%E7%BD%AEvue23/","excerpt":"","text":"这样配置的时候适合再学习vu2&#x2F;3 学习切换的时候,到时就不用切换项目,只要每次重新配置一下webpack.config.js 就可以了. vue2配置首先我们创建一个文件. 在根目录下初始化文件 1npm init 创建vue 目录文件夹, src, public.在publuc 目录下创建index.html,引入vue2 cdn 12&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&#x27;app&#x27;&gt;&lt;/div&gt; 然后我们在 src 目录下创建一个main.js 来作为我们的入口文件 然后开始下载依赖. 1234567webpack@4.44.2webpack-cli@3.3.12webpack-dev-server@3.11.2html-webpack-plugin@4.5vue-template-compiler@2.7.14vue-loader@15.0-15.9 然后我们开始配置webpack.config.js 12345678910111213141516171819202122232425262728293031const &#123; resolve &#125; = require(&#x27;path&#x27;);const htmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);// 注意这里的vue-loader 一定要在16.0版本一下, 不然版本不兼容const VueLoaderPlugin = require(&#x27;vue-loader/lib/plugin&#x27;);module.exports = &#123; mode: &#x27;development&#x27;, entry: &#x27;./src/main.js&#x27;, output:&#123; path: resolve(__dirname, &#x27;dist&#x27;), filename: &#x27;main.js&#x27; &#125;, externals:&#123; &#x27;vue&#x27;: &#x27;Vue&#x27; &#125;, devtool: &#x27;source-map&#x27;, module:&#123; rules:[ &#123; test: /\\.vue$/, loader: &#x27;vue-loader&#x27; &#125; ] &#125;, plugins:[ new VueLoaderPlugin(), new htmlWebpackPlugin( &#123; template:resolve(__dirname,&#x27;public/index.html&#x27;) &#125;), ]&#125; 在main.js 创建Vue的实例挂载 12345import App from &#x27;./App.vue&#x27;new Vue(&#123; render:h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;) 在src 下创建一个App.vue 1234567891011121314&lt;template&gt;&lt;div&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;App&quot;, data()&#123; return &#123; title: &quot;hello word vue2&quot; &#125; &#125;&#125;&lt;/script&gt; 修改package.json, 位置启动项webpack-server-cli 123&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server&quot; &#125;, 这时候,如果没有出现插件兼容的问题, 基本就是没问题,可以npm run dev 启动了 vue3 配置在切换vue 的3 我们主要是替换vue-loader 就好了 下载@vue&#x2F;compiler-sfc&#96;是Vue.js 3的一个核心软件包, 而且这时候vue-loader 也要更新16.0 以上的版本最好不要17,不然需要处理兼容性 12vue-loader@next@16.1.1npm i -d @vue/compiler-sfc@3.1.2 下载好插件后, 修改一下webpack.config.js 123const VueLoaderPlugin = require(&#x27;vue-loader/lib/plugin&#x27;);// 这时候需要把之前引用vu2 的loader 修改成const &#123;VueLoaderPlugin&#125; = require(&#x27;vue-loader&#x27;); 然后修改main.js 的vue 挂载方式 1Vue.createApp(App).mount(&#x27;#app&#x27;) 修改index.html 中vue的cdn 引入 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@3.1.2/dist/vue.global.js&quot;&gt;&lt;/script&gt; 然后重新启动npm run dev vue2 和vue3 切换在配置好以后, 以后在这项目中, 每次切换的时候需要 修改index.html 的Vue cdn 引用 1234// vue 2&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.js&quot;&gt;&lt;/script&gt;// vue3&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@3.1.2/dist/vue.global.js&quot;&gt;&lt;/script&gt; 修改webcpack.comfig.js 1234// vue2 loader// const VueLoaderPlugin = require(&#x27;vue-loader/lib/plugin&#x27;);// vue3 loaderconst &#123; VueLoaderPlugin &#125; = require(&#x27;vue-loader&#x27;); 注意每次vue 2 切换 3 的时候,vue-loader 都要重新下载依赖 12345678910// vue2 切换3vue-loader@next@16.1.1npm i -d @vue/compiler-sfc@3.1.2vue3 切换vue2 vue-loader@15.0-15.9 总结其实在官网说明现在说明建议使用脚手架来构建了 1npm init vue@latest 而且在vue3 @vue&#x2F;compiler-sfc 核心包,已经停止维护了, 但是这样搭建也可以在学习2&#x2F;3 的时候方便切换,","categories":[{"name":"webpack","slug":"webpack","permalink":"http://example.com/categories/webpack/"}],"tags":[{"name":"webpack/vue","slug":"webpack-vue","permalink":"http://example.com/tags/webpack-vue/"}]},{"title":"hello","slug":"hello","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/03/25/hello/","link":"","permalink":"http://example.com/2023/03/25/hello/","excerpt":"","text":"这是标题1这是标题2这是标题2这是标题3这是标题3这是标题3这是标题2这是标题3这是标题3这是标题3这是标题2这是标题3这是标题3这是标题3","categories":[{"name":"测试分类","slug":"测试分类","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB/"}],"tags":[]},{"title":"tt","slug":"tt","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/03/25/tt/","link":"","permalink":"http://example.com/2023/03/25/tt/","excerpt":"","text":"这是h1 标题 Lorem ipsum dolor sit amet consectetur adipisicing elit. Incidunt aliquid soluta debitis, autem pariatur aut optio laboriosam nulla eius, nisi quibusdam praesentium dicta laudantium! Assumenda a dolor cum autem porro. 这也是h1 标题 Lorem ipsum dolor sit amet consectetur adipisicing elit. Incidunt aliquid soluta debitis, autem pariatur aut optio laboriosam nulla eius, nisi quibusdam praesentium dicta laudantium! Assumenda a dolor cum autem porro. 12let n = 1;console.log(n) h2 标题22 h2标题22 h1标题11 h2标题11","categories":[{"name":"测试分类","slug":"测试分类","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB/"}],"tags":[]},{"title":"tt copy","slug":"tt copy","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/03/25/tt copy/","link":"","permalink":"http://example.com/2023/03/25/tt%20copy/","excerpt":"","text":"这是h1 标题 Lorem ipsum dolor sit amet consectetur adipisicing elit. Incidunt aliquid soluta debitis, autem pariatur aut optio laboriosam nulla eius, nisi quibusdam praesentium dicta laudantium! Assumenda a dolor cum autem porro. 这也是h1 标题 Lorem ipsum dolor sit amet consectetur adipisicing elit. Incidunt aliquid soluta debitis, autem pariatur aut optio laboriosam nulla eius, nisi quibusdam praesentium dicta laudantium! Assumenda a dolor cum autem porro. 12let n = 1;console.log(n)","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[]},{"title":"test","slug":"test","date":"un44fin44","updated":"un66fin66","comments":true,"path":"2022/08/25/test/","link":"","permalink":"http://example.com/2022/08/25/test/","excerpt":"","text":"","categories":[{"name":"web前端","slug":"web前端","permalink":"http://example.com/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":" test","slug":"test","permalink":"http://example.com/tags/test/"}]},{"title":"hexo网站配置","slug":"hexo网站配置","date":"un33fin33","updated":"un00fin00","comments":true,"path":"2022/03/16/hexo网站配置/","link":"","permalink":"http://example.com/2022/03/16/hexo%E7%BD%91%E7%AB%99%E9%85%8D%E7%BD%AE/","excerpt":"","text":"1:安装gitbash2: 打开gitbash 设置user.name和email&#96;&#96; 12git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot; 3: 生成秘钥和github绑定4:安装node5: 安装hexo&#96;&#96; 1npm install -g hexo-cli 6:然后新建一个新的空文件,进入到新建的空文件初始化&#96;&#96; 1hexo init blog 然后测试 &#96;&#96; 12345hexo new test_my_site // 新建一篇文章hexo g // hexo generate #生成hexo s // 打开本地服务器 如果不出意外 服务器启动成功,显示访问端口: localhost: 4000 主题配置https://github.com/litten/hexo-theme-yilia 根据文档主题待定","categories":[],"tags":[]}],"categories":[{"name":"-hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"},{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"},{"name":"css","slug":"css","permalink":"http://example.com/categories/css/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"},{"name":"阅读","slug":"阅读","permalink":"http://example.com/categories/%E9%98%85%E8%AF%BB/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/categories/TypeScript/"},{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"npm","slug":"npm","permalink":"http://example.com/categories/npm/"},{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"},{"name":"intellij","slug":"intellij","permalink":"http://example.com/categories/intellij/"},{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"webpack","slug":"webpack","permalink":"http://example.com/categories/webpack/"},{"name":"测试分类","slug":"测试分类","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB/"},{"name":"web前端","slug":"web前端","permalink":"http://example.com/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"阅读","slug":"阅读","permalink":"http://example.com/tags/%E9%98%85%E8%AF%BB/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"},{"name":"npm","slug":"npm","permalink":"http://example.com/tags/npm/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"},{"name":"webpack/vue","slug":"webpack-vue","permalink":"http://example.com/tags/webpack-vue/"},{"name":" test","slug":"test","permalink":"http://example.com/tags/test/"}]}