{"meta":{"title":"chen","subtitle":"","description":"你是想说什么吗","author":"chen","url":"http://example.com","root":"/"},"pages":[{"title":"关于","date":"un66fin66","updated":"un66fin66","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"不要相信化妆和美颜的女孩子 年少的时候，我觉得孤单是很酷的一件事。长大以后，我觉得孤单是很凄凉的一件事。现在，我觉得孤单不是一件事。不合群是一回事，不将就又是另一回事。"},{"title":"所有分类","date":"un00fin00","updated":"un00fin00","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"un00fin00","updated":"un00fin00","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"这是分页标题","date":"un66fin66","updated":"un66fin66","comments":true,"path":"notes/项目笔记/index.html","permalink":"http://example.com/notes/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/index.html","excerpt":"","text":""},{"title":"这是分页标题","date":"un66fin66","updated":"un66fin66","comments":true,"path":"notes/tes/index.html","permalink":"http://example.com/notes/tes/index.html","excerpt":"","text":""}],"posts":[{"title":"vue","slug":"vue","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2023/10/08/vue/","link":"","permalink":"http://example.com/2023/10/08/vue/","excerpt":"","text":"","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"},{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"javascript重难点阅读","slug":"javascript重难点阅读","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2023/10/08/javascript重难点阅读/","link":"","permalink":"http://example.com/2023/10/08/javascript%E9%87%8D%E9%9A%BE%E7%82%B9%E9%98%85%E8%AF%BB/","excerpt":"","text":"数据类型在javascript 中, 数据类型可以分为基本数据类型和引用数据类型. 基本数据类型包括: undefined null boolean number string symbol(es6新增) 引用数据类型包括: ​ Object Function Array Date Undefined​ 表示一个变量不存在, 或者声明了却没有赋值初始化. 声明了变量但是没有初始化的变量会返回undefined 12var a ;console.log(a) 获取一个对象的某个不存在的属性(自身属性和原型链属性)时, 会返回undefined 12345const obj = &#123; name: &#x27;name&#x27;&#125;obj.age; // undefined 函数没有明确返回值时, 但却在其他地方使用了返回值, 会发返回undeined, 这也是我们经常在控制台调试的时候, 在没有指定return 值的时候, 老是会有undefined的出现 12function foo()&#123;&#125;console.lof()foo()) 函数定义的时候使用了多个形式参数, 在调用传递的时候,参数的数量少于形参, 那么在没有匹配上的参数就位undefined, 在es6 中已经可以指定默认参数, 避免了这种情况发行 function foo(num1, num=2)&#123;&#125; 如果在传递形参的时候, 指定了默认参数, 那么就会使用 默认参数, 避免了undefined的发生 1234function foo(num1, mu2)&#123; console.log(num,num2)&#125;foo(1) Nullnull 类型只有一个唯一的字面值,null , 表示一个空指针对象, 所以在使用typeof 检测null 值的时候也会返回一个object 的原因. 如果生命的变量是为了以后保存某个值, 那么再声明的时候, 就会会赋值为null 123const obj = null;function foo()&#123;&#125;obj = foo javascript 中在获取dom 元素的时候, 如果没有获取到指定的元素对象, 也会返回null 1document.querySelector(&quot;#id&quot;) // null 使用正则表达式进行捕获的时候, 如果没有捕获结果, 就会返回null 1&#x27;test&#x27;.match(/a/) ; // null Null 和undefined 的异同 虽然null 和undefined 是两种不同的基本数据类型,虽然存在一些不同的特性, 但是某些表现上却也存在着相同之处. 相同点null 和undefined 两种数据类型都只有一个字面值, 分别是null 和undefined. null类和undefined 类在转换为boolea 类型的值时候, 都会转换为false. 123if (!undefined) &#123; console.log(1);&#125; 123if (!null) &#123; console.log(2);&#125; 在非严格相等的情况下, 两者是相等的 1null == undefined // true 不同点null 是javascript 中的关键字, 而undefined 是javascript 中的一个全局变量 在使用typeof 运算检测的时候, undefined 类型的值会返回undefined null 类型的会返回object 12typeof undefined; // undefinedtypeof null; // object 通过call 调用 toString 函数的时候, undefined 类型的值会返回[Object Undefined] 而null 类型会返回[Object Null] 12Object.prototype.toString.call(undefined) // [Object Undefined]Object.prototype.toString.call(null) // [Object NuLl] 在需要进行字符串转换的时候, null 会换转为字符串null 而undefined 会转换为字符串undefined 12undefined + &quot;string&quot; // undefined stringnull + &quot;string&quot; // null string 在需要进行数值类型得转换 的时候, undefined 会转换为nan 无法参与计算, null 会转换为0, 可以参与计算 12undefined + 0 ; // nannull+ 0 ; // 0 BooleanBoolean 又称为布尔类型, 字面值只有两个, 分别是true 和false, 他们是区分大小写, 例如True 和 False 并不是boolean 类型. String 类型转换Boolean 类型 空字符串都转换为false 任何非空字符串都会转换为true, 包括空格字符串 number 类型 0 和nan 会转换为false 除了 0 和nan 都会转换为true, 包括无穷大和无穷小的infinity 和 -infinity Object类型 当object 为null 的时候, 会转换为false 如果object不为null , 则都会转换为true, 包括空对象{} Function 类型任何Function 类型的值都会转换为true Null 类型Null 类型只有一个null 值, 会转换为false Undefined 类型 undefined 类型只有一个undefined , 会转换为false Number类型在javascript 中number 类型包括了整数类型, 也包括了浮点类型数据. Number 类型转换javascript 中基本是按照十进制数据类行转换. boolean 类型转换number true 转换wi1 false 转换为0 12Number(true) // 1Number(false) // 0 Null 类型转换 null 类型值只有一个字面值null, 直接转换为0 1Number(null) // 0 Undefined 转换 undefined 只有一个字面值undefined, 直接转换为nan String 类型转换 如果字符串中值包含数字, 则会转换成十进制数, 如果前面有0, 则会直接省略掉,例如0123 , 直接转换为123 如果字符串串中包含有效的十六进制格式的数据, 则会按照十进制转换 如果是空字符串, 则转换为0 除了上面的格式, 其他的则会直接转换为NaN Object 类型转换 Object 类型转在转换为Number 类型的时候, 会优先调用valueof 函数, 燃烧后通过valueof&#39; 函数的方绘制值,按照规则转换,如果转换的结果是nan 则调用toString 函数, 通过toString 函数的返回值重新按照指定规则进行转换 &#96;&#96;&#96;javascriptconst obj &#x3D; { age: 21, valueOf: function () {return []; }, toString: function () {return this.age; },};console.log(Number(obj)); 123456789 #### Number 方法##### parseInt()用于解析一个字符串, 并返回指定的基数对应的整数值 parseInt(string, radix) 12345678910111213141516171819&gt; string : 表示要被解析的值, 如果该参数不是一个字符串, 那么会调用`toString` 函数转换成字符串&gt;&gt; radix: 表示进制转换的基数, 基数范围是2-36, 默认 为10 进制.&gt;&gt; 如果传入的字符串无法转换成`number` 类型, 则会返回`nan`###### map () 函数和parseInt() 函数的隐性坑在一个场景, 如果存在一个数组, 数组中的每个元素, 都是`number`类型的字符串`[“1”, ‘“2”, “3”]` 这时候如果将数组中的元素都转换为整数. ```javascriptvar arr = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;];var result = arr.map(parseInt);console.log(result);// 预期结果是 [1,2,3,4]// 实际结果是: [1, nan] Array.prototype.map 在mdn 的定义是一个迭代方法, 它为数组中的每一个元素调用一次提供的callback , 并用结果返回一个新数组 1map(callback, thisArray) map 的callback 接受三个参数, element: 数组当前正在处理的元素 index: 当前正在处理的元素数组索引 array: 调用了map 的数组本身 也就是类似于在使用map 的时候代码类似这样 123arr.map(function(el, index, array)&#123; return parseInt (el, index)&#125;) map 每次调用调用处理的数组元素的index 下标是在变化的.在处理到时候大概如下 1234parseInt(&#x27;1&#x27;, 0); // 1 任何整数以0 为基数取数的时候, 都会返回数值本身parseInt(&#x27;2&#x27;, 1); // NaN 基数只能是2-36parseInt(&#x27;3&#x27;, 2); // NaN 二进制数只有0,和1, 3超过了进制范围parseInt(&#x27;4&#x27;, 3); // NaN 4 无法使用3 进制表示 解决办法就是, 在每次使用parseInt 的时候尽量指定基数, 不要将parseInt 作为map 的参数,而是在map 的回调函数中使用 12const arr = []let res = arr.map((el)=&gt;&#123; return parseInt(10)&#125;) parseFloat()该方法用于解析一个字符串, 返回对应的符数点 , 如果给定的值不能转为数值, 则返回nan. 在解析的过程中如果遇到了正负号, 数字0-9 , 小数点或者科学计数法以外的字符, 则会忽略该字符开始至结束的所有字符, 然后返回当前已经接卸的字符的浮点数形式 12345parseFloat(&#x27;+1.2&#x27;); // 1.2parseFloat(&#x27;-1.2&#x27;); // -1.2parseFloat(&#x27;++1.2&#x27;); // NaN，符号不能连续出现parseFloat(&#x27;--1.2&#x27;); // NaN，符号不能连续出现parseFloat(&#x27;1+1.2&#x27;); // 1，&#x27;+&#x27;出现在第二位，不会当作符号位处理 字符前面的空白会直接忽略, 如果无法解析, 则直接返回nan 12parseFloat(&quot; 1.2&quot;) // 1.2parseFloat(&quot;f1.2&quot;) // nan 对于字符中出现的合法科学运算符, 在金蒜运算处理后会转换成浮点数 12parseFloat(&quot;4e3&quot;) // 400parseInt(&quot;4e3, 10&quot;) // 10 parseFloat: 在处理4e3 的时候 , 会先进行科学计数法的运算, 然后再转换为浮点数 parseInt : 在处理4e3 的时候, 则直接从字符串4 开始按进制基数10 转换, 然后返回整数4 对于小数点, 只能正确匹配第一个, 第二个小数点是无效的, 后面的字符也将被忽略 12parseFloat(&#x27;11.20&#x27;); // 11.2parseFloat(&#x27;11.2.1&#x27;); // 11.2 isNaN 与 Number.isNaN在number 数据类型中, 存在一个特殊的数值nan 即not a number, 表示应该返回设置却没有返回数值. 在javascript 中nan 有两个明显的特点: 任何涉及nan 的操作都会返回nan nan 与任何值都不相等, 即使是与nan 本身相比 在判断nan 的时候, es5 提供了isNaN 函数, 在es6 的时候, 又为number 类型添加了静态函数isNaN isNaN () 函数用来确定一个变量是不是NaN . NaN 是一个number 类型的数值, 只不过这个数值无法用真实的数字表示. 在传递参数的时候, 如果是number 类型的数据, 可以很容易判断是不是NaN 但是在传递的参数是非number 类型的时候, 谈返回的结果往往让人费解. 1isNaN(&#123;&#125;) // true 空对象明明不是一个nan 数据, 应该返回的false, 但是却返回了true. 首先nan 产生的条件是在数据运算的时候, 返回了一个无法表示的数值,如 1console.log(0/0) // nan 除了0&#x2F;0 , 其他数据除以0 都会返回Infinity 又或者在做强制数据类型转换的时候, 某些数据不能直接转换为数值类型, 也会返回nan如 11- &quot;a &quot; // nan 而isNaN() 函数也会进行数据类型的转换, 它在处理的时候会去判断传入的变量值是否能转换为数字, 如果能转换为数字, 则会返回false, 如果无法转换则会返回true. 所以在 isNaN(&#123;&#125;) 返回true 的时候, 首先会对&#123;&#125; 进行类型转换, 但是&#123;&#125; 是一个字面量无法转换成数字,自然判断true 12345678910111213isNaN(NaN); // trueisNaN(undeﬁned); // trueisNaN(&#123;&#125;); // trueisNaN(true); // false，Number(true)会转换成数字1isNaN(null); // false，Number(null)会转换成数字0isNaN(1); // falseisNaN(&#x27;&#x27;); // false，Number(&#x27;&#x27;)会转换为成数字0isNaN(&quot;1&quot;); // false，字符串&quot;1&quot;可以转换成数字1isNaN(&quot;JavaScript&quot;); // true，字符串&quot;JavaScript&quot;无法转换成数字// Date类型isNaN(new Date()); // falseisNaN(new Date().toString()); // true 关于new Date() 函数生成的实例在转换为数值类型的时候 , 都会转换为对应的世界戳, 但是在调用toString 函数的时候, 返回的是一串字符串表示的时间, 无法转化成数值类型, 123const date = new Date();console.log( date); // 生成的是数字时间戳console.log(date.toString()); // 调用了toString()后返回的是字符串表示的时间戳 Number.isNaN()在全局环境中已经有了isNaN() 函数, 在es 6 为什么还要增加一个Number.isNaN() 函数呢,. 那是因为全局中的isNaN 会在传入的类型做类型转换, 而Number.isNaN 不会去做类型转换,你传入的是什么就是什么, 同样的代码在es5 isNaN 和es6 的Number.isNaN 的区别 12isNaN(&#123;&#125;) // trueNumber.isNaN(&#123;&#125;) // false 123456Number.isNaN(NaN); // trueNumber.isNaN(undeﬁned); // falseNumber.isNaN(null); // falseNumber.isNaN(true); // falseNumber.isNaN(&#x27;&#x27;); // falseNumber.isNaN(123); // false 兼容性如果在非es6 的环境中 需要用用到Number.isNan 函数呢, 123456789function myIsNaN() &#123; // 判断环境中是否存在Number.isNaN if (!Number.isNaN) &#123; // 如果环境中并不存在 , 那么创建一个函数 Number.isNaN = function(n)&#123; return n !== n; &#125; &#125;&#125; 在所有类型的数据中, 如果一个变量和自身做比较, 只有变量值在为NaN的时候 , 才会返回false , 其他时候都是返回true, 浮点型运算在javascript 中整数和浮点数都是属于Number 类型, 都统一采用64 位浮点数来进行存储.虽村存储数据的方式是一致,但是在进行浮点数运算的时候, 结果有时候却会有差异. 12345678910111213141516// 加法0.1 + 0.2 = 0.300000000000000040.7 + 0.1 = 0.7999999999999999// 减法1.5 - 1.2 = 0.300000000000000040.3 - 0.2 = 0.09999999999999998// 乘法0.7 * 180 = 125.999999999999999.7 * 100 = 969.9999999999999// 除法0.3 / 0.1 = 2.99999999999999960.69 / 10 = 0.06899999999999999 经典问题来了 0.1+0.2 不等于0.3 这是因为在JavaScript 是因为双精度浮点数来表示数字, 而双精度浮点数又存在精度问题, 在双精度浮点数中使用有限的二进制位数来表示实数,在有些情况系会出现舍入误差,而0.1, 0.2 在转换为二进制数的时候会产生无循环的小数, 所以在进行计算的时候会存在一些误差. 一个浮点数在计算机中长度为64位, 其中最高位为符号位, 接下来的11 位为 指数位, 最后的52 位为小数位, 即有效数字的部分. 因为使用64为存储, 除去 最高位0 位, 和11 位指数位, 接下来最多也就能存储52位的小数位, 对于一些无限循环的小数位浮点数, 也只会截取到钱52位,这也就是为什么前面说的会小出现舍入误差. 既然知道了为什么会出现这个问题, 那么我们来看看这个结果是这么在计算出来的. 首先在计算的过程中, 会将各个小数位按照乘 2 取整. 顺序排列的方法转换成2进制表示,具体做法, 就是用 2 乘以十进制小数得到积, 将积的部整数部分取出, 然后再用2 乘以余下的小数部分, 又得到一个积, 再将积的整数部分取出, 如此反复, 知道将积的小数部分为0 为止. 这时候把取出的整数部分按照顺序排列起来, 先取出的整数作为二进制小数的高位有效位, 后取的整数作作为地位有效位. 这时候来看看0.1 转换成二进制的过程 后面就是0.00011, 0011,0011, 如此反复 然后还要对0.2 开始二进制转换, 计算过程和上面差不多, 只不过是从0.2开始少了第一位的0 然后也是0.0011, 0011 不断反复. 这时候0.1 和0.2 开始相加, 转换成52 位精度的浮点型表示: 123 0.0001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 (0.1)+ 0.0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 (0.2)= 0.0100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 得到的结果就转换成十进制的值就是0.30000000000000004","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"},{"name":"阅读","slug":"阅读","permalink":"http://example.com/categories/%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"阅读","slug":"阅读","permalink":"http://example.com/tags/%E9%98%85%E8%AF%BB/"}]},{"title":"TypeScript","slug":"Typescript","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2023/10/04/Typescript/","link":"","permalink":"http://example.com/2023/10/04/Typescript/","excerpt":"","text":"","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"}]},{"title":"npm","slug":"npm","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2023/10/02/npm/","link":"","permalink":"http://example.com/2023/10/02/npm/","excerpt":"","text":"npm 下载源设置12345678910npm config get registry // 查看npm当前镜像源npm config set registry https://registry.npm.taobao.org/ // 设置npm镜像源为淘宝镜像yarn config get registry // 查看yarn当前镜像源yarn config set registry https://registry.npm.taobao.org/ // 设置yarn镜像源为淘宝镜像# https -&gt; http，这样网速就会好很多npm config set registry http://registry.npmjs.org","author":"chen","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"npm","slug":"npm","permalink":"http://example.com/categories/npm/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://example.com/tags/npm/"}]},{"title":"git","slug":"git","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2023/10/02/git/","link":"","permalink":"http://example.com/2023/10/02/git/","excerpt":"","text":"git 设置123git config --global user.name gitaccountgit config --global user.email gitaccount@example.com git 取消全局设置12345git config --global --unset user.namegit config --global --unset user.emailgit config --global user.name#全局配置账户已经移除git config --global user.email git 取消代理12git config --global --unset https.proxygit config --global --unset http.proxy error: RPC failed； curl 28 OpenSSL SSL_read: Connection was reset, errno 10054 fatal: expected 证书错误忽略证书错误 1git config --global http.sslVerify &quot;false&quot;","author":"chen","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"你不知道的javascript阅读笔记","slug":"你不知道的javascript阅读笔记","date":"un00fin00","updated":"un55fin55","comments":true,"path":"2023/10/01/你不知道的javascript阅读笔记/","link":"","permalink":"http://example.com/2023/10/01/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","excerpt":"","text":"对象在JavaScript 中对象可以通过两种形式定义,: 声明和构造形式. 对象声明: 1const obj = &#123;&#125; 构造声明 12cosnt obj = new Object();obj.value = value 上面两种生成的对象是一样. 区别只在在于, 在对象声明中我们可以一次性添加多个键值对, 而构造声明需要诸葛添加属性 对象类型在JavaScript 中主要有六种数据类型: string number boolean null undefined object 在上面的(string, boolean, number, null, undefined) 本省并不是一个对象, null 又时候虽然也被当做一个对象, 但这其实本身是语言的一个bug,是因为对null 执行 type of 的时候会返回字符串“object”, 但严格意义来说null 本身属于基本类型. JavaScript 中的函数也属于对象的一个子类型, 内置对象 String Number Boolean Object Function Array Date RegExp Error 对象键值对象的内容本身是由任意类型的值,组成的我们统称为属性, 在需要访问对象的值的时候我们通常使用. 操作符, 或者[] 操作符来访问. 其中前者被称为属性访问, 后者被称为见访问. 1234567const obj = &#123; a: 2,&#125;;// 点操作符console.log(obj.a);// 属性操作console.log(obj[&#x27;a&#x27;]); 这两种属性访问的区别在于,. 操作符需要满足标识符的命名规范, 而[“”] 操作符, 可以接受任何UTF-8&#x2F;Unicode字符串为属性名. 在对象中属性永远都是字符串,即使使用string 意外的字面量为属性名, 但是他也会隐性转换为字符串 12345cosnt obj = &#123; 2: a &quot;2&quot;:b&#125; 属性和方法在JavaScript 中如果访问的对象属性是一个函数在其他语言中, 在理解中这个函数可以被称为对象的访问, 但是在JavaScript 语法规范中, 函数永远不会属于一个对象,. 这是因为函数具有this的引用, 虽然有时这些this 确实会指向调用位置的对象引用. 但是JavaScript 的 this 是在运行时根据调用位置动态绑定, 函数和对象的关系只能称为间接关系 1234567891011function foo() &#123; console.log(&#x27;foo&#x27;);&#125;const someFoo = foo;const myObject = &#123; someFoo: foo,&#125;;foo();console.log(someFoo);console.log(myObject.someFoo); 正如上面的代码中, someFoo 和 Object.someFoo 中都是对同一个函数 foo 的引用, 同理这也能说明 对象中的函数,它并不是属于对象的一个方法. 对象复制Object.assign()对象的复制分为浅拷贝和深拷贝. 浅拷贝: 12const obj = &#123;a: 1&#125;const newobj = Object.assign(&#123;&#125;, obj) 1234567891011var person1 = &#123; name: &#x27;p1&#x27;, age: 18, &#125;; var person2 = &#123;&#125;; for (const key in person1) &#123; person2[key] = person1[key]; &#125; person2.name = &#x27;p2&#x27;; console.log(person1, person2); 深拷贝 1234567891011121314151617181920function deepClone(origin, target) &#123; var target = target || &#123;&#125;; var toStr = Object.prototype.toString; var arrType = &#x27;[object Array]&#x27;; for (const key in origin) &#123; if (origin.hasOwnProperty(key)) &#123; if (typeof origin[key] === &#x27;object&#x27; &amp;&amp; origin[key] !== null) &#123; if (toStr.call(origin[key]) === arrType) &#123; target[key] = []; &#125; else &#123; target[key] = &#123;&#125;; &#125; deepClone(origin[key], target[key]); &#125; else &#123; target[key] = origin[key]; &#125; &#125; &#125; return target; &#125; JSON 拷贝 123456789101112131415```### 对象属性描述符 getOwnPropertyDescriptor在ES5 之前, javascript 本身没有提供可以直接检测属性特性的方法, 比如判断属性是否只读, 但是从es5开始, 所有的属性都具备了属性描述符.`getOwnPropertyDescriptor` 来查看对象属性```javascriptconst obj = &#123; a: 2,&#125;;Object.getOwnPropertyDesscriptor(&#x27;obj&#x27;, &quot;a&quot;) // &#123; value: 2, writable: true, enumerable: true, configurable: true &#125; 返回的对象包含了, 该对象的属性描述 value : 表示该属性的值 writable: 表示该值是否可以 更改 enumerable: 表示该值是否可以枚举 configurable: 表示该值是否可以配置 getOwnPropertyDescriptors 产看该对对象的所有属性描述 12345678910 const obj = &#123; a: 2, b: 2,&#125;;console.log(Object.getOwnPropertyDescriptors(obj));//&#123; a: &#123; value: 2, writable: true, enumerable: true, configurable: true &#125;, b: &#123; value: 2, writable: true, enumerable: true, configurable: true &#125;&#125; 上面的对象时我们我自己声明了一个对象, 看到声明对象的属性个的默认配置, 全部为true, 那么是否是在任何时候对象的属性描述都是true呢? 在创建普通属性时, 属性描述符都是使用的默认值,默认值都为true, 那么在使用Object.defineProperty 给一个对象添加属性或者修改一个属性,(如果configurable : true的话) 12345678910const obj = &#123;&#125;;Object.defineProperty(obj, &#x27;a&#x27;, &#123; value: 2,&#125;);console.log(Object.getOwnPropertyDescriptors(obj));//&#123; a: &#123; value: 2, writable: false, enumerable: false, configurable: false &#125;&#125; 上面代码可以看到在使用Object.difinePeoperty 为对象添加的属性在不显式执行描述符的时候, 该属性描述符这时候为false,当然也可以在对象添加对属性的时候, 显示的指定的添加. 1234567const obj = &#123;&#125;;Object.defineProperty(obj, &#x27;a&#x27;, &#123; value: 2, writable: true, enumerable: true, configurable: true,&#125;); 对象禁止扩展Object.preventExtensions(..)禁止一个对象添加属性, 并且保留自己的属性, 在非严格模式下, 创建新属性会静默失败, 在严格模式下, 会抛出typeError 错误 12345678910const obj = &#123; a: 2,&#125;;Object.preventExtensions(obj);obj.b = 3;console.log(Object.getOwnPropertyDescriptors(obj));// 可以看到新添加的属性无法添加进去&#123; a: &#123; value: 2, writable: true, enumerable: true, configurable: true &#125;&#125; 对象密封 Object.seal()该方法是在Object.preventExtensions 的扩展,把现有对象属性的描述符configurable 标记改为false. 在使用该方法后 , 不仅不能添加新符属性,, 也不能重新配置或者删除现有属性, 但是可以修改现有属性值 1234567891011const obj = &#123; a: 2,&#125;;//Object.seal() 前// a: &#123; value: 2, writable: true, enumerable: true, configurable: true &#125;console.log(Object.getOwnPropertyDescriptors(obj));// Object.seal() 后//a: &#123; value: 2, writable: true, enumerable: true, configurable: false &#125;Object.seal(obj);console.log(Object.getOwnPropertyDescriptors(obj)); 对象冻结Object.freeze()该方法h会在现有对象上调用Object.seal 把数据属性标记为 writable: fale 使用了该方法可以禁止该对象本身任意属性的直接修改, 但是对象用用的其他对象不受影响. 12345678910111213const obj = &#123; a: 2,&#125;;// Object.frreze 前// a: &#123; value: 2, writable: true, enumerable: true, configurable: true &#125;console.log(Object.getOwnPropertyDescriptors(obj));// Object.freeze 后// a: &#123; value: 2, writable: false, enumerable: true, configurable: false &#125;Object.freeze(obj);console.log(Object.getOwnPropertyDescriptors(obj));// 修改属性本身也是失败obj.a = 3;console.log(obj.a); // 2 在冻结之前对象引用 1234567891011const obj = &#123;a : 1&#125;// 在冻结之前浅拷贝复制一个对象const newObj = Object.assign(&#123;&#125;, obj)Object.freeze(obj)// a: &#123; value: 2, writable: false, enumerable: true, configurable: false &#125;console.log(Object.getOwnPropertyDescriptors(obj));// a: &#123; value: 2, writable: true, enumerable: true, configurable: true &#125;console.log(Object.getOwnPropertyDescriptors(newObj));// 修改成功newObj.a = 2; 对象解冻Object.isFrozen该方法判断一个对象是否被冻结, 如果被冻结,将返回true. 123if(Object.isFrozen(obj))&#123;&#125; 对象枚举在对象属性描述中有一个属性: enumerable 配置对象属性是否可以枚举, 1234567891011121314151617181920212223const obj = &#123;&#125;;Object.defineProperties(obj, &#123; a: &#123; value: 1, // 可枚举 enumerable: true, &#125;, b: &#123; value: 2, // 不可枚举 enumerable: false, &#125;,&#125;);// 属性访问全部都能正常访问console.log(obj.a, obj.b)console.log(&quot;b&quot; in obj)obj.hasOwnProperty(&quot;b&quot;)// 遍历对象for(let key in obj)&#123; // a: 1 console.log(k, obj[k])&#125; 在上面的代码中 , 使用了Object.defineProperties 配置了a, b 两个属性, 一个enumerable 配置为false, 一个配置了true,在我们使用了. 访问的时候, 是都能访问到全部属性的, 但是在 for 循环中却只出现了一个属性a 如果需要判断一个属性在对象中是否可以枚举:propertyIsEnumerable() 该方法会检查给定的属性是否直存在对象中, (不会检查原型链) 12obj.propertyIsEnumerable(&quot;a&quot;)// trueobj.propertyIsEnumerable(&quot;b&quot;)// false 至于in 和hasOwnProperty 也可以判断一个属性是否存在对象中, 他们的区别在于, in 只会判断对象本身自身是否包含, hasOwnProperty 则会查找原型链 下面的方法, 要可以枚举对象的属性 Object.keys()该方法会返回一个数组, 包含所有可枚举的属性 1Object.keys(obj) Object.gerOwnProeprtyNames()该方法也会返回指定对象中所有的属性, 无论是否可以枚举 对象遍历混合对象“类”在面向对象对象编程语言中, 关于对象一直有着这几种机制: 多态, 类, 继承, 封装 类描述了对象的属性(数据)和方法(行为,) 类也是对象的抽象 多态: 描述了对象可以根据上下文的不同的表现的多种状态, 可以使用类定义或接口定义的抽象类型的子类对象, 极大的提高了对象的灵活性和扩展性 继承: 允许一个类继承另外一个类, 通过继承子类可以重用父类的代码, 并可以扩展或修改父类的行为 封装: 指的是将数据和操作数据的行为包装在一起的机制, 以防止外部直接访问和修改对象内部的状态. 通过封装, 内部的对象细节对外是影藏的, 只提供公共接口来给其他对象使用 在hjavascript 中想要实现一个类: 12345678function Car()&#123; this.color = &quot;red&quot;; this.show = function()&#123; console.log(this.color) &#125;&#125;const car = new Car()car.show() 在以前都是使用构造函数来生成一个类,然后new 一个实例出来 原型[[prototype]][[prototype]] 是javascript 对象的内置属性, 他是对象之间继承关系的基础, 在javascript 中, 每一个对象都有一个[[prototype]] , 它指向另外一个对象或者为null . 这个指向的对象被称为原型prototype 当我们访问一个对象的属性时, 如果该对象本身没有该属性, 那么javascript 就会一层层的自动向上去原型上查找,称之为原型链 123456const obj1 = &#123; name: &#x27;obj1name&#x27;,&#125;;const obj2 = &#123; value: &#x27;obj2value&#x27;,&#125;; 上面的代码可以看到这时候两个obj 的prototype 指向的是Object 我们使Object.setPrototypeOf() 设置一下原型 12// 将obj1 ,设置为obj2 的原型Object.setPrototypeOf(obj2, obj1) 这时候呢个看到obj2 上的原型属性已经变为obj1 的属性了. 每一个Object.prototype 的顶部都是Object的 原型 类在严格意义上来说javascript 是一个只有对象没有类的语言. 因为javascript 的无法创造类, 即使后面推出了class 之流的关键字, 但是本质上依旧是原型的改版而已 构造函数原型继承在javscript 中经常使用模拟类的行为的方法,但是只有类不能继承的话, 那就是一个空架子, 虽然在es5 之后推出了extend 关键字来解决了类的继承问题. 那在es5 之前是这么解决的呢~ 行为委托类型异步","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"},{"name":"阅读","slug":"阅读","permalink":"http://example.com/categories/%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"阅读","slug":"阅读","permalink":"http://example.com/tags/%E9%98%85%E8%AF%BB/"}]},{"title":"javascript 高级程序设计阅读笔记","slug":"javascript 高级程序设计阅读笔记","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2023/10/01/javascript 高级程序设计阅读笔记/","link":"","permalink":"http://example.com/2023/10/01/javascript%20%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"},{"name":"阅读","slug":"阅读","permalink":"http://example.com/categories/%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"阅读","slug":"阅读","permalink":"http://example.com/tags/%E9%98%85%E8%AF%BB/"}]},{"title":"hexo","slug":"hexo配置","date":"un66fin66","updated":"un00fin00","comments":true,"path":"2023/09/30/hexo配置/","link":"","permalink":"http://example.com/2023/09/30/hexo%E9%85%8D%E7%BD%AE/","excerpt":"","text":"关于hexo git 上传老是超时报错在配置完hexo 上传发布到 git 的时候老是会报错ssl, 超时错误. 这时候可以修改hexo 根目录下的_config.yml的 deploy 项的repo 下面是默认的 1## repo: https://github.com/rongchaoChen/rongchaoChen.github.io.git 修改成 12repo: git@github.com:git用户名/git用户名.github.io hexo 文章模版12345678titile:文章名称author: chencategories: [文章分类]tag: &quot;文章标签&quot;文章摘要&lt;!--more --&gt;正文 page 独立页面 post 文章页面 docs 文档页面 category 分类页面 tag 标签页面 friends 友链页面 list 列表页面 文章布局文章分类多个分类有两种关系，一种是层级（等同于文件夹），一种是并列（等同于标签）。 多级分类： 1categories: [分类A, 分类B] 或者 123categories: - 分类A - 分类B 并列分类 123categories: - [分类A] - [分类B] 多级加并列分类 123categories: - [分类A, 分类B] - [分类C, 分类D]","categories":[{"name":"-hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"javascript this","slug":"javascript this","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2023/04/09/javascript this/","link":"","permalink":"http://example.com/2023/04/09/javascript%20this/","excerpt":"","text":"this在javascript 中, 因为是一门弱类型语言, 在很多时候, 总是会和强类型语言,如java python 这种强类型语言又着一些很不同的区别. 就如this 而言, 在常规认知理解中, this 顾名思义从英语的语法角度来说 把他理解成指向函数的本身.但是事实真的是这样的吗. 首先我们来看下面这段代码: 1234567891011function foo(num)&#123; console.log(&quot;foo:&quot; + num) this.count++;&#125;foo.count= 0for(let i = 0; i &lt; 10 ; i++)&#123; if(i&gt; 5)&#123; foo(i) &#125;&#125;console.log(foo.count) 在上面的代码中我们声明了一个foo ()函数, 并给foo()函数传递了一个形参,在函数内部中我们打印了这个传递进来的形参,并调用了一个count的参数, 来记录当前foo()函数被调用的次数, 在外面for()循环中, 当i &gt; 5 的时候, 这时候i 就会传递进去foo(num)形参当中, 最后我们consloe.log(foo.count)来记录foo()一共被调用了几次. 运行代码的结果如下: 12345foo: 6foo: 7foo: 8foo: 9count: 0 count 为什么是0呢?从输出结果来看foo()函数确实是被被调用了四次, 但是里面的this.count++ , 却没有增加.那是因为this.count 的this 的本身没有指向foo() 函数半身. 可是我在外面已经foo.count &#x3D; 0; 声明了啊 首先我们来看foo()本身的this, 其实是指向 全局的, this.count 也就相当于说是在全局创建了一个count 的变量.当我们在调用foo 函数的时候, foo.count是会被自增的, 但是它所在的对象this.count 却不会自增.那么我该怎么解决呢! 首先我们可以把foo 函数中的this.count .改成foo.count . 这时候虽然能解决当下的问题, 但是却没有解决实质性的问题, 如何指向当前的this. callcall函数 使用一个指定的this 值和单独给出的一个或多个参数来调用一个函数.那么来改变一下上面的代码 1234567891011121314function foo(num)&#123; console.log(&quot;foo:&quot; + num) // 因为当前this 不指向foo 函数本身 this.count++;&#125;foo.count= 0for(let i = 0; i &lt; 10 ; i++)&#123; if(i&gt; 5)&#123; // 那么在这里使用call 函数让this指向foo 函数 foo.call(foo,i) &#125;&#125;// 这时候输出结果符合我们console.log(foo.count) -","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"intellij配置Tomcat","slug":"intellij配置Tomcat","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2023/03/26/intellij配置Tomcat/","link":"","permalink":"http://example.com/2023/03/26/intellij%E9%85%8D%E7%BD%AETomcat/","excerpt":"","text":"记录一下intellij配置Tomcat, 首先intellij 和 tomcat 是肯定要的, intellij 版本为2022.1 ,tomcat为9. 第一步打开Intellij这时后在打开的目录下, 创建一个 new module, 选择java , 然后next 输入这个mdoule 名就好 然后再这个新module 上右键选择 Add Framewrok Support 选择 然后这时候的目录就是这样,然后我们再WEB-INF下面创建一个lib 文件和一个classes 文件 , lib 用来解压tomcat的jar包, classes,这时候我们的目录就搭建好了, 开始配置Tomcat 配置Tomcat注意Tomcat 和TomEE 不要选错 , 然后点击local 确认 这时候来到这里 选择自己安装好的Tomcat, 这时候再点击Deployment 项目设置 这里Jar 包的目录选择之前创建的lib 文件中, 然后点击Paths把再把之前创建好的classes 文件设置成output path 的路径 然后启动Tomcat j就好了","categories":[{"name":"intellij","slug":"intellij","permalink":"http://example.com/categories/intellij/"},{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"webpack/vue","slug":"webpack-vue","permalink":"http://example.com/tags/webpack-vue/"}]},{"title":"webpack4配置vue2\\3","slug":"webpack4配置vue23","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2023/03/26/webpack4配置vue23/","link":"","permalink":"http://example.com/2023/03/26/webpack4%E9%85%8D%E7%BD%AEvue23/","excerpt":"","text":"这样配置的时候适合再学习vu2&#x2F;3 学习切换的时候,到时就不用切换项目,只要每次重新配置一下webpack.config.js 就可以了. vue2配置首先我们创建一个文件. 在根目录下初始化文件 1npm init 创建vue 目录文件夹, src, public.在publuc 目录下创建index.html,引入vue2 cdn 12&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&#x27;app&#x27;&gt;&lt;/div&gt; 然后我们在 src 目录下创建一个main.js 来作为我们的入口文件 然后开始下载依赖. 1234567webpack@4.44.2webpack-cli@3.3.12webpack-dev-server@3.11.2html-webpack-plugin@4.5vue-template-compiler@2.7.14vue-loader@15.0-15.9 然后我们开始配置webpack.config.js 12345678910111213141516171819202122232425262728293031const &#123; resolve &#125; = require(&#x27;path&#x27;);const htmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);// 注意这里的vue-loader 一定要在16.0版本一下, 不然版本不兼容const VueLoaderPlugin = require(&#x27;vue-loader/lib/plugin&#x27;);module.exports = &#123; mode: &#x27;development&#x27;, entry: &#x27;./src/main.js&#x27;, output:&#123; path: resolve(__dirname, &#x27;dist&#x27;), filename: &#x27;main.js&#x27; &#125;, externals:&#123; &#x27;vue&#x27;: &#x27;Vue&#x27; &#125;, devtool: &#x27;source-map&#x27;, module:&#123; rules:[ &#123; test: /\\.vue$/, loader: &#x27;vue-loader&#x27; &#125; ] &#125;, plugins:[ new VueLoaderPlugin(), new htmlWebpackPlugin( &#123; template:resolve(__dirname,&#x27;public/index.html&#x27;) &#125;), ]&#125; 在main.js 创建Vue的实例挂载 12345import App from &#x27;./App.vue&#x27;new Vue(&#123; render:h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;) 在src 下创建一个App.vue 1234567891011121314&lt;template&gt;&lt;div&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;App&quot;, data()&#123; return &#123; title: &quot;hello word vue2&quot; &#125; &#125;&#125;&lt;/script&gt; 修改package.json, 位置启动项webpack-server-cli 123&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server&quot; &#125;, 这时候,如果没有出现插件兼容的问题, 基本就是没问题,可以npm run dev 启动了 vue3 配置在切换vue 的3 我们主要是替换vue-loader 就好了 下载@vue&#x2F;compiler-sfc&#96;是Vue.js 3的一个核心软件包, 而且这时候vue-loader 也要更新16.0 以上的版本最好不要17,不然需要处理兼容性 12vue-loader@next@16.1.1npm i -d @vue/compiler-sfc@3.1.2 下载好插件后, 修改一下webpack.config.js 123const VueLoaderPlugin = require(&#x27;vue-loader/lib/plugin&#x27;);// 这时候需要把之前引用vu2 的loader 修改成const &#123;VueLoaderPlugin&#125; = require(&#x27;vue-loader&#x27;); 然后修改main.js 的vue 挂载方式 1Vue.createApp(App).mount(&#x27;#app&#x27;) 修改index.html 中vue的cdn 引入 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@3.1.2/dist/vue.global.js&quot;&gt;&lt;/script&gt; 然后重新启动npm run dev vue2 和vue3 切换在配置好以后, 以后在这项目中, 每次切换的时候需要 修改index.html 的Vue cdn 引用 1234// vue 2&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.js&quot;&gt;&lt;/script&gt;// vue3&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@3.1.2/dist/vue.global.js&quot;&gt;&lt;/script&gt; 修改webcpack.comfig.js 1234// vue2 loader// const VueLoaderPlugin = require(&#x27;vue-loader/lib/plugin&#x27;);// vue3 loaderconst &#123; VueLoaderPlugin &#125; = require(&#x27;vue-loader&#x27;); 注意每次vue 2 切换 3 的时候,vue-loader 都要重新下载依赖 12345678910// vue2 切换3vue-loader@next@16.1.1npm i -d @vue/compiler-sfc@3.1.2vue3 切换vue2 vue-loader@15.0-15.9 总结其实在官网说明现在说明建议使用脚手架来构建了 1npm init vue@latest 而且在vue3 @vue&#x2F;compiler-sfc 核心包,已经停止维护了, 但是这样搭建也可以在学习2&#x2F;3 的时候方便切换,","categories":[{"name":"webpack","slug":"webpack","permalink":"http://example.com/categories/webpack/"}],"tags":[{"name":"webpack/vue","slug":"webpack-vue","permalink":"http://example.com/tags/webpack-vue/"}]},{"title":"hello","slug":"hello","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/03/25/hello/","link":"","permalink":"http://example.com/2023/03/25/hello/","excerpt":"","text":"这是标题1这是标题2这是标题2这是标题3这是标题3这是标题3这是标题2这是标题3这是标题3这是标题3这是标题2这是标题3这是标题3这是标题3","categories":[{"name":"测试分类","slug":"测试分类","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB/"}],"tags":[]},{"title":"tt","slug":"tt","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/03/25/tt/","link":"","permalink":"http://example.com/2023/03/25/tt/","excerpt":"","text":"这是h1 标题 Lorem ipsum dolor sit amet consectetur adipisicing elit. Incidunt aliquid soluta debitis, autem pariatur aut optio laboriosam nulla eius, nisi quibusdam praesentium dicta laudantium! Assumenda a dolor cum autem porro. 这也是h1 标题 Lorem ipsum dolor sit amet consectetur adipisicing elit. Incidunt aliquid soluta debitis, autem pariatur aut optio laboriosam nulla eius, nisi quibusdam praesentium dicta laudantium! Assumenda a dolor cum autem porro. 12let n = 1;console.log(n) h2 标题22 h2标题22 h1标题11 h2标题11","categories":[{"name":"测试分类","slug":"测试分类","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB/"}],"tags":[]},{"title":"tt copy","slug":"tt copy","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/03/25/tt copy/","link":"","permalink":"http://example.com/2023/03/25/tt%20copy/","excerpt":"","text":"这是h1 标题 Lorem ipsum dolor sit amet consectetur adipisicing elit. Incidunt aliquid soluta debitis, autem pariatur aut optio laboriosam nulla eius, nisi quibusdam praesentium dicta laudantium! Assumenda a dolor cum autem porro. 这也是h1 标题 Lorem ipsum dolor sit amet consectetur adipisicing elit. Incidunt aliquid soluta debitis, autem pariatur aut optio laboriosam nulla eius, nisi quibusdam praesentium dicta laudantium! Assumenda a dolor cum autem porro. 12let n = 1;console.log(n)","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[]},{"title":"test","slug":"test","date":"un44fin44","updated":"un66fin66","comments":true,"path":"2022/08/25/test/","link":"","permalink":"http://example.com/2022/08/25/test/","excerpt":"","text":"","categories":[{"name":"web前端","slug":"web前端","permalink":"http://example.com/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":" test","slug":"test","permalink":"http://example.com/tags/test/"}]},{"title":"hexo网站配置","slug":"hexo网站配置","date":"un33fin33","updated":"un00fin00","comments":true,"path":"2022/03/16/hexo网站配置/","link":"","permalink":"http://example.com/2022/03/16/hexo%E7%BD%91%E7%AB%99%E9%85%8D%E7%BD%AE/","excerpt":"","text":"1:安装gitbash2: 打开gitbash 设置user.name和email&#96;&#96; 12git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot; 3: 生成秘钥和github绑定4:安装node5: 安装hexo&#96;&#96; 1npm install -g hexo-cli 6:然后新建一个新的空文件,进入到新建的空文件初始化&#96;&#96; 1hexo init blog 然后测试 &#96;&#96; 12345hexo new test_my_site // 新建一篇文章hexo g // hexo generate #生成hexo s // 打开本地服务器 如果不出意外 服务器启动成功,显示访问端口: localhost: 4000 主题配置https://github.com/litten/hexo-theme-yilia 根据文档主题待定","categories":[],"tags":[]}],"categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"},{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"},{"name":"阅读","slug":"阅读","permalink":"http://example.com/categories/%E9%98%85%E8%AF%BB/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/categories/TypeScript/"},{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"npm","slug":"npm","permalink":"http://example.com/categories/npm/"},{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"},{"name":"-hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"},{"name":"intellij","slug":"intellij","permalink":"http://example.com/categories/intellij/"},{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"webpack","slug":"webpack","permalink":"http://example.com/categories/webpack/"},{"name":"测试分类","slug":"测试分类","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB/"},{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"},{"name":"web前端","slug":"web前端","permalink":"http://example.com/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"},{"name":"阅读","slug":"阅读","permalink":"http://example.com/tags/%E9%98%85%E8%AF%BB/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"},{"name":"npm","slug":"npm","permalink":"http://example.com/tags/npm/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"},{"name":"webpack/vue","slug":"webpack-vue","permalink":"http://example.com/tags/webpack-vue/"},{"name":" test","slug":"test","permalink":"http://example.com/tags/test/"}]}